diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
index 12dd1874e83..5127f00ca9b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
@@ -73,6 +73,7 @@ OptionDatabase::OptionDatabase(Architecture *g)
   registerOption(new OptionCommentStyle());
   registerOption(new OptionCommentHeader());
   registerOption(new OptionCommentInstruction());
+  registerOption(new OptionIndentationStyle());
   registerOption(new OptionIntegerFormat());
   registerOption(new OptionCurrentAction());
   registerOption(new OptionAllowContextSet());
@@ -537,6 +538,18 @@ string OptionCommentInstruction::apply(Architecture *glb,const string &p1,const
   return "Instruction comment type "+p1+" turned "+prop;
 }
 
+/// \class OptionIndentationStyle
+/// \brief Set the style of indentation emitted by the decompiler
+///
+/// The first parameter is either "allman", or "kr", other styles could be
+/// supported in the future 
+string OptionIndentationStyle::apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const
+
+{
+	glb->print->setIndentationStyle(p1);
+	return "Indentation style set to "+p1;
+}
+
 /// \class OptionIntegerFormat
 /// \brief Set the formatting strategy used by the decompiler to emit integers
 ///
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
index b18e0a1b46b..472c2b44add 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
@@ -192,6 +192,12 @@ public:
  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
 };
 
+class OptionIndentationStyle : public ArchOption {
+public:
+  OptionIndentationStyle(void) { name = "indentationstyle"; }	///< Constructor
+  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+};
+
 class OptionIntegerFormat : public ArchOption {
 public:
   OptionIntegerFormat(void) { name = "integerformat"; }	///< Constructor
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
index 79da4cfa313..f33c7d09b41 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
@@ -1828,7 +1828,7 @@ void PrintC::emitStructDefinition(const TypeStruct *ct)
   emit->print("typedef struct",EmitXml::keyword_color);
   emit->spaces(1);
   int4 id = emit->startIndent();
-  emit->print("{");
+  emitFormattedStartBrace(id);
   emit->tagLine();
   iter = ct->beginField();
   while(iter!=ct->endField()) {
@@ -1867,7 +1867,7 @@ void PrintC::emitEnumDefinition(const TypeEnum *ct)
   emit->print("typedef enum",EmitXml::keyword_color);
   emit->spaces(1);
   int4 id = emit->startIndent();
-  emit->print("{");
+  emitFormattedStartBrace(id);
   emit->tagLine();
   iter = ct->beginEnum();
   while(iter!=ct->endEnum()) {
@@ -2056,6 +2056,17 @@ void PrintC::setCommentStyle(const string &nm)
     throw LowlevelError("Unknown comment style. Use \"c\" or \"cplusplus\"");
 }
 
+void PrintC::setIndentationStyle(const string &nm)
+
+{
+  if (nm=="kr")
+    option_indentationStyle = indentation_style_kr;
+  else if (nm=="allman")
+    option_indentationStyle = indentation_style_allman;
+  else
+    throw LowlevelError("Unknown indentation style. Use \"kr\" or \"allman\"");
+}
+
 /// \brief Emit the definition of the given data-type
 ///
 /// This is currently limited to a 'struct' or 'enum' definitions. The
@@ -2353,6 +2364,8 @@ void PrintC::docFunction(const Funcdata *fd)
     emit->tagLine();
     emit->tagLine();
     int4 id = emit->startIndent();
+    // Intentionally not using a formatted start brace
+    // Currently supported indentation styles both place a function's opening brace on a new line
     emit->print("{");
     emitLocalVarDecls(fd);
     if (isSet(flat))
@@ -2608,7 +2621,7 @@ void PrintC::emitBlockIf(const BlockIf *bl)
   setMod(no_branch);
   emit->spaces(1);
   int4 id = emit->startIndent();
-  emit->print("{");
+  emitFormattedStartBrace(id);
   int4 id1 = emit->beginBlock(bl->getBlock(1));
   bl->getBlock(1)->emit(this);
   emit->endBlock(id1);
@@ -2620,7 +2633,7 @@ void PrintC::emitBlockIf(const BlockIf *bl)
     emit->print("else",EmitXml::keyword_color);
     emit->spaces(1);
     int4 id = emit->startIndent();
-    emit->print("{");
+    emitFormattedStartBrace(id);
     int4 id2 = emit->beginBlock(bl->getBlock(2));
     bl->getBlock(2)->emit(this);
     emit->endBlock(id2);
@@ -2715,7 +2728,7 @@ void PrintC::emitBlockWhileDo(const BlockWhileDo *bl)
     emit->closeParen(')',id1);
     emit->spaces(1);
     indent = emit->startIndent();
-    emit->print("{");
+    emitFormattedStartBrace(indent);
     pushMod();
     setMod(no_branch);
     condBlock->emit(this);
@@ -2746,7 +2759,7 @@ void PrintC::emitBlockWhileDo(const BlockWhileDo *bl)
     emit->closeParen(')',id1);
     emit->spaces(1);
     indent = emit->startIndent();
-    emit->print("{");
+    emitFormattedStartBrace(indent);
   }
   setMod(no_branch); // Dont print goto at bottom of clause
   int4 id2 = emit->beginBlock(bl->getBlock(1));
@@ -2771,7 +2784,7 @@ void PrintC::emitBlockDoWhile(const BlockDoWhile *bl)
   emit->print("do",EmitXml::keyword_color);
   emit->spaces(1);
   int4 id = emit->startIndent();
-  emit->print("{");
+  emitFormattedStartBrace(id);
   pushMod();
   int4 id2 = emit->beginBlock(bl->getBlock(0));
   setMod(no_branch);
@@ -3025,7 +3038,7 @@ void PrintC::emitBlockSwitch(const BlockSwitch *bl)
   bl->getSwitchBlock()->emit(this);
   popMod();
   emit->spaces(1);
-  emit->print("{");
+  emitFormattedStartBrace(0);
 
   for(int4 i=0;i<bl->getNumCaseBlocks();++i) {
     emitSwitchCase(i,bl);
@@ -3051,6 +3064,37 @@ void PrintC::emitBlockSwitch(const BlockSwitch *bl)
   popMod();
 }
 
+/// \brief Emits an opening brace according to the indentation style selected in options
+///
+/// \param indent is the current indent level
+int4 PrintC::emitFormattedStartBrace(int4 indent)
+
+{
+  switch(option_indentationStyle) {
+  case indentation_style_allman:
+
+    // Reduce one layer of indentation, emit new line, emit opening brace, update new indentation
+    if (indent) {
+  	 emit->stopIndent(indent);
+  	}
+  	
+  	emit->tagLine();
+    emit->print("{");
+    
+    emit->startIndent();
+    break;
+
+  case indentation_style_kr:
+
+    // Emit opening brace, indentation is unaffected
+    emit->print("{");
+    break;
+
+  default:
+    throw LowlevelError("Unknown indentation style");
+  }
+}
+
 /// \brief Create a generic function name base on the entry point address
 ///
 /// \param addr is the entry point address of the function
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
index 92afe1ee1e9..e1dcac8a0d6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
@@ -62,6 +62,11 @@ struct PartialSymbolEntry {
 ///  - etc.
 class PrintC : public PrintLanguage {
 protected:
+  /// \brief Possible types of indentation style
+  enum indentation_style {
+    indentation_style_kr = 0,		/// K&R style indentation
+    indentation_style_allman = 1    /// Allman styles indentation
+  };
   static OpToken hidden;		///< Hidden functional (that may force parentheses)
   static OpToken scope;			///< The sub-scope/namespace operator
   static OpToken object_member;		///< The \e member operator
@@ -119,6 +124,7 @@ protected:
   bool option_nocasts;		///< Don't print a cast if \b true
   bool option_unplaced;		///< Set to \b true if we should display unplaced comments
   bool option_hide_exts;	///< Set to \b true if we should hide implied extension operations
+  indentation_style option_indentationStyle;  ///< Set to the prefered type of indentation style
   string nullToken;		///< Token to use for 'null'
   CommentSorter commsorter;	///< Container/organizer for comments in the current function
 
@@ -210,6 +216,7 @@ public:
   virtual void adjustTypeOperators(void);
   virtual void setCommentStyle(const string &nm);
   virtual void docTypeDefinitions(const TypeFactory *typegrp);
+  virtual void setIndentationStyle(const string &nm);
   virtual void docAllGlobals(void);
   virtual void docSingleGlobal(const Symbol *sym);
   virtual void docFunction(const Funcdata *fd);
@@ -225,6 +232,7 @@ public:
   virtual void emitBlockDoWhile(const BlockDoWhile *bl);
   virtual void emitBlockInfLoop(const BlockInfLoop *bl);
   virtual void emitBlockSwitch(const BlockSwitch *bl);
+  virtual int4 emitFormattedStartBrace(int4 indent);
 
   virtual void opCopy(const PcodeOp *op);
   virtual void opLoad(const PcodeOp *op);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
index e06c7c4abdb..8eb789a4e35 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
@@ -439,6 +439,11 @@ public:
   /// \param nm is the configuration description
   virtual void setCommentStyle(const string &nm)=0;
 
+  /// \brief Set the indentation style used in the decompiler output
+  ///
+  /// \param nm is the configuration description
+  virtual void setIndentationStyle(const string &nm)=0;
+
   /// \brief Emit definitions of data-types
   ///
   /// \param typegrp is the container for the data-types that should be defined
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
index c71ef521592..9b14b61a8b3 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
@@ -238,6 +238,34 @@ public String toString() {
 		"If set, the entry point plate comment is displayed as " + "a function header comment.";
 	private final static boolean COMMENTHEAD_OPTIONDEFAULT = true;	// Must match PrintLanguage::resetDefaultsInternal
 	private boolean commentHeadInclude;
+	
+	private final static String INDENTATIONSTYLE_OPTIONSTRING = "Display.Indentation style";
+	private final static String INDENTATIONSTYLE_OPTIONDESCRIPTION = "The indentation style to be used";
+	
+	public enum IndentationStyleEnum {
+		
+		KR("kr", "K&R style"), Allman("allman", "Allman style");
+		
+		private String label;
+		private String optionString;
+		
+		private IndentationStyleEnum(String optString, String label) {
+			this.label = label;
+			this.optionString = optString;
+		}
+
+		public String getOptionString() {
+			return optionString;
+		}
+		
+		@Override
+		public String toString() {
+			return label;
+		}
+	}	
+
+	private final static IndentationStyleEnum INDENTATIONSTYLE_OPTIONDEFAULT = IndentationStyleEnum.KR;
+	private IndentationStyleEnum indentationStyle;
 
 	public enum NamespaceStrategy {
 		Minimal("minimal", "Minimally"), All("all", "Always"), Never("none", "Never");
@@ -391,6 +419,7 @@ public DecompileOptions() {
 		commentWARNInclude = COMMENTWARN_OPTIONDEFAULT;
 		commentHeadInclude = COMMENTHEAD_OPTIONDEFAULT;
 		namespaceStrategy = NAMESPACE_OPTIONDEFAULT;
+		indentationStyle = INDENTATIONSTYLE_OPTIONDEFAULT;
 		integerFormat = INTEGERFORMAT_OPTIONDEFAULT;
 		keywordColor = HIGHLIGHT_KEYWORD_DEF;
 		functionColor = HIGHLIGHT_FUNCTION_DEF;
@@ -454,6 +483,7 @@ public void grabFromToolAndProgram(Plugin ownerPlugin, ToolOptions opt, Program
 		commentWARNInclude = opt.getBoolean(COMMENTWARN_OPTIONSTRING, COMMENTWARN_OPTIONDEFAULT);
 		commentHeadInclude = opt.getBoolean(COMMENTHEAD_OPTIONSTRING, COMMENTHEAD_OPTIONDEFAULT);
 		namespaceStrategy = opt.getEnum(NAMESPACE_OPTIONSTRING, NAMESPACE_OPTIONDEFAULT);
+		indentationStyle = opt.getEnum(INDENTATIONSTYLE_OPTIONSTRING, INDENTATIONSTYLE_OPTIONDEFAULT);
 		integerFormat = opt.getEnum(INTEGERFORMAT_OPTIONSTRING, INTEGERFORMAT_OPTIONDEFAULT);
 		keywordColor = opt.getColor(HIGHLIGHT_KEYWORD_MSG, HIGHLIGHT_KEYWORD_DEF);
 		typeColor = opt.getColor(HIGHLIGHT_TYPE_MSG, HIGHLIGHT_TYPE_DEF);
@@ -604,6 +634,9 @@ public void registerOptions(Plugin ownerPlugin, ToolOptions opt, Program program
 		opt.registerOption(NAMESPACE_OPTIONSTRING, NAMESPACE_OPTIONDEFAULT,
 			new HelpLocation(HelpTopics.DECOMPILER, "DisplayNamespaces"),
 			NAMESPACE_OPTIONDESCRIPTION);
+		opt.registerOption(INDENTATIONSTYLE_OPTIONSTRING, INDENTATIONSTYLE_OPTIONDEFAULT,
+			new HelpLocation(HelpTopics.DECOMPILER, "IndendationStyle"),
+			INDENTATIONSTYLE_OPTIONDESCRIPTION);
 		opt.registerOption(INTEGERFORMAT_OPTIONSTRING, INTEGERFORMAT_OPTIONDEFAULT,
 			new HelpLocation(HelpTopics.DECOMPILER, "DisplayIntegerFormat"),
 			INTEGERFORMAT_OPTIONDESCRIPTION);
@@ -784,7 +817,9 @@ public String getXML(DecompInterface iface) {
 		if (maxIntructionsPer != SUGGESTED_MAX_INSTRUCTIONS) {
 			appendOption(buf, "maxinstruction", Integer.toString(maxIntructionsPer), "", "");
 		}
+
 		appendOption(buf, "protoeval", protoEvalModel, "", "");
+		appendOption(buf, "indentationstyle", indentationStyle.getOptionString(), "", "");
 		buf.append("</optionslist>\n");
 		return buf.toString();
 	}
@@ -980,6 +1015,14 @@ public CommentStyleEnum getCommentStyle() {
 	public void setCommentStyle(CommentStyleEnum commentStyle) {
 		this.commentStyle = commentStyle;
 	}
+	
+	public IndentationStyleEnum getIndentationStyle() {
+		return indentationStyle;
+	}
+	
+	public void setIndentationStyle(IndentationStyleEnum indentationStyle) {
+		this.indentationStyle = indentationStyle;
+	}
 
 	public int getCacheSize() {
 		return cachedResultsSize;
