diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
index 7b1b2062ab8..c6170d78b54 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
@@ -362,10 +362,8 @@ int4 Action::perform(Funcdata &data)
 ActionGroup::~ActionGroup(void)
 
 {
-  vector<Action *>::iterator iter;
-  
-  for(iter=list.begin();iter!=list.end();++iter)
-    delete *iter;
+  for(auto *it : list)
+    delete it;
 }
 
 /// To be used only during the construction of \b this ActionGroup. This routine
@@ -726,10 +724,8 @@ bool Rule::checkActionBreak(void)
 ActionPool::~ActionPool(void)
 
 {
-  vector<Rule *>::iterator iter;
-
-  for(iter=allrules.begin();iter!=allrules.end();++iter)
-    delete *iter;
+  for(auto *it : allrules)
+    delete it;
 }
 
 /// This method should only be invoked during construction of this ActionPool
@@ -974,9 +970,8 @@ const char ActionDatabase::universalname[] = "universal";
 ActionDatabase::~ActionDatabase(void)
 
 {
-  map<string,Action *>::iterator iter;
-  for(iter = actionmap.begin();iter!=actionmap.end();++iter)
-    delete (*iter).second;
+  for(auto &it : actionmap)
+    delete it.second;
 }
 
 /// Clear out (possibly altered) root Actions. Reset the default groups.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
index 56dd7f979f1..b903114d37b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
@@ -134,46 +134,30 @@ Architecture::Architecture(void)
 Architecture::~Architecture(void)
 
 {				// Delete anything that was allocated
-  vector<TypeOp *>::iterator iter;
-  TypeOp *t_op;
-
-  for(iter=inst.begin();iter!=inst.end();++iter) {
-    t_op = *iter;
-    if (t_op != (TypeOp *)0)
-      delete t_op;
-  }
-  for(int4 i=0;i<extra_pool_rules.size();++i)
-    delete extra_pool_rules[i];
-
-  if (symboltab != (Database *)0)
-    delete symboltab;
-  for(int4 i=0;i<(int4)printlist.size();++i)
-    delete printlist[i];
+  for(TypeOp *op : inst)
+    delete op;
+  for(Rule *rule : extra_pool_rules)
+    delete rule;
+
+  delete symboltab;
+  for(PrintLanguage *lang : printlist)
+    delete lang;
   delete options;
 #ifdef CPUI_STATISTICS
   delete stats;
 #endif
 
-  map<string,ProtoModel *>::const_iterator piter;
-  for(piter=protoModels.begin();piter!=protoModels.end();++piter)
-    delete (*piter).second;
-
-  if (types != (TypeFactory *)0)
-    delete types;
-  if (translate != (Translate *)0)
-    delete translate;
-  if (loader != (LoadImage *)0)
-    delete loader;
-  if (pcodeinjectlib != (PcodeInjectLibrary *)0)
-    delete pcodeinjectlib;
-  if (commentdb != (CommentDatabase *)0)
-    delete commentdb;
-  if (stringManager != (StringManager *)0)
-    delete stringManager;
-  if (cpool != (ConstantPool *)0)
-    delete cpool;
-  if (context != (ContextDatabase *)0)
-    delete context;
+  for(auto &model : protoModels)
+    delete model.second;
+
+  delete types;
+  delete translate;
+  delete loader;
+  delete pcodeinjectlib;
+  delete commentdb;
+  delete stringManager;
+  delete cpool;
+  delete context;
 }
 
 /// The Architecture maintains the set of prototype models that can
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
index b40acf50e62..e6a18dad0b3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
@@ -1167,10 +1167,8 @@ void BlockGraph::markCopyBlock(FlowBlock *bl,uint4 fl)
 void BlockGraph::clear(void)
 
 {
-  vector<FlowBlock *>::iterator iter;
-
-  for(iter=list.begin();iter!=list.end();++iter)
-    delete *iter;
+  for(auto *it : list)
+    delete it;
   list.clear();
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
index 80265a458ff..6486093ebcf 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
@@ -569,8 +569,8 @@ TraceDAG::BranchPoint::BranchPoint(BlockTrace *parenttrace)
 TraceDAG::BranchPoint::~BranchPoint(void)
 
 {
-  for(int4 i=0;i<paths.size();++i)
-    delete paths[i];
+  for(auto *path : paths)
+    delete path;
 }
 
 /// \param t is the parent BranchPoint
@@ -951,8 +951,8 @@ TraceDAG::TraceDAG(list<FloatingEdge> &lg)
 TraceDAG::~TraceDAG(void)
 
 {
-  for(int4 i=0;i<branchlist.size();++i)
-    delete branchlist[i];
+  for(auto *branch : branchlist)
+    delete branch;
 }
 
 /// Given the registered root FlowBlocks, create the initial (virtual) BranchPoint
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
index 9dafc0e983c..f4beaf55697 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
@@ -135,19 +135,15 @@ CommentDatabaseInternal::CommentDatabaseInternal(void)
 CommentDatabaseInternal::~CommentDatabaseInternal(void)
 
 {
-  CommentSet::iterator iter;
-
-  for(iter=commentset.begin();iter!=commentset.end();++iter)
-    delete *iter;
+  for(auto *it : commentset)
+    delete it;
 }
 
 void CommentDatabaseInternal::clear(void)
 
 {
-  CommentSet::iterator iter;
-
-  for(iter=commentset.begin();iter!=commentset.end();++iter)
-    delete *iter;
+  for(auto *it : commentset)
+    delete it;
   commentset.clear();
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
index 3372e5ac55a..39e1b129870 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
@@ -91,7 +91,7 @@ private:
   int4 delayslot;		// delayslot depth
 public:
   ParserContext(ContextCache *ccache);
-  ~ParserContext(void) { if (context != (uintm *)0) delete [] context; }
+  ~ParserContext(void) { delete [] context; }
   uint1 *getBuffer(void) { return buf; }
   void initialize(int4 maxstate,int4 maxparam,AddrSpace *spc);
   int4 getParserState(void) const { return parsestate; }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
index 7a90f6e9f86..816463d7d38 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
@@ -69,7 +69,7 @@ private:
   int4 byteDataLen;	///< The number of bytes in the data for a string literal
 public:
   CPoolRecord(void) { type = (Datatype *)0; byteData = (uint1 *)0; }		///< Construct an empty record
-  ~CPoolRecord(void) { if (byteData != (uint1 *)0) delete [] byteData; }	///< Destructor
+  ~CPoolRecord(void) { delete [] byteData; }	///< Destructor
   uint4 getTag(void) const { return tag; }					///< Get the type of record
   const string &getToken(void) const { return token; }				///< Get name of method or data-type
   const uint1 *getByteData(void) const { return byteData; }			///< Get pointer to string literal data
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
index 2363a94b02b..4757e4bfa1d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
@@ -584,9 +584,10 @@ FunctionSymbol::FunctionSymbol(Scope *sc,int4 size)
   buildType();
 }
 
-FunctionSymbol::~FunctionSymbol(void) {
-  if (fd != (Funcdata *)0)
-    delete fd;
+FunctionSymbol::~FunctionSymbol(void)
+
+{
+  delete fd;
 }
 
 Funcdata *FunctionSymbol::getFunction(void)
@@ -1157,11 +1158,8 @@ SymbolEntry *Scope::addMap(SymbolEntry &entry)
 Scope::~Scope(void)
 
 {
-  ScopeMap::iterator iter = children.begin();
-  while(iter != children.end()) {
-    delete (*iter).second;
-    ++iter;
-  }
+  for (auto &it : children)
+    delete it.second;
 }
 
 /// Starting from \b this Scope, look for a Symbol with the given name.
@@ -1909,16 +1907,10 @@ ScopeInternal::ScopeInternal(uint8 id,const string &nm,Architecture *g, Scope *o
 ScopeInternal::~ScopeInternal(void)
 
 {
-  vector<EntryMap *>::iterator iter1;
-
-  for(iter1=maptable.begin();iter1!=maptable.end();++iter1)
-    if ((*iter1) != (EntryMap *)0)
-      delete *iter1;
-
-  SymbolNameTree::iterator iter2;
-
-  for(iter2=nametree.begin();iter2!=nametree.end();++iter2)
-    delete *iter2;
+  for(auto *it : maptable)
+    delete it;
+  for(auto *it : nametree)
+    delete it;
 }
 
 void ScopeInternal::clear(void)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
index 597ece06d20..81e7b77c634 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
@@ -339,10 +339,10 @@ EmulatePcodeCache::EmulatePcodeCache(Translate *t,MemoryState *s,BreakTable *b)
 void EmulatePcodeCache::clearCache(void)
 
 {
-  for(int4 i=0;i<opcache.size();++i)
-    delete opcache[i];
-  for(int4 i=0;i<varcache.size();++i)
-    delete varcache[i];
+  for(auto *op : opcache)
+    delete op;
+  for(auto *var : varcache)
+    delete var;
   opcache.clear();
   varcache.clear();
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
index 97bb8408764..e25bced693a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
@@ -293,10 +293,10 @@ void EmulateSnippet::fallthruOp(void)
 EmulateSnippet::~EmulateSnippet(void)
 
 {
-  for(int4 i=0;i<opList.size();++i)
-    delete opList[i];
-  for(int4 i=0;i<varList.size();++i)
-    delete varList[i];
+  for(auto *op : opList)
+    delete op;
+  for(auto *var : varList)
+    delete var;
 }
 
 /// \brief Provide the caller with an emitter for building the p-code snippet
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
index e87033c34db..a7951ffb4d6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
@@ -434,11 +434,8 @@ ParamListStandard::ParamListStandard(const ParamListStandard &op2)
 ParamListStandard::~ParamListStandard(void)
 
 {
-  for(int4 i=0;i<resolverMap.size();++i) {
-    ParamEntryResolver *resolver = resolverMap[i];
-    if (resolver != (ParamEntryResolver *)0)
-      delete resolver;
-  }
+  for(auto *resolver : resolverMap)
+    delete resolver;
 }
 
 /// Find the (first) entry containing the given memory range
@@ -1806,10 +1803,8 @@ ProtoModel::ProtoModel(const string &nm,const ProtoModel &op2)
 ProtoModel::~ProtoModel(void)
 
 {
-  if (input != (ParamList *)0)
-    delete input;
-  if (output != (ParamList *)0)
-    delete output;
+  delete input;
+  delete output;
 }
 
 /// Test whether one ProtoModel can substituted for another during FuncCallSpecs::deindirect
@@ -2473,13 +2468,9 @@ ProtoStoreSymbol::ProtoStoreSymbol(Scope *sc,const Address &usepoint)
 ProtoStoreSymbol::~ProtoStoreSymbol(void)
 
 {
-  for(int4 i=0;i<inparam.size();++i) {
-    ProtoParameter *param = inparam[i];
-    if (param != (ProtoParameter *)0)
-      delete param;
-  }
-  if (outparam != (ProtoParameter *)0)
-    delete outparam;
+  for(auto *param : inparam)
+    delete param;
+  delete outparam;
 }
 
 /// Retrieve the specified ProtoParameter object, making sure it is a ParameterSymbol.
@@ -2495,8 +2486,7 @@ ParameterSymbol *ProtoStoreSymbol::getSymbolBacked(int4 i)
   ParameterSymbol *res = dynamic_cast<ParameterSymbol *>(inparam[i]);
   if (res != (ParameterSymbol *)0)
     return res;
-  if (inparam[i] != (ProtoParameter *)0)
-    delete inparam[i];
+  delete inparam[i];
   res = new ParameterSymbol();
   inparam[i] = res;
   return res;
@@ -2596,8 +2586,7 @@ ProtoParameter *ProtoStoreSymbol::getInput(int4 i)
 ProtoParameter *ProtoStoreSymbol::setOutput(const ParameterPieces &piece)
 
 {
-  if (outparam != (ProtoParameter *)0)
-    delete outparam;
+  delete outparam;
   outparam = new ParameterBasic("",piece.addr,piece.type,piece.flags);
   return outparam;
 }
@@ -2657,13 +2646,9 @@ ProtoStoreInternal::ProtoStoreInternal(Datatype *vt)
 ProtoStoreInternal::~ProtoStoreInternal(void)
 
 {
-  if (outparam != (ProtoParameter *)0)
-    delete outparam;
-  for(int4 i=0;i<inparam.size();++i) {
-    ProtoParameter *param = inparam[i];
-    if (param != (ProtoParameter *)0)
-      delete param;
-  }
+  delete outparam;
+  for(auto *param : inparam)
+    delete param;
 }
 
 ProtoParameter *ProtoStoreInternal::setInput(int4 i,const string &nm,const ParameterPieces &pieces)
@@ -2671,8 +2656,7 @@ ProtoParameter *ProtoStoreInternal::setInput(int4 i,const string &nm,const Param
 {
   while(inparam.size() <= i)
     inparam.push_back((ProtoParameter *)0);
-  if (inparam[i] != (ProtoParameter *)0)
-    delete inparam[i];
+  delete inparam[i];
   inparam[i] = new ParameterBasic(nm,pieces.addr,pieces.type,pieces.flags);
   return inparam[i];
 }
@@ -2682,8 +2666,7 @@ void ProtoStoreInternal::clearInput(int4 i)
 {
   int4 sz = inparam.size();
   if (i>=sz) return;
-  if (inparam[i] != (ProtoParameter *)0)
-    delete inparam[i];
+  delete inparam[i];
   inparam[i] = (ProtoParameter *)0;
   for(int4 j=i+1;j<sz;++j) {	// Renumber parameters with index > i
     inparam[j-1] = inparam[j];
@@ -2696,10 +2679,8 @@ void ProtoStoreInternal::clearInput(int4 i)
 void ProtoStoreInternal::clearAllInputs(void)
 
 {
-  for(int4 i=0;i<inparam.size();++i) {
-    if (inparam[i] != (ProtoParameter *)0)
-      delete inparam[i];
-  }
+  for(auto *param : inparam)
+    delete param;
   inparam.clear();
 }
 
@@ -2720,8 +2701,7 @@ ProtoParameter *ProtoStoreInternal::getInput(int4 i)
 ProtoParameter *ProtoStoreInternal::setOutput(const ParameterPieces &piece)
 
 {
-  if (outparam != (ProtoParameter *)0)
-    delete outparam;
+  delete outparam;
   outparam = new ParameterBasic("",piece.addr,piece.type,piece.flags);
   return outparam;
 }
@@ -2729,8 +2709,7 @@ ProtoParameter *ProtoStoreInternal::setOutput(const ParameterPieces &piece)
 void ProtoStoreInternal::clearOutput(void)
 
 {
-  if (outparam != (ProtoParameter *)0)
-    delete outparam;
+  delete outparam;
   outparam = new ParameterBasic(voidtype);
 }
 
@@ -3012,8 +2991,7 @@ void FuncProto::copy(const FuncProto &op2)
   model = op2.model;
   extrapop = op2.extrapop;
   flags = op2.flags;
-  if (store != (ProtoStore *)0)
-    delete store;
+  delete store;
   if (op2.store != (ProtoStore *)0)
     store = op2.store->clone();
   else
@@ -3126,8 +3104,7 @@ void FuncProto::setInternal(ProtoModel *m,Datatype *vt)
 FuncProto::~FuncProto(void)
 
 {
-  if (store != (ProtoStore *)0)
-    delete store;
+  delete store;
 }
 
 bool FuncProto::isInputLocked(void) const
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
index 39d22630cd3..c0f6d66155d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
@@ -386,7 +386,7 @@ public:
   void initActiveOutput(void);					///< Initialize \e return prototype recovery analysis
   /// \brief Clear any analysis of the function's \e return prototype
   void clearActiveOutput(void) {
-    if (activeoutput != (ParamActive *)0) delete activeoutput;
+    delete activeoutput;
     activeoutput = (ParamActive *)0;
   }
   ParamActive *getActiveOutput(void) const { return activeoutput; }	///< Get the \e return prototype recovery object
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
index 46efe6eb0f6..d19cc5f276e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
@@ -221,10 +221,8 @@ void DeregisterProgram::rawAction(void)
 
 {
 #ifdef __REMOTE_SOCKET__
-    if (ghidra_dcp != (IfaceStatus *)0)
-      delete ghidra_dcp;
-    if (remote != (RemoteSocket *)0)
-      delete remote;
+    delete ghidra_dcp;
+    delete remote;
     ghidra_dcp = (IfaceStatus *)0;
     remote = (RemoteSocket *)0;
 #endif
@@ -422,18 +420,14 @@ SetOptions::SetOptions(void) : GhidraCommand()
 SetOptions::~SetOptions(void)
 
 {
-  if (doc != (Document *)0)
-    delete doc;
+  delete doc;
 }
 
 void SetOptions::loadParameters(void)
 
 {
   GhidraCommand::loadParameters();
-  if (doc != (Document *)0) {
-    delete doc;
-    doc = (Document *)0;
-  }
+  delete doc;
   doc = ArchitectureGhidra::readXMLStream(sin);
 }
 
@@ -493,9 +487,8 @@ int4 GhidraCapability::readCommand(istream &sin,ostream &out)
 void GhidraCapability::shutDown(void)
 
 {
-  map<string,GhidraCommand *>::iterator iter;
-  for(iter=commandmap.begin();iter!=commandmap.end();++iter)
-    delete (*iter).second;
+  for(auto &it : commandmap)
+    delete it.second;
 }
 
 void GhidraDecompCapability::initialize(void)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
index d6fc5792a13..886e73a96e4 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
@@ -2910,45 +2910,36 @@ Datatype *CParse::oldEnum(const string &ident)
 void CParse::clearAllocation(void)
 
 {
-  list<TypeDeclarator *>::iterator iter1;
-
-  for(iter1=typedec_alloc.begin();iter1!=typedec_alloc.end();++iter1)
-    delete *iter1;
+  for(auto *it : typedec_alloc)
+    delete it;
   typedec_alloc.clear();
 
-  list<TypeSpecifiers *>::iterator iter2;
-  for(iter2=typespec_alloc.begin();iter2!=typespec_alloc.end();++iter2)
-    delete *iter2;
+  for(auto *it : typespec_alloc)
+    delete it;
   typespec_alloc.clear();
 
-  list<vector<uint4> *>::iterator iter3;
-  for(iter3=vecuint4_alloc.begin();iter3!=vecuint4_alloc.end();++iter3)
-    delete *iter3;
+  for(auto *it : vecuint4_alloc)
+    delete it;
   vecuint4_alloc.clear();
 
-  list<vector<TypeDeclarator *> *>::iterator iter4;
-  for(iter4=vecdec_alloc.begin();iter4!=vecdec_alloc.end();++iter4)
-    delete *iter4;
+  for(auto *it : vecdec_alloc)
+    delete it;
   vecdec_alloc.clear();
 
-  list<string *>::iterator iter5;
-  for(iter5=string_alloc.begin();iter5!=string_alloc.end();++iter5)
-    delete *iter5;
+  for(auto *it : string_alloc)
+    delete it;
   string_alloc.clear();
 
-  list<uintb *>::iterator iter6;
-  for(iter6=num_alloc.begin();iter6!=num_alloc.end();++iter6)
-    delete *iter6;
+  for(auto *it : num_alloc)
+    delete it;
   num_alloc.clear();
 
-  list<Enumerator *>::iterator iter7;
-  for(iter7=enum_alloc.begin();iter7!=enum_alloc.end();++iter7)
-    delete *iter7;
+  for(auto *it : enum_alloc)
+    delete it;
   enum_alloc.clear();
 
-  list<vector<Enumerator *> *>::iterator iter8;
-  for(iter8=vecenum_alloc.begin();iter8!=vecenum_alloc.end();++iter8)
-    delete *iter8;
+  for(auto *it : vecenum_alloc)
+    delete it;
   vecenum_alloc.clear();
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.y b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.y
index 33141afdab8..d6b0c465ec6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.y
@@ -1125,45 +1125,36 @@ Datatype *CParse::oldEnum(const string &ident)
 void CParse::clearAllocation(void)
 
 {
-  list<TypeDeclarator *>::iterator iter1;
-
-  for(iter1=typedec_alloc.begin();iter1!=typedec_alloc.end();++iter1)
-    delete *iter1;
+  for(auto *it : typedec_alloc)
+    delete it;
   typedec_alloc.clear();
 
-  list<TypeSpecifiers *>::iterator iter2;
-  for(iter2=typespec_alloc.begin();iter2!=typespec_alloc.end();++iter2)
-    delete *iter2;
+  for(auto *it : typespec_alloc)
+    delete it;
   typespec_alloc.clear();
 
-  list<vector<uint4> *>::iterator iter3;
-  for(iter3=vecuint4_alloc.begin();iter3!=vecuint4_alloc.end();++iter3)
-    delete *iter3;
+  for(auto *it : vecuint4_alloc)
+    delete it;
   vecuint4_alloc.clear();
 
-  list<vector<TypeDeclarator *> *>::iterator iter4;
-  for(iter4=vecdec_alloc.begin();iter4!=vecdec_alloc.end();++iter4)
-    delete *iter4;
+  for(auto *it : vecdec_alloc)
+    delete it;
   vecdec_alloc.clear();
 
-  list<string *>::iterator iter5;
-  for(iter5=string_alloc.begin();iter5!=string_alloc.end();++iter5)
-    delete *iter5;
+  for(auto *it : string_alloc)
+    delete it;
   string_alloc.clear();
 
-  list<uintb *>::iterator iter6;
-  for(iter6=num_alloc.begin();iter6!=num_alloc.end();++iter6)
-    delete *iter6;
+  for(auto *it : num_alloc)
+    delete it;
   num_alloc.clear();
 
-  list<Enumerator *>::iterator iter7;
-  for(iter7=enum_alloc.begin();iter7!=enum_alloc.end();++iter7)
-    delete *iter7;
+  for(auto *it : enum_alloc)
+    delete it;
   enum_alloc.clear();
 
-  list<vector<Enumerator *> *>::iterator iter8;
-  for(iter8=vecenum_alloc.begin();iter8!=vecenum_alloc.end();++iter8)
-    delete *iter8;
+  for(auto *it : vecenum_alloc)
+    delete it;
   vecenum_alloc.clear();
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
index 215b15a4bff..fcc63a0db85 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
@@ -226,18 +226,15 @@ IfaceDecompData::IfaceDecompData(void)
 IfaceDecompData::~IfaceDecompData(void)
 
 {
-  if (cgraph != (CallGraph *)0)
-    delete cgraph;
-  if (conf != (Architecture *)0)
-    delete conf;
+  delete cgraph;
+  delete conf;
 // fd will get deleted with Database
 }
 
 void IfaceDecompData::allocateCallGraph(void)
 
 {
-  if (cgraph != (CallGraph *)0)
-    delete cgraph;
+  delete cgraph;
   cgraph = new CallGraph(conf);
 }
 
@@ -257,8 +254,7 @@ void IfaceDecompData::abortFunction(ostream &s)
 void IfaceDecompData::clearArchitecture(void)
 
 {
-  if (conf != (Architecture *)0)
-    delete conf;
+  delete conf;
   conf = (Architecture *)0;
   fd = (Funcdata *)0;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
index b72d089d2ae..c52e7e7c7d5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
@@ -20,15 +20,13 @@
 InjectContextSleigh::~InjectContextSleigh(void)
 
 {
-  if (pos != (ParserContext *)0)
-    delete pos;
+  delete pos;
 }
 
 InjectPayloadSleigh::~InjectPayloadSleigh(void)
 
 {
-  if (tpl != (ConstructTpl *)0)
-    delete tpl;
+  delete tpl;
 }
 
 InjectPayloadSleigh::InjectPayloadSleigh(const string &src,const string &nm,int4 tp)
@@ -185,8 +183,7 @@ ExecutablePcodeSleigh::ExecutablePcodeSleigh(Architecture *g,const string &src,c
 ExecutablePcodeSleigh::~ExecutablePcodeSleigh(void)
 
 {
-  if (tpl != (ConstructTpl *)0)
-    delete tpl;
+  delete tpl;
 }
 
 void ExecutablePcodeSleigh::inject(InjectContext &context,PcodeEmit &emit) const
@@ -238,9 +235,8 @@ void ExecutablePcodeSleigh::printTemplate(ostream &s) const
 InjectPayloadDynamic::~InjectPayloadDynamic(void)
 
 {
-  map<Address,Document *>::iterator iter;
-  for(iter=addrMap.begin();iter!=addrMap.end();++iter)
-    delete (*iter).second;
+  for(auto &it : addrMap)
+    delete it.second;
 }
 
 void InjectPayloadDynamic::restoreEntry(const Element *el)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
index 9c5674b8f09..cb521feca93 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
@@ -55,23 +55,14 @@ RemoteSocket::RemoteSocket(void)
 void RemoteSocket::close(void)
 
 {
-  if (inStream != (istream *)0) {
-    delete inStream;
-    inStream = (istream *)0;
-  }
-  if (outStream != (ostream *)0) {
-    delete outStream;
-    outStream = (ostream *)0;
-  }
-  if (inbuf != (basic_filebuf<char> *)0) {
-    // Destroying the buffer should automatically close the socket
-    delete inbuf;
-    inbuf = (basic_filebuf<char> *)0;
-  }
-  if (outbuf != (basic_filebuf<char> *)0) {
-    delete outbuf;
-    outbuf = (basic_filebuf<char> *)0;
-  }
+  delete inStream;
+  inStream = (istream *)0;
+  delete outStream;
+  outStream = (ostream *)0;
+  delete inbuf;
+  inbuf = (basic_filebuf<char> *)0;
+  delete outbuf;
+  outbuf = (basic_filebuf<char> *)0;
   isOpen = false;
 }
 
@@ -239,18 +230,14 @@ void IfaceStatus::wordsToString(string &res,const vector<string> &list)
 IfaceStatus::~IfaceStatus(void)
 
 {
-  if (optr != fileoptr) {
-    ((ofstream *)fileoptr)->close();
+  if (optr != fileoptr)
     delete fileoptr;
-  }
   while(!promptstack.empty())
     popScript();
   for(int4 i=0;i<comlist.size();++i)
     delete comlist[i];
-  map<string,IfaceData *>::const_iterator iter;
-  for(iter=datamap.begin();iter!=datamap.end();++iter)
-    if ((*iter).second != (IfaceData *)0)
-      delete (*iter).second;
+  for(auto &it : datamap)
+    delete it.second;
 }
 
 /// \brief Register a command with this interface
@@ -581,7 +568,6 @@ void IfcClosefile::execute(istream &s)
 {
   if (status->optr == status->fileoptr)
     throw IfaceExecutionError("No file open");
-  ((ofstream *)status->fileoptr)->close();
   delete status->fileoptr;
   status->fileoptr = status->optr;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
index 656d197573d..b6589d502e1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
@@ -1283,8 +1283,7 @@ bool JumpBasic::foldInOneGuard(Funcdata *fd,GuardRecord &guard,JumpTable *jump)
 JumpBasic::~JumpBasic(void)
 
 {
-  if (jrange != (JumpValuesRange *)0)
-    delete jrange;
+  delete jrange;
 }
 
 bool JumpBasic::recoverModel(Funcdata *fd,PcodeOp *indop,uint4 matchsize,uint4 maxtablesize)
@@ -1491,10 +1490,8 @@ JumpModel *JumpBasic::clone(JumpTable *jt) const
 void JumpBasic::clear(void)
 
 {
-  if (jrange != (JumpValuesRange *)0) {
-    delete jrange;
-    jrange = (JumpValuesRange *)0;
-  }
+  delete jrange;
+  jrange = (JumpValuesRange *)0;
   pathMeld.clear();
   selectguards.clear();
   normalvn = (Varnode *)0;
@@ -2255,10 +2252,8 @@ JumpTable::JumpTable(const JumpTable *op2)
 JumpTable::~JumpTable(void)
 
 {
-  if (jmodel != (JumpModel *)0)
-    delete jmodel;
-  if (origmodel != (JumpModel *)0)
-    delete origmodel;
+  delete jmodel;
+  delete origmodel;
 }
 
 /// \brief Return the number of address table entries that target the given basic-block
@@ -2296,8 +2291,7 @@ bool JumpTable::isOverride(void) const
 void JumpTable::setOverride(const vector<Address> &addrtable,const Address &naddr,uintb h,uintb sv)
 
 {
-  if (jmodel != (JumpModel *)0)
-    delete jmodel;
+  delete jmodel;
 
   JumpBasicOverride *override;
   jmodel = override = new JumpBasicOverride(this);
@@ -2478,8 +2472,7 @@ void JumpTable::recoverAddresses(Funcdata *fd)
 void JumpTable::recoverMultistage(Funcdata *fd)
 
 {
-  if (origmodel != (JumpModel *)0)
-    delete origmodel;
+  delete origmodel;
   origmodel = jmodel;
   jmodel = (JumpModel *)0;
   
@@ -2490,26 +2483,21 @@ void JumpTable::recoverMultistage(Funcdata *fd)
     recoverAddresses(fd);
   }
   catch(JumptableThunkError &err) {
-    if (jmodel != (JumpModel *)0)
-      delete jmodel;
+    delete jmodel;
     jmodel = origmodel;
     origmodel = (JumpModel *)0;
     addresstable = oldaddresstable;
     fd->warning("Second-stage recovery error",indirect->getAddr());
   }
   catch(LowlevelError &err) {
-    if (jmodel != (JumpModel *)0)
-      delete jmodel;
+    delete jmodel;
     jmodel = origmodel;
     origmodel = (JumpModel *)0;
     addresstable = oldaddresstable;
     fd->warning("Second-stage recovery error",indirect->getAddr());
   }
   recoverystage = 2;
-  if (origmodel != (JumpModel *)0) { // Keep the new model if it was created successfully
-    delete origmodel;
-    origmodel = (JumpModel *)0;
-  }
+  delete origmodel;
 }
 
 /// This is run assuming the address table has already been recovered, via recoverAddresses() in another
@@ -2527,8 +2515,7 @@ bool JumpTable::recoverLabels(Funcdata *fd)
 
   // Unless the model is an override, move model (created on a flow copy) so we can create a current instance
   if (jmodel != (JumpModel *)0) {
-    if (origmodel != (JumpModel *)0)
-      delete origmodel;
+    delete origmodel;
     if (!jmodel->isOverride()) {
       origmodel = jmodel;
       jmodel = (JumpModel *)0;
@@ -2561,10 +2548,8 @@ bool JumpTable::recoverLabels(Funcdata *fd)
     trivialSwitchOver();
     jmodel->buildLabels(fd,addresstable,label,origmodel);
   }
-  if (origmodel != (JumpModel *)0) {
-    delete origmodel;
-    origmodel = (JumpModel *)0;
-  }
+  delete origmodel;
+  origmodel = (JumpModel *)0;
   return multistagerestart;
 }
 
@@ -2574,10 +2559,8 @@ bool JumpTable::recoverLabels(Funcdata *fd)
 void JumpTable::clear(void)
 
 {
-  if (origmodel != (JumpModel *)0) {
-    delete origmodel;
-    origmodel = (JumpModel *)0;
-  }
+  delete origmodel;
+  origmodel = (JumpModel *)0;
   if (jmodel->isOverride())
     jmodel->clear();
   else {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
index e14109b328c..6f63628c58d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
@@ -46,10 +46,7 @@ RawLoadImage::RawLoadImage(const string &f) : LoadImage(f)
 RawLoadImage::~RawLoadImage(void)
 
 {
-  if (thefile != (ifstream *)0) {
-    thefile->close();
-    delete thefile;
-  }
+  delete thefile;
 }
 
 /// The file is opened and its size immediately recovered.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
index 7e9f1ad8a56..ae03bbd9ef7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
@@ -39,8 +39,7 @@ LoadImageBfd::LoadImageBfd(const string &f,const string &t) : LoadImage(f)
 LoadImageBfd::~LoadImageBfd(void)
 
 {
-  if (symbol_table != (asymbol **)0)
-    delete [] symbol_table;
+  delete [] symbol_table;
   if (thebfd != (bfd *) 0)
     close();
   delete [] buffer;
@@ -274,8 +273,7 @@ bool LoadImageBfd::getNextSection(LoadImageSection &record) const
 void LoadImageBfd::closeSymbols(void) const
 
 {
-  if (symbol_table != (asymbol **)0)
-    delete [] symbol_table;
+  delete [] symbol_table;
   symbol_table = (asymbol **)0;
   number_of_symbols = 0;
   cursymbol = 0;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
index be9a570a09d..a915d1a7978 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
@@ -537,10 +537,8 @@ MemoryPageOverlay::MemoryPageOverlay(AddrSpace *spc,int4 ws,int4 ps,MemoryBank *
 MemoryPageOverlay::~MemoryPageOverlay(void)
 
 {
-  map<uintb,uint1 *>::iterator iter;
-
-  for(iter=page.begin();iter!=page.end();++iter)
-    delete [] (*iter).second;
+  for(auto &it : page)
+    delete [] it.second;
 }
 
 /// Write the value into the hashtable, using \b addr as a key.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
index af89c583acb..ce0a3881c25 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
@@ -1052,14 +1052,12 @@ list<PcodeOp *>::const_iterator PcodeOpBank::end(OpCode opc) const
 void PcodeOpBank::clear(void)
 
 {
-  list<PcodeOp *>::iterator iter;
-
-  for(iter=alivelist.begin();iter!=alivelist.end();++iter)
-    delete *iter;
-  for(iter=deadlist.begin();iter!=deadlist.end();++iter)
-    delete *iter;
-  for(iter=deadandgone.begin();iter!=deadandgone.end();++iter)
-    delete *iter;
+  for(auto *it : alivelist)
+    delete it;
+  for(auto *it : deadlist)
+    delete it;
+  for(auto *it : deadandgone)
+    delete it;
   optree.clear();
   alivelist.clear();
   deadlist.clear();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
index 12dd1874e83..85f302114ca 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
@@ -88,9 +88,8 @@ OptionDatabase::OptionDatabase(Architecture *g)
 OptionDatabase::~OptionDatabase(void)
 
 {
-  map<string,ArchOption *>::iterator iter;
-  for(iter=optionmap.begin();iter!=optionmap.end();++iter)
-    delete (*iter).second;
+  for(auto &it : optionmap)
+    delete it.second;
 }
 
 /// Perform an \e option \e command directly, given its name and optional parameters
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
index a998ba28176..5b42301011d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
@@ -19,10 +19,8 @@
 void Override::clear(void)
 
 {
-  map<Address,FuncProto *>::iterator iter;
-
-  for(iter=protoover.begin();iter!=protoover.end();++iter)
-    delete (*iter).second;
+  for(auto &it : protoover)
+    delete it.second;
 
   forcegoto.clear();
   deadcodedelay.clear();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
index 7927bececa4..72e559ff9af 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
@@ -44,8 +44,7 @@ ExprTree::ExprTree(OpTpl *op)
 ExprTree::~ExprTree(void)
 
 {
-  if (outvn != (VarnodeTpl *)0)
-    delete outvn;
+  delete outvn;
   if (ops != (vector<OpTpl *> *)0) {
     for(int4 i=0;i<ops->size();++i)
       delete (*ops)[i];
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
index f8e8d1f9282..d75b7ae87c1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
@@ -175,9 +175,8 @@ uintb ExecutablePcode::evaluate(const vector<uintb> &input)
 PcodeInjectLibrary::~PcodeInjectLibrary(void)
 
 {
-  vector<InjectPayload *>::iterator iter;
-  for(iter=injection.begin();iter!=injection.end();++iter)
-    delete *iter;
+  for(auto *it : injection)
+    delete it;
 }
 
 /// \brief Map a \e call-fixup name to a payload id
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
index 4dea9f568a9..15d2764f3c0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
@@ -142,7 +142,7 @@ class ExecutablePcode : public InjectPayload {
   void build(void);			///< Initialize the Emulate object with the snippet p-code
 public:
   ExecutablePcode(Architecture *g,const string &src,const string &nm);	///< Constructor
-  virtual ~ExecutablePcode(void) { if (emitter != (PcodeEmit *)0) delete emitter; }
+  virtual ~ExecutablePcode(void) { delete emitter; }
   virtual string getSource(void) const { return source; }
   uintb evaluate(const vector<uintb> &input);		///< Evaluate the snippet on the given inputs
 };
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
index a15a81a2ac1..978c74a58e8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
@@ -3270,10 +3270,8 @@ void PcodeSnippet::clear(void)
       tree.erase(tmpiter);
     }
   }
-  if (result != (ConstructTpl *)0) {
-    delete result;
-    result = (ConstructTpl *)0;
-  }
+  delete result;
+  result = (ConstructTpl *)0;
   // tempbase = 0;
   errorcount = 0;
   firsterror.clear();
@@ -3305,12 +3303,9 @@ PcodeSnippet::~PcodeSnippet(void)
 
 {
   SymbolTree::iterator iter;
-  for(iter=tree.begin();iter!=tree.end();++iter)
-    delete *iter;		// Free ALL temporary symbols
-  if (result != (ConstructTpl *)0) {
-    delete result;
-    result = (ConstructTpl *)0;
-  }
+  for(auto *it : tree)
+    delete it;		// Free ALL temporary symbols
+  delete result;
 }
 
 void PcodeSnippet::reportError(const Location *loc, const string &msg)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
index a86239a0d70..a2d6062d0d2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
@@ -93,7 +93,7 @@
 %destructor { delete $$; } rtlmid
 %destructor { if ($$ != (vector<OpTpl *> *)0) { for(int4 i=0;i<$$->size();++i) delete (*$$)[i]; delete $$;} } statement
 %destructor { delete $$; } expr
-%destructor { if ($$ != (VarnodeTpl *)0) delete $$; } varnode integervarnode lhsvarnode jumpdest
+%destructor { delete $$; } varnode integervarnode lhsvarnode jumpdest
 %destructor { delete $$; } sizedstar
 
 %%
@@ -669,10 +669,8 @@ void PcodeSnippet::clear(void)
       tree.erase(tmpiter);
     }
   }
-  if (result != (ConstructTpl *)0) {
-    delete result;
-    result = (ConstructTpl *)0;
-  }
+  delete result;
+  result = (ConstructTpl *)0;
   // tempbase = 0;
   errorcount = 0;
   firsterror.clear();
@@ -703,13 +701,9 @@ PcodeSnippet::PcodeSnippet(const SleighBase *slgh)
 PcodeSnippet::~PcodeSnippet(void)
 
 {
-  SymbolTree::iterator iter;
-  for(iter=tree.begin();iter!=tree.end();++iter)
-    delete *iter;		// Free ALL temporary symbols
-  if (result != (ConstructTpl *)0) {
-    delete result;
-    result = (ConstructTpl *)0;
-  }
+  for(auto *it : tree)
+    delete it;		// Free ALL temporary symbols
+  delete result;
 }
 
 void PcodeSnippet::reportError(const Location *loc, const string &msg)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
index 1d140a38651..0d7eccc8cc5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
@@ -39,8 +39,7 @@ PrintJava::PrintJava(Architecture *glb,const string &nm) : PrintC(glb,nm)
 {
   resetDefaultsPrintJava();
   nullToken = "null";			// Java standard lower-case 'null'
-  if (castStrategy != (CastStrategy *)0)
-    delete castStrategy;
+  delete castStrategy;
 
   castStrategy = new CastStrategyJava();
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
index 30eb7814122..8478663a26a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
@@ -71,8 +71,7 @@ PrintLanguage::~PrintLanguage(void)
 
 {
   delete emit;
-  if (castStrategy != (CastStrategy *)0)
-    delete castStrategy;
+  delete castStrategy;
 }
 
 /// \param val is the number of characters
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
index af4e191c798..1532e7e60a4 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
@@ -402,13 +402,9 @@ RuleCompile::RuleCompile(void)
 RuleCompile::~RuleCompile(void)
 
 {
-  if (finalrule != (ConstraintGroup *)0)
-    delete finalrule;
-  for(int4 i=0;i<inst.size();++i) {
-    OpBehavior *t_op = inst[i];
-    if (t_op != (OpBehavior *)0)
-      delete t_op;
-  }
+  delete finalrule;
+  for(auto *op : inst) {
+    delete op;
 }
 
 void RuleCompile::ruleError(const char *s)
@@ -771,10 +767,8 @@ void RuleCompile::run(istream &s,bool debug)
     return;
   }
   errors = 0;
-  if (finalrule != (ConstraintGroup *)0) {
-    delete finalrule;
-    finalrule = (ConstraintGroup *)0;
-  }
+  delete finalrule;
+  finalrule = (ConstraintGroup *)0;
   lexer.initialize(s);
 
   rulecompile = this;		// Setup the global pointer
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
index f8c1580a8e6..ca07c5e4082 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
@@ -661,11 +661,9 @@ void HandleTpl::restoreXml(const Element *el,const AddrSpaceManager *manage)
 OpTpl::~OpTpl(void)
 
 {				// An OpTpl owns its varnode_tpls
-  if (output != (VarnodeTpl *)0)
-    delete output;
-  vector<VarnodeTpl *>::iterator iter;
-  for(iter=input.begin();iter!=input.end();++iter)
-    delete *iter;
+  delete output;
+  for(auto *it : input)
+    delete it;
 }
 
 bool OpTpl::isZeroSize(void) const
@@ -738,11 +736,9 @@ void OpTpl::restoreXml(const Element *el,const AddrSpaceManager *manage)
 ConstructTpl::~ConstructTpl(void)
 
 {				// Constructor owns its ops and handles
-  vector<OpTpl *>::iterator oiter;
-  for(oiter=vec.begin();oiter!=vec.end();++oiter)
-    delete *oiter;
-  if (result != (HandleTpl *)0)
-    delete result;
+  for(auto *it : vec)
+    delete it;
+  delete result;
 }
 
 bool ConstructTpl::addOp(OpTpl *ot)
@@ -838,8 +834,7 @@ void ConstructTpl::setInput(VarnodeTpl *vn,int4 index,int4 slot)
   OpTpl *op = vec[index];
   VarnodeTpl *oldvn = op->getIn(slot);
   op->setInput(vn,slot);
-  if (oldvn != (VarnodeTpl *)0)
-    delete oldvn;
+  delete oldvn;
 }
 
 void ConstructTpl::setOutput(VarnodeTpl *vn,int4 index)
@@ -849,8 +844,7 @@ void ConstructTpl::setOutput(VarnodeTpl *vn,int4 index)
   OpTpl *op = vec[index];
   VarnodeTpl *oldvn = op->getOut();
   op->setOutput(vn);
-  if (oldvn != (VarnodeTpl *)0)
-    delete oldvn;
+  delete oldvn;
 }
 
 void ConstructTpl::deleteOps(const vector<int4> &indices)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
index bf65a9d5f08..c275e8de2d5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
@@ -487,8 +487,7 @@ void Sleigh::clearForDelete(void)
 
 {
   delete cache;
-  if (discache != (DisassemblyCache *)0)
-    delete discache;
+  delete discache;
 }
 
 Sleigh::~Sleigh(void)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
index 038bc379e65..23ed6969825 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
@@ -463,9 +463,7 @@ void SleighArchitecture::scanForSleighDirectories(const string &rootpath)
 void SleighArchitecture::shutdown(void)
 
 {
-  if (last_sleigh != (Sleigh *)0) {
-    delete last_sleigh;
-    last_sleigh = (Sleigh *)0;
-  }
+  delete last_sleigh;
+  last_sleigh = (Sleigh *)0;
   // description.clear();  // static vector is destroyed by the normal exit handler
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
index 4ebeaa000c3..bbc9b1600f1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
@@ -692,10 +692,8 @@ void ContextPattern::restoreXml(const Element *el)
 CombinePattern::~CombinePattern(void)
 
 {
-  if (context != (ContextPattern *)0)
-    delete context;
-  if (instr != (InstructionPattern *)0)
-    delete instr;
+  delete context;
+  delete instr;
 }
 
 bool CombinePattern::isMatch(ParserWalker &walker) const
@@ -843,10 +841,8 @@ OrPattern::OrPattern(const vector<DisjointPattern *> &list)
 OrPattern::~OrPattern(void)
 
 {
-  vector<DisjointPattern *>::iterator iter;
-
-  for(iter=orlist.begin();iter!=orlist.end();++iter)
-    delete *iter;
+  for(auto *it : orlist)
+    delete it;
 }
 
 void OrPattern::shiftInstruction(int4 sa)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
index 05b98e00ad9..1b391362b12 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
@@ -88,7 +88,7 @@ public:
   InstructionPattern(PatternBlock *mv) { maskvalue = mv; }
   InstructionPattern(bool tf) { maskvalue = new PatternBlock(tf); }
   PatternBlock *getBlock(void) { return maskvalue; }
-  virtual ~InstructionPattern(void) { if (maskvalue != (PatternBlock *)0) delete maskvalue; }
+  virtual ~InstructionPattern(void) { delete maskvalue; }
   virtual Pattern *simplifyClone(void) const { return new InstructionPattern(maskvalue->clone()); }
   virtual void shiftInstruction(int4 sa) { maskvalue->shift(sa); }
   virtual Pattern *doOr(const Pattern *b,int4 sa) const;
@@ -109,7 +109,7 @@ public:
   ContextPattern(void) { maskvalue = (PatternBlock *)0; } // For use with restoreXml
   ContextPattern(PatternBlock *mv) { maskvalue = mv; }
   PatternBlock *getBlock(void) { return maskvalue; }
-  virtual ~ContextPattern(void) { if (maskvalue != (PatternBlock *)0) delete maskvalue; }
+  virtual ~ContextPattern(void) { delete maskvalue; }
   virtual Pattern *simplifyClone(void) const { return new ContextPattern(maskvalue->clone()); }
   virtual void shiftInstruction(int4 sa) { }  // do nothing
   virtual Pattern *doOr(const Pattern *b,int4 sa) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
index 5f4a8fe3230..485c60cecd3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
@@ -43,12 +43,10 @@ SleighSymbol *SymbolScope::findSymbol(const string &nm) const
 SymbolTable::~SymbolTable(void)
 
 {
-  vector<SymbolScope *>::iterator iter;
-  for(iter=table.begin();iter!=table.end();++iter)
-    delete *iter;
-  vector<SleighSymbol *>::iterator siter;
-  for(siter=symbollist.begin();siter!=symbollist.end();++siter)
-    delete *siter;
+  for(auto *it : table)
+    delete it;
+  for(auto *it : symbollist)
+    delete it;
 }
 
 void SymbolTable::addScope(void)
@@ -1388,20 +1386,14 @@ Constructor::Constructor(SubtableSymbol *p)
 Constructor::~Constructor(void)
 
 {
-  if (pattern != (TokenPattern *)0)
-    delete pattern;
+  delete pattern;
   if (pateq != (PatternEquation *)0)
     PatternEquation::release(pateq);
-  if (templ != (ConstructTpl *)0)
-    delete templ;
-  for(int4 i=0;i<namedtempl.size();++i) {
-    ConstructTpl *ntpl = namedtempl[i];
-    if (ntpl != (ConstructTpl *)0)
-      delete ntpl;
-  }
-  vector<ContextChange *>::iterator iter;
-  for(iter=context.begin();iter!=context.end();++iter)
-    delete *iter;
+  delete templ;
+  for(auto *it : namedtempl)
+    delete it;
+  for(auto *it : context)
+    delete it;
 }
 
 void Constructor::addInvisibleOperand(OperandSymbol *sym)
@@ -1891,13 +1883,10 @@ SubtableSymbol::SubtableSymbol(const string &nm) : TripleSymbol(nm)
 SubtableSymbol::~SubtableSymbol(void)
 
 {
-  if (pattern != (TokenPattern *)0)
-    delete pattern;
-  if (decisiontree != (DecisionNode *)0)
-    delete decisiontree;
-  vector<Constructor *>::iterator iter;
-  for(iter=construct.begin();iter!=construct.end();++iter)
-    delete *iter;
+  delete pattern;
+  delete decisiontree;
+  for(auto *it : construct)
+    delete it;
 }
 
 void SubtableSymbol::collectLocalValues(vector<uintb> &results) const
@@ -2047,12 +2036,10 @@ DecisionNode::DecisionNode(DecisionNode *p)
 DecisionNode::~DecisionNode(void)
 
 {				// We own sub nodes
-  vector<DecisionNode *>::iterator iter;
-  for(iter=children.begin();iter!=children.end();++iter)
-    delete *iter;
-  vector<pair<DisjointPattern *,Constructor *> >::iterator piter;
-  for(piter=list.begin();piter!=list.end();++piter)
-    delete (*piter).first;	// Delete the patterns
+  for(auto *it : children)
+    delete it;
+  for(auto &it : list)
+    delete it.first;	// Delete the patterns
 }
 
 void DecisionNode::addConstructorPair(const DisjointPattern *pat,Constructor *ct)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
index 11aafca1be3..36d086e5800 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
@@ -604,7 +604,7 @@ public:
   void addOperand(OperandSymbol *sym) { operands.push_back(sym); }
   int4 getNumOperands(void) const { return operands.size(); }
   OperandSymbol *getOperand(int4 i) const { return operands[i]; }
-  virtual ~MacroSymbol(void) { if (construct != (ConstructTpl *)0) delete construct; }
+  virtual ~MacroSymbol(void) { delete construct; }
   virtual symbol_type getType(void) const { return macro_symbol; }
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
index c60d99bdb7b..d70b88b4382 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
@@ -325,9 +325,8 @@ bool LanedRegister::restoreXml(const Element *el,const AddrSpaceManager *manage)
 TransformManager::~TransformManager(void)
 
 {
-  map<int4,TransformVar *>::iterator iter;
-  for(iter=pieceMap.begin();iter!=pieceMap.end();++iter) {
-    delete [] (*iter).second;
+  for(auto &it : pieceMap) {
+    delete [] it.second;
   }
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
index 6a397be4a4a..6d4c889f099 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
@@ -416,8 +416,7 @@ void AddrSpaceManager::insertResolver(AddrSpace *spc,AddressResolver *rsolv)
   int4 ind = spc->getIndex();
   while(resolvelist.size() <= ind)
     resolvelist.push_back((AddressResolver *)0);
-  if (resolvelist[ind] != (AddressResolver *)0)
-    delete resolvelist[ind];
+  delete resolvelist[ind];
   resolvelist[ind] = rsolv;
 }
 
@@ -444,10 +443,8 @@ AddrSpaceManager::~AddrSpaceManager(void)
     else
       delete spc;
   }
-  for(int4 i=0;i<resolvelist.size();++i) {
-    if (resolvelist[i] != (AddressResolver *)0)
-      delete resolvelist[i];
-  }
+  for(int4 i=0;i<resolvelist.size();++i)
+    delete resolvelist[i];
   for(int4 i=0;i<splitlist.size();++i)
     delete splitlist[i];	// Delete any join records
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
index 97399808216..c543cd7fe15 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
@@ -1114,8 +1114,7 @@ void TypeCode::set(TypeFactory *tfact,ProtoModel *model,
 {
   factory = tfact;
   flags |= variable_length;
-  if (proto != (FuncProto *)0)
-    delete proto;
+  delete proto;
   proto = new FuncProto();
   proto->setInternal(model,voidtype);
   vector<Datatype *> typelist;
@@ -1153,8 +1152,7 @@ TypeCode::TypeCode(const string &nm) : Datatype(1,TYPE_CODE,nm)
 TypeCode::~TypeCode(void)
 
 {
-  if (proto != (FuncProto *)0)
-    delete proto;
+  delete proto;
 }
 
 void TypeCode::printRaw(ostream &s) const
@@ -1305,11 +1303,11 @@ void TypeCode::restoreXml(const Element *el,TypeFactory &typegrp)
     flags |= variable_length;
   }
   restoreXmlBasic(el);
-  if (proto != (FuncProto *)0) {
-    delete proto;
+  delete proto;
+  if (iter == list.end()) {
     proto = (FuncProto *)0;
+    return; // No underlying prototype
   }
-  if (iter == list.end()) return; // No underlying prototype
   Architecture *glb = typegrp.getArch();
   factory = &typegrp;
   proto = new FuncProto();
@@ -1604,10 +1602,8 @@ void TypeFactory::cacheCoreTypes(void)
 void TypeFactory::clear(void)
 
 {
-  DatatypeSet::iterator iter;
-
-  for(iter=tree.begin();iter!=tree.end();++iter)
-    delete *iter;
+  for(auto *it : tree)
+    delete it;
   tree.clear();
   nametree.clear();
   clearCache();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
index 56ce320bc4d..630b48b5732 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
@@ -161,8 +161,7 @@ TypeOp::TypeOp(TypeFactory *t,OpCode opc,const string &n)
 TypeOp::~TypeOp(void)
 
 {
-  if (behave != (OpBehavior *)0)
-    delete behave;
+  delete behave;
 }
 
 /// \return \b true if the ordering of the inputs does not affect the output
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
index d848cfc7dd6..ead8547ad2c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
@@ -246,8 +246,7 @@ ConstantExpression::~ConstantExpression(void)
 
 {
   delete expr1;
-  if (expr2 != (RHSConstant *)0)
-    delete expr2;
+  delete expr2;
 }
 
 RHSConstant *ConstantExpression::clone(void)
@@ -417,8 +416,7 @@ ConstraintVarConst::~ConstraintVarConst(void)
 
 {
   delete expr;
-  if (exprsz != (RHSConstant *)0)
-    delete exprsz;
+  delete exprsz;
 }
 
 UnifyConstraint *ConstraintVarConst::clone(void) const
@@ -1350,8 +1348,7 @@ ConstraintSetInputConstVal::~ConstraintSetInputConstVal(void)
 {
   delete val;
   delete slot;
-  if (exprsz != (RHSConstant *)0)
-    delete exprsz;
+  delete exprsz;
 }
 
 UnifyConstraint *ConstraintSetInputConstVal::clone(void) const
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
index 0d13d3a7b6a..25256de2f59 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
@@ -303,13 +303,8 @@ UserOpManage::UserOpManage(void)
 UserOpManage::~UserOpManage(void)
 
 {
-  vector<UserPcodeOp *>::iterator iter;
-
-  for(iter=useroplist.begin();iter!=useroplist.end();++iter) {
-    UserPcodeOp *userop = *iter;
-    if (userop != (UserPcodeOp *)0)
-      delete userop;
-  }
+  for(auto *op : useroplist)
+    delete op;
 }
 
 /// Every user defined p-code op is initially assigned an UnspecializedPcodeOp description,
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
index 7a651026cfd..38694f71d69 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
@@ -732,9 +732,8 @@ MapState::MapState(AddrSpace *spc,const RangeList &rn,
 MapState::~MapState(void)
 
 {
-  vector<RangeHint *>::iterator iter;
-  for(iter=maplist.begin();iter!=maplist.end();++iter)
-    delete *iter;
+  for(auto *it : maplist)
+    delete it;
 }
 
 /// A specific range of bytes is described for the hint, given a starting offset and other information.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
index 9192305070b..97971d39ffa 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
@@ -217,10 +217,8 @@ void Varnode::updateCover(void) const
 void Varnode::clearCover(void) const
 
 {
-  if (cover != (Cover *)0) {
-    delete cover;
-    cover = (Cover *)0;
-  }
+  delete cover;
+  cover = (Cover *)0;
 }
 
 /// Initialize a new Cover and set dirty bit so that updateCover will rebuild
@@ -228,8 +226,7 @@ void Varnode::calcCover(void) const
 
 {
   if (hasCover()) {
-    if (cover != (Cover *)0)
-      delete cover;
+    delete cover;
     cover = new Cover;
     setFlags(Varnode::coverdirty);
   }
@@ -555,8 +552,7 @@ Varnode::Varnode(int4 s,const Address &m,Datatype *dt)
 Varnode::~Varnode(void)
 
 {
-  if (cover != (Cover *)0)
-    delete cover;
+  delete cover;
   if (high != (HighVariable *)0) {
     high->remove(this);
     if (high->isUnattached())
@@ -864,10 +860,8 @@ VarnodeBank::VarnodeBank(AddrSpaceManager *m,AddrSpace *uspace,uintm ubase)
 void VarnodeBank::clear(void)
 
 {
-  VarnodeLocSet::iterator iter;
-
-  for(iter=loc_tree.begin();iter!=loc_tree.end();++iter)
-    delete *iter;
+  for(auto *it : loc_tree)
+    delete it;
 
   loc_tree.clear();
   def_tree.clear();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
index 51fb5870ca2..946886b4266 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
@@ -1954,8 +1954,7 @@ XmlScan::~XmlScan(void)
 void XmlScan::clearlvalue(void)
 
 {
-  if (lvalue != (string *)0)
-    delete lvalue;
+  delete lvalue;
 }
 
 int4 XmlScan::scanSingle(void)
@@ -2275,10 +2274,8 @@ void TreeHandler::characters(const char *text,int4 start,int4 length)
 Element::~Element(void)
 
 {
-  List::iterator iter;
-  
-  for(iter=children.begin();iter!=children.end();++iter)
-    delete *iter;
+  for(auto *it : children)
+    delete it;
 }
 
 const string &Element::getAttributeValue(const string &nm) const
@@ -2293,10 +2290,8 @@ const string &Element::getAttributeValue(const string &nm) const
 DocumentStorage::~DocumentStorage(void)
 
 {
-  for(int4 i=0;i<doclist.size();++i) {
-    if (doclist[i] != (Document *)0)
-      delete doclist[i];
-  }
+  for(int4 i=0;i<doclist.size();++i)
+    delete doclist[i];
 }
 
 Document *DocumentStorage::parseDocument(istream &s)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
index 7c4c60aaacd..1aedc49c627 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
@@ -232,8 +232,7 @@ XmlScan::~XmlScan(void)
 void XmlScan::clearlvalue(void)
 
 {
-  if (lvalue != (string *)0)
-    delete lvalue;
+  delete lvalue;
 }
 
 int4 XmlScan::scanSingle(void)
@@ -553,10 +552,8 @@ void TreeHandler::characters(const char *text,int4 start,int4 length)
 Element::~Element(void)
 
 {
-  List::iterator iter;
-  
-  for(iter=children.begin();iter!=children.end();++iter)
-    delete *iter;
+  for(auto *it : children)
+    delete it;
 }
 
 const string &Element::getAttributeValue(const string &nm) const
@@ -571,10 +568,8 @@ const string &Element::getAttributeValue(const string &nm) const
 DocumentStorage::~DocumentStorage(void)
 
 {
-  for(int4 i=0;i<doclist.size();++i) {
-    if (doclist[i] != (Document *)0)
-      delete doclist[i];
-  }
+  for(int4 i=0;i<doclist.size();++i)
+    delete doclist[i];
 }
 
 Document *DocumentStorage::parseDocument(istream &s)
