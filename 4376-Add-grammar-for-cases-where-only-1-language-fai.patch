diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index 3ec58b9d051..f0d1a4381ab 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -1981,7 +1981,10 @@ void SleighCompile::checkConsistency(void)
   if ((!warndeadtemps)&&(checker.getNumWriteNoRead() > 0)) {
     ostringstream msg;
     msg << dec << checker.getNumWriteNoRead();
-    msg << " operations wrote to temporaries that were not read";
+    if (checker.getNumWriteNoRead() == 1)
+      msg << " operation wrote to temporaries that were not read";
+    else
+      msg << " operations wrote to temporaries that were not read";
     reportWarning(msg.str());
     reportWarning("Use -t switch to list each individually");
   }
@@ -2081,7 +2084,7 @@ void SleighCompile::checkLocalCollisions(void)
   }
   if (collisionCount > 0) {
     ostringstream msg;
-    msg << dec << collisionCount << " constructors with local collisions between operands";
+    msg << dec << collisionCount << ((collisionCount == 1) ? " constructor" : " constructors") << " with local collisions between operands";
     reportWarning(msg.str());
     if (!warnalllocalcollisions)
       reportWarning("Use -c switch to list each individually");
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
index f390239f162..30040f7e81c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
@@ -454,21 +454,21 @@ private void buildDecisionTrees() {
 		DecisionProperties props = new DecisionProperties();
 		root.buildDecisionTree(props);
 
-		for (int i = 0; i < tables.size(); ++i) {
-			tables.get(i).buildDecisionTree(props);
+		for (SubtableSymbol symbol : tables) {
+			symbol.buildDecisionTree(props);
 		}
 		VectorSTL<String> ierrors = props.getIdentErrors();
 //    		const vector<string> &ierrors( props.getIdentErrors() );
-		for (int i = 0; i < ierrors.size(); ++i) {
+		for (String error : ierrors) {
 			errors += 1;
-			Msg.error(this, ierrors.get(i));
+			Msg.error(this, error);
 		}
 
 		if (!lenientconflicterrors) {
 			VectorSTL<String> cerrors = props.getConflictErrors();
-			for (int i = 0; i < cerrors.size(); ++i) {
+			for (String error : cerrors) {
 				errors += 1;
-				Msg.error(this, cerrors.get(i));
+				Msg.error(this, error);
 			}
 		}
 	}
@@ -509,8 +509,13 @@ private void checkConsistency() {
 			return;
 		}
 		if ((!warnunnecessarypcode) && (checker.getNumUnnecessaryPcode() > 0)) {
-			reportWarning(null, checker.getNumUnnecessaryPcode() +
-				" unnecessary extensions/truncations were converted to copies");
+			if (checker.getNumUnnecessaryPcode() == 1) {
+				reportWarning(null, "1 unnecessary extension/truncation was converted to a copy");
+			}
+			else {
+				reportWarning(null, checker.getNumUnnecessaryPcode() +
+					" unnecessary extensions/truncations were converted to copies");
+			}
 			reportWarning(null, "Use -u switch to list each individually");
 		}
 		checker.optimizeAll();
@@ -519,16 +524,20 @@ private void checkConsistency() {
 			return;
 		}
 		if ((!warndeadtemps) && (checker.getNumWriteNoRead() > 0)) {
-			reportWarning(null, checker.getNumWriteNoRead() +
-				" operations wrote to temporaries that were not read");
+			reportWarning(null, String.format("%d operation%s wrote to temporaries that were not read", checker.getNumWriteNoRead() , checker.getNumWriteNoRead() == 1 ? "" : "s"));
 			reportWarning(null, "Use -t switch to list each individually");
 		}
 		checker.testLargeTemporary();
 		if ((!largetemporarywarning) && checker.getNumLargeTemporaries() > 0) {
-			reportWarning(null,
-				checker.getNumLargeTemporaries() +
-					" constructors contain temporaries larger than " + SleighBase.MAX_UNIQUE_SIZE +
-					" bytes.");
+			if (checker.getNumLargeTemporaries() == 1) {
+				reportWarning(null, "1 constructor contains temporaries larger than " + SleighBase.MAX_UNIQUE_SIZE +
+						" bytes.");
+			} else {
+				reportWarning(null,
+						checker.getNumLargeTemporaries() +
+								" constructors contain temporaries larger than " + SleighBase.MAX_UNIQUE_SIZE +
+								" bytes.");
+			}
 			reportWarning(null, "Use -o switch to list each individually.");
 		}
 	}
@@ -598,8 +607,7 @@ private void checkLocalCollisions() {
 			sym = tables.get(i);
 		}
 		if (collisionCount > 0) {
-			reportWarning(null,
-				collisionCount + " constructors with local collisions between operands");
+			reportWarning(null, String.format("%d constructor%s with local collisions between operands", collisionCount, collisionCount == 1 ? "" : "s"));
 			if (!warnalllocalcollisions) {
 				reportWarning(null, "Use -c switch to list each individually");
 			}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
index 014481488a0..6b664e9b11e 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompileLauncher.java
@@ -220,12 +220,12 @@ else if (args[i].charAt(1) == 'x') {
 					++totalSuccesses;
 				}
 			}
-			System.out.println(totalSuccesses + " languages successfully compiled");
+			System.out.println(String.format("%d language%s successfully compiled", totalSuccesses, totalSuccesses == 1 ? "" : "s"));
 			if (totalFailures != 0) {
 				for (String path : failures) {
 					System.out.println(path + " failed to compile");
 				}
-				System.out.println(totalFailures + " languages total failed to compile");
+				System.out.println(String.format("%d language%s failed to compile", totalFailures, totalFailures == 1 ? "" : "s"));
 			}
 			return -totalFailures;
 		}
@@ -288,7 +288,7 @@ private static String[] injectOptionsFromFile(String[] args, int index) {
 			String option = r.readLine();
 			while (option != null) {
 				option = option.trim();
-				if (option.length() != 0 && !option.startsWith("#")) {
+				if (option.length() != 0 && option.charAt(0) != '#') {
 					list.add(option);
 				}
 				option = r.readLine();
