From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ben Shelton <ben.shelton@gmail.com>
Date: Mon, 27 Mar 2023 21:33:02 -0500
Subject: [PATCH] 5178: Fix a few issues with PEF relocation and loading

- Fix a bug where the repeatCount for the repeated block unpacking opcode is
  decremented by one rather than incremented by one. See Mac OS Runtime
  Architectures page 8-13 for how this is supposed to work.

- Implement the RelocSmRepeat and RelocLgRepeat relocation opcodes. The basic
  approach is to go back over the preceding blocks the specified number of
  times and insert new Relocation instances for each iteration. This approach
  may not scale the best for large numbers of repeats, but for real-world
  scenarios it seems to work OK.

- Implement the RelocLgSetOrBySection relocation opcode in the same manner as
  the RelocByIndexGroup opcode.

- Fix a couple of incorrect masks for the large opcodes.
---
 .../app/util/bin/format/pef/ParseState.java   | 58 +++++++++++++++++
 .../bin/format/pef/RelocByIndexGroup.java     |  2 +-
 .../bin/format/pef/RelocBySectDWithSkip.java  |  2 +-
 .../bin/format/pef/RelocIncrPosition.java     |  2 +-
 .../util/bin/format/pef/RelocLgByImport.java  |  2 +-
 .../util/bin/format/pef/RelocLgRepeat.java    | 28 +++++++--
 .../bin/format/pef/RelocLgSetOrBySection.java | 63 ++++++++++++++++++-
 .../util/bin/format/pef/RelocSetPosition.java |  2 +-
 .../util/bin/format/pef/RelocSmRepeat.java    | 24 +++++--
 .../bin/format/pef/RelocUndefinedOpcode.java  |  2 +-
 .../util/bin/format/pef/RelocValueGroup.java  |  2 +-
 .../bin/format/pef/RelocationFactory.java     |  6 +-
 .../util/bin/format/pef/SectionHeader.java    |  2 +-
 13 files changed, 172 insertions(+), 23 deletions(-)
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/ParseState.java

diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/ParseState.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/ParseState.java
new file mode 100644
index 000000000..e6d90b8df
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/ParseState.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.pef;
+
+/**
+ * This class maintains the running state while
+ * parsing PEF relocations.
+ * <p>
+ * <b><code>loopCount</code></b>
+ * Holds the number of times the current repeat has been processed.
+ * <p>
+ * <b><code>lastIndex</code></b>
+ * Holds an index in the BinaryReader for the currently-active repeat.
+ */
+public class ParseState {
+	private int loopCount = 0;
+	private long lastIndex = -1;
+
+	/**
+	 * Increments the loop count by one.
+	 * @param index the index in the BinaryReader for the repeat
+	 */
+	public void incrementLoopCount(long index) {
+		if (lastIndex != -1 && lastIndex != index)
+			throw new RuntimeException("active repeat is at a different index; nesting repeats is not permitted!");
+
+		++loopCount;
+	}
+
+	/**
+	 * Clears the loop count.
+	 */
+	public void clearLoopCount() {
+		loopCount = 0;
+		lastIndex = -1;
+	}
+
+	/**
+	 * Returns the loop count.
+	 * @return the current loop count
+	 */
+	public int getLoopCount() {
+		return this.loopCount;
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocByIndexGroup.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocByIndexGroup.java
index c38f6fbea..ae4b98180 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocByIndexGroup.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocByIndexGroup.java
@@ -61,7 +61,7 @@ public class RelocByIndexGroup extends Relocation {
 	private int subopcode;
 	private int index;
 
-	RelocByIndexGroup(BinaryReader reader) throws IOException {
+	RelocByIndexGroup(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode    =  (value & 0xe000) >> 13;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocBySectDWithSkip.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocBySectDWithSkip.java
index 4d003222b..64adca11a 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocBySectDWithSkip.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocBySectDWithSkip.java
@@ -29,7 +29,7 @@ public class RelocBySectDWithSkip extends Relocation {
 	private int skipCount;
 	private int relocCount;
 
-	RelocBySectDWithSkip(BinaryReader reader) throws IOException {
+	RelocBySectDWithSkip(BinaryReader reader, ParseState parseState) throws IOException {
 		int value  = reader.readNextShort() & 0xffff;
 
 		opcode     = ((value & 0xc000) >> 14) & 0x3;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocIncrPosition.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocIncrPosition.java
index 2c9a7e832..65f1785de 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocIncrPosition.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocIncrPosition.java
@@ -28,7 +28,7 @@ import ghidra.util.task.TaskMonitor;
 public class RelocIncrPosition extends Relocation {
 	private int offset;
 
-	RelocIncrPosition(BinaryReader reader) throws IOException {
+	RelocIncrPosition(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode = (value & 0xf000) >> 12;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgByImport.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgByImport.java
index 0d25c23fa..6b04d4653 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgByImport.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgByImport.java
@@ -32,7 +32,7 @@ import java.util.List;
 public class RelocLgByImport extends Relocation {
 	private int index;
 
-	RelocLgByImport(BinaryReader reader) throws IOException {
+	RelocLgByImport(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode  =  (value & 0xfc00) >> 10;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgRepeat.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgRepeat.java
index 010c29f5e..6785512ea 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgRepeat.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgRepeat.java
@@ -28,19 +28,36 @@ import java.io.IOException;
 public class RelocLgRepeat extends Relocation {
 	private int chunkCount;
 	private int repeatCount;
+	private BinaryReader reader;
+	private ParseState parseState;
 
-	RelocLgRepeat(BinaryReader reader) throws IOException {
+	RelocLgRepeat(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode       =  (value & 0xfc00) >> 10;
-		chunkCount   =  (value & 0x0330) >>  6;
+		chunkCount   =  (value & 0x03c0) >>  6;
 		repeatCount  =  (value & 0x003f) << 16;
 		repeatCount |=  reader.readNextShort() & 0xffff;
+
+		this.reader = reader;
+		this.parseState = parseState;
 	}
 
 	@Override
 	public boolean isMatch() {
-		return opcode == 0x2c;
+		if (opcode != 0x2c)
+			return false;
+
+		parseState.incrementLoopCount(reader.getPointerIndex() - 4);
+		if (parseState.getLoopCount() == repeatCount) {
+			/* done looping */
+			parseState.clearLoopCount();
+		} else {
+			/* go back two chunks for this command plus the number of chunks specified */
+			reader.setPointerIndex(reader.getPointerIndex() - 4 - (2 * (chunkCount + 1)));
+		}
+
+		return true;
 	}
 
 	@Override
@@ -53,13 +70,12 @@ public class RelocLgRepeat extends Relocation {
 	}
 
 	public int getRepeatCount() {
-		return repeatCount + 1;
+		return repeatCount;
 	}
 
 	@Override
 	public void apply(ImportStateCache importState, RelocationState relocState, 
 			ContainerHeader header, Program program, MessageLog log, TaskMonitor monitor) {
-		
-		throw new RuntimeException("Unhandled relocation: RelocLgRepeat");
+		/* nothing to do */
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgSetOrBySection.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgSetOrBySection.java
index 4c9b62d60..6e75561e5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgSetOrBySection.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocLgSetOrBySection.java
@@ -18,6 +18,8 @@ package ghidra.app.util.bin.format.pef;
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.symbol.*;
 import ghidra.util.task.TaskMonitor;
 
 import java.io.IOException;
@@ -26,14 +28,35 @@ import java.io.IOException;
  * See Apple's -- PEFBinaryFormat.h
  */
 public class RelocLgSetOrBySection extends Relocation {
+	/**
+	 * This instruction adds the address of the instantiated
+	 * section specified by <code>index</code> to the word
+	 * pointed to by <code>relocAddress</code>. After
+	 * execution, <code>relocAddress</code> points to just
+	 * past the modified word.
+	 */
+	public final static int kPEFRelocLgBySection = 0;
+	/**
+	 * This instruction sets the variable <code>sectionC</code>
+	 * to the memory address of the instantiated section
+	 * specified by <code>index</code>.
+	 */
+	public final static int kPEFRelocLgSetSectC = 1;
+	/**
+	 * This instruction sets the variable <code>sectionD</code>
+	 * to the memory adddress of the instantiated section
+	 * specified by <code>index</code>.
+	 */
+	public final static int kPEFRelocLgSetSectD = 2;
+
 	private int subopcode;
 	private int index;
 
-	RelocLgSetOrBySection(BinaryReader reader) throws IOException {
+	RelocLgSetOrBySection(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode    =  (value & 0xfc00) >> 10;
-		subopcode =  (value & 0x0330) >> 6;
+		subopcode =  (value & 0x03c0) >> 6;
 		index     =  (value & 0x003f) << 16;
 		index    |=  reader.readNextShort() & 0xffff;
 	}
@@ -56,10 +79,44 @@ public class RelocLgSetOrBySection extends Relocation {
 		return index;
 	}
 
+        @Override
+	public String toString() {
+		switch (subopcode) {
+			case kPEFRelocLgBySection: return "RelocLgBySection";
+			case kPEFRelocLgSetSectC:  return "RelocLgSetSectC";
+			case kPEFRelocLgSetSectD:  return "RelocLgSetSectD";
+		}
+		return super.toString();
+	}
+
 	@Override
 	public void apply(ImportStateCache importState, RelocationState relocState, 
 			ContainerHeader header, Program program, MessageLog log, TaskMonitor monitor) {
 
-		throw new RuntimeException("Unhandled relocation: RelocLgSetOrBySection");
+		switch (subopcode) {
+			case kPEFRelocLgBySection: {
+				SectionHeader sect = header.getSections().get(index);
+				MemoryBlock block = importState.getMemoryBlockForSection(sect);
+				relocState.relocateMemoryAt(relocState.getRelocationAddress(),
+											(int)block.getStart().getOffset(), log);
+				break;
+			}
+			case kPEFRelocLgSetSectC: {
+				SectionHeader sectC = header.getSections().get(index);
+				MemoryBlock blockC = importState.getMemoryBlockForSection(sectC);
+				relocState.setSectionC(blockC.getStart());
+				break;
+			}
+			case kPEFRelocLgSetSectD: {
+				SectionHeader sectD = header.getSections().get(index);
+				MemoryBlock blockD = importState.getMemoryBlockForSection(sectD);
+				relocState.setSectionD(blockD.getStart());
+				break;
+			}
+			default: {
+				log.appendMsg("Unsupported RelocLgSetOrBySection subopcode: " + subopcode);
+				break;
+			}
+                }
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSetPosition.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSetPosition.java
index d7112b6ce..1dfde9e28 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSetPosition.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSetPosition.java
@@ -29,7 +29,7 @@ import java.io.IOException;
 public class RelocSetPosition extends Relocation {
 	private int offset;
 
-	RelocSetPosition(BinaryReader reader) throws IOException {
+	RelocSetPosition(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode   = ((value & 0xfc00) >> 10) & 0x3f;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSmRepeat.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSmRepeat.java
index 25323ca33..d12666fbc 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSmRepeat.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocSmRepeat.java
@@ -28,18 +28,35 @@ import java.io.IOException;
 public class RelocSmRepeat extends Relocation {
 	private int chunks;
 	private int repeatCount;
+	private BinaryReader reader;
+	private ParseState parseState;
 
-	RelocSmRepeat(BinaryReader reader) throws IOException {
+	RelocSmRepeat(BinaryReader reader, ParseState parseState) throws IOException {
 		int value   = reader.readNextShort() & 0xffff;
 
 		opcode      = (value & 0xf000) >> 12;
 		chunks      = (value & 0x0f00) >>  8;
 		repeatCount = (value & 0x00ff);
+
+		this.reader = reader;
+		this.parseState = parseState;
 	}
 
 	@Override
 	public boolean isMatch() {
-		return opcode == 0x9;
+		if (opcode != 0x9)
+			return false;
+
+		parseState.incrementLoopCount(reader.getPointerIndex() - 2);
+		if (parseState.getLoopCount() == repeatCount + 1) {
+			/* done looping */
+			parseState.clearLoopCount();
+		} else {
+			/* go back one chunk for this command plus the number of chunks specified */
+			reader.setPointerIndex(reader.getPointerIndex() - 2 - (2 * (chunks + 1)));
+		}
+
+		return true;
 	}
 
 	public int getChunks() {
@@ -53,7 +70,6 @@ public class RelocSmRepeat extends Relocation {
 	@Override
 	public void apply(ImportStateCache importState, RelocationState relocState, 
 			ContainerHeader header, Program program, MessageLog log, TaskMonitor monitor) {
-
-		throw new RuntimeException("Unhandled relocation: RelocSmRepeat");
+		/* nothing to do */
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocUndefinedOpcode.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocUndefinedOpcode.java
index bc76dc973..b554ee521 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocUndefinedOpcode.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocUndefinedOpcode.java
@@ -25,7 +25,7 @@ import java.io.IOException;
 
 public class RelocUndefinedOpcode extends Relocation {
 
-	RelocUndefinedOpcode(BinaryReader reader) throws IOException {
+	RelocUndefinedOpcode(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode = ((value & 0xff) >> 8) & 0xff;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocValueGroup.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocValueGroup.java
index 9159ad2f7..5f4317b55 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocValueGroup.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocValueGroup.java
@@ -43,7 +43,7 @@ public class RelocValueGroup extends Relocation {
 	private int subopcode;
 	private int runLength;
 
-	RelocValueGroup(BinaryReader reader) throws IOException {
+	RelocValueGroup(BinaryReader reader, ParseState parseState) throws IOException {
 		int value = reader.readNextShort() & 0xffff;
 
 		opcode    = (value & 0xe000) >> 13;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocationFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocationFactory.java
index 430b465d8..632740b4d 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocationFactory.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/RelocationFactory.java
@@ -36,12 +36,14 @@ public class RelocationFactory {
 		RelocValueGroup.class,
 	};
 
+	private static ParseState parseState = new ParseState();
+
 	public static Relocation getRelocation(BinaryReader reader) {
 		long index = reader.getPointerIndex();
 		for (Class<?> relocationClass : relocationClasses) {
 			try {
-				Constructor<?> constructor = relocationClass.getDeclaredConstructor(new Class[]{BinaryReader.class});
-				Relocation relocation = (Relocation)constructor.newInstance(new Object[]{reader});
+				Constructor<?> constructor = relocationClass.getDeclaredConstructor(new Class[]{BinaryReader.class, ParseState.class});
+				Relocation relocation = (Relocation)constructor.newInstance(new Object[]{reader, parseState});
 				if (relocation.isMatch()) {
 					return relocation;
 				}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/SectionHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/SectionHeader.java
index 18df9d529..a45bc6a20 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/SectionHeader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/pef/SectionHeader.java
@@ -153,7 +153,7 @@ public class SectionHeader implements StructConverter {
 						throw new IllegalStateException(
 							"Unable to read enough bytes for " + opcode);
 					}
-					for (int i = 0; i < repeatCount - 1; ++i) {
+					for (int i = 0; i < repeatCount + 1; ++i) {
 						System.arraycopy(rawData, 0, data, index, rawData.length);
 						index += rawData.length;
 					}
-- 
2.39.1

