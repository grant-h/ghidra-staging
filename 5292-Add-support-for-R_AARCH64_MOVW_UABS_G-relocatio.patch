From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ryan <ryan@picasso.lan>
Date: Thu, 4 May 2023 19:36:11 +0000
Subject: [PATCH] 5292: Add support for R_AARCH64_MOVW_UABS_G* relocations

---
 .../AARCH64_ElfRelocationHandler.java         | 83 +++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java
index 8db0bc5c9..04d6998bd 100644
--- a/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java
+++ b/Ghidra/Processors/AARCH64/src/main/java/ghidra/app/util/bin/format/elf/relocation/AARCH64_ElfRelocationHandler.java
@@ -71,6 +71,8 @@ public class AARCH64_ElfRelocationHandler extends ElfRelocationHandler {
 
 		boolean is64bit = true;
 		
+		boolean overflowCheck = true; // *_NC type relocations specify "no overflow check"
+
 		Address symbolAddr = elfRelocationContext.getSymbolAddress(sym);
 		long symbolValue = elfRelocationContext.getSymbolValue(sym);
 		long newValue = 0;
@@ -137,6 +139,87 @@ public class AARCH64_ElfRelocationHandler extends ElfRelocationHandler {
 				break;
 			}
 
+			// MOV[ZK]:   ((S+A) >>  0) & 0xffff
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G0_NC: {
+				overflowCheck = false;
+				// fall-through
+			}
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G0: {
+				int oldValue = memory.getInt(relocationAddress, isBigEndianInstructions);
+				long imm = (symbolValue + addend) >> 0;
+
+				oldValue &= ~(0xffff << 5);
+				newValue = oldValue | ((imm & 0xffff) << 5);
+
+				memory.setInt(relocationAddress, (int) newValue, isBigEndianInstructions);
+
+				if (overflowCheck && imm > 0xffffL) {
+					// relocation already applied; report overflow condition
+					markAsError(program, relocationAddress, "R_AARCH64_MOVW_UABS_G0", symbolName,
+						"Failed overflow check for R_AARCH64_MOVW_UABS_G0 immediate value",
+						elfRelocationContext.getLog());
+				}
+				break;
+			}
+
+			// MOV[ZK]:   ((S+A) >>  16) & 0xffff
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G1_NC: {
+				overflowCheck = false;
+				// fall-through
+			}
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G1: {
+				int oldValue = memory.getInt(relocationAddress, isBigEndianInstructions);
+				long imm = (symbolValue + addend) >> 16;
+
+				oldValue &= ~(0xffff << 5);
+				newValue = oldValue | ((imm & 0xffff) << 5);
+
+				memory.setInt(relocationAddress, (int) newValue, isBigEndianInstructions);
+
+				if (overflowCheck && imm > 0xffffL) {
+					// relocation already applied; report overflow condition
+					markAsError(program, relocationAddress, "R_AARCH64_MOVW_UABS_G0", symbolName,
+						"Failed overflow check for R_AARCH64_MOVW_UABS_G0 immediate value",
+						elfRelocationContext.getLog());
+				}
+				break;
+			}
+
+			// MOV[ZK]:   ((S+A) >>  32) & 0xffff
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G2_NC: {
+				overflowCheck = false;
+				// fall-through
+			}
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G2: {
+				int oldValue = memory.getInt(relocationAddress, isBigEndianInstructions);
+				long imm = (symbolValue + addend) >> 32;
+
+				oldValue &= ~(0xffff << 5);
+				newValue = oldValue | ((imm & 0xffff) << 5);
+
+				memory.setInt(relocationAddress, (int) newValue, isBigEndianInstructions);
+
+				if (overflowCheck && imm > 0xffffL) {
+					// relocation already applied; report overflow condition
+					markAsError(program, relocationAddress, "R_AARCH64_MOVW_UABS_G0", symbolName,
+						"Failed overflow check for R_AARCH64_MOVW_UABS_G0 immediate value",
+						elfRelocationContext.getLog());
+				}
+				break;
+			}
+
+			// MOV[ZK]:   ((S+A) >>  48) & 0xffff
+			case AARCH64_ElfRelocationConstants.R_AARCH64_MOVW_UABS_G3: {
+				int oldValue = memory.getInt(relocationAddress, isBigEndianInstructions);
+				long imm = (symbolValue + addend) >> 48;
+
+				oldValue &= ~(0xffff << 5);
+				newValue = oldValue | ((imm & 0xffff) << 5);
+
+				memory.setInt(relocationAddress, (int) newValue, isBigEndianInstructions);
+				break;
+			}
+
 			// ADRH: ((PG(S+A)-PG(P)) >> 12) & 0x1fffff
 			case AARCH64_ElfRelocationConstants.R_AARCH64_ADR_PREL_PG_HI21:
 			case AARCH64_ElfRelocationConstants.R_AARCH64_P32_ADR_PREL_PG_HI21: {
-- 
2.40.0

