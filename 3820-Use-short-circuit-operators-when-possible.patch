diff --git a/GPL/DMG/src/dmg/java/mobiledevices/dmg/reader/DmgFileReader.java b/GPL/DMG/src/dmg/java/mobiledevices/dmg/reader/DmgFileReader.java
index 436d7ab68ce..958e1193fab 100644
--- a/GPL/DMG/src/dmg/java/mobiledevices/dmg/reader/DmgFileReader.java
+++ b/GPL/DMG/src/dmg/java/mobiledevices/dmg/reader/DmgFileReader.java
@@ -287,7 +287,7 @@ public List<FSEntry> getListing( String path ) {
 	 * If the entry is actually a directory, then -1 is returned.
 	 */
 	public long getLength( FSEntry entry ) {
-		if ( entry != null & entry.isFile() ) {
+		if (entry != null && entry.isFile()) {
 			FSFork mainFork = entry.asFile().getMainFork();
 			if ( mainFork.getLength() > 0 ) {
 				return mainFork.getLength();
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceBytesPcodeExecutorState.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceBytesPcodeExecutorState.java
index 8ae9af63e87..35558678127 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceBytesPcodeExecutorState.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceBytesPcodeExecutorState.java
@@ -97,7 +97,7 @@ public long getSnap() {
 	}
 
 	public void setThread(TraceThread thread) {
-		if (thread != null & thread.getTrace() != trace) {
+		if (thread != null && thread.getTrace() != trace) {
 			throw new IllegalArgumentException("Thread, if given, must be part of the same trace");
 		}
 		this.thread = thread;
diff --git a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceMemoryStatePcodeExecutorStatePiece.java b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceMemoryStatePcodeExecutorStatePiece.java
index 8d320d44588..aec3277e945 100644
--- a/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceMemoryStatePcodeExecutorStatePiece.java
+++ b/Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/pcode/exec/trace/TraceMemoryStatePcodeExecutorStatePiece.java
@@ -67,7 +67,7 @@ public long getSnap() {
 	}
 
 	public void setThread(TraceThread thread) {
-		if (thread != null & thread.getTrace() != trace) {
+		if (thread != null && thread.getTrace() != trace) {
 			throw new IllegalArgumentException("Thread, if given, must be part of the same trace");
 		}
 		this.thread = thread;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
index 9d5ddddad06..79f72c5a219 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
@@ -309,7 +309,7 @@ protected boolean doDisassembly(TaskMonitor monitor, Program program,
 			doDisassemblySeeds(disassembler, seedSet, mgr);
 		}
 
-		return disassemblyPerformed || (!nonExecutableStart & !unalignedStart);
+		return disassemblyPerformed || (!nonExecutableStart && !unalignedStart);
 	}
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/nav/LocationMemento.java b/Ghidra/Features/Base/src/main/java/ghidra/app/nav/LocationMemento.java
index 7b0c9210e72..124e3be9321 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/nav/LocationMemento.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/nav/LocationMemento.java
@@ -126,13 +126,10 @@ private boolean compareLocations(ProgramLocation loc1, ProgramLocation loc2) {
 		if (loc1.getClass() == loc2.getClass()) {
 			return true;
 		}
-		// at this point we know they have the some addresses, but different location types (fields)
+		// at this point we know they have the same addresses, but different location types (fields)
 		// also consider generic program locations to be equal to addressField locations
-		boolean isAddr1 =
-			loc1 instanceof AddressFieldLocation || loc1.getClass() == ProgramLocation.class;
-		boolean isAddr2 =
-			loc2 instanceof AddressFieldLocation || loc2.getClass() == ProgramLocation.class;
-		return isAddr1 & isAddr2;
+		return (loc1 instanceof AddressFieldLocation || loc1.getClass() == ProgramLocation.class) &&
+			(loc2 instanceof AddressFieldLocation || loc2.getClass() == ProgramLocation.class);
 	}
 
 	public void saveState(SaveState saveState) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
index 120e48a7277..476b5319235 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
@@ -71,7 +71,7 @@ public MergeableBackgroundCommand mergeCommands(MergeableBackgroundCommand comma
 			+ "managers of the two commands are the same instance and this is not the case.");
 
 		// once we encounter a markAsAnalyzed value that is true, then leave it on
-		markAsAnalyzed = markAsAnalyzed | abc.markAsAnalyzed;
+		markAsAnalyzed = markAsAnalyzed || abc.markAsAnalyzed;
 		return this;
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/DndTableCellRenderer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/DndTableCellRenderer.java
index 4e8f683111e..149025c37c4 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/DndTableCellRenderer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/compositeeditor/DndTableCellRenderer.java
@@ -185,7 +185,7 @@ public Component getTableCellRendererComponent(JTable myTable, Object value,
 				if (column == 0 && !inserting) {
 					border.addBorders(DndBorder.LEFT);
 				}
-				if (column == myTable.getColumnCount() - 1 & !inserting) {
+				if (column == myTable.getColumnCount() - 1 && !inserting) {
 					border.addBorders(DndBorder.RIGHT);
 				}
 				c.setBorder(border);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/AddressTableAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/AddressTableAnalyzer.java
index 2d0d79a94ef..ad6c6571280 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/AddressTableAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/disassembler/AddressTableAnalyzer.java
@@ -257,7 +257,7 @@ public boolean added(Program program, AddressSetView addrSet, TaskMonitor monito
 
 	private AddressSetView removeNonSearchableMemory(Program program, AddressSetView addrSet) {
 		// get rid of any non-initialized blocks
-		ignoreBookmarks = ignoreBookmarks | addrSet.hasSameAddresses(program.getMemory());
+		ignoreBookmarks = ignoreBookmarks || addrSet.hasSameAddresses(program.getMemory());
 
 		addrSet = addrSet.intersect(program.getMemory().getLoadedAndInitializedAddressSet());
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/GhidraSourceBundle.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/GhidraSourceBundle.java
index 68f8c51ac71..8d92bd0e913 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/GhidraSourceBundle.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/osgi/GhidraSourceBundle.java
@@ -624,7 +624,7 @@ public boolean clean() {
 			if (bundle != null) {
 				bundleHost.deactivateSynchronously(bundle);
 			}
-			return anythingChanged | wipeBinDir();
+			return anythingChanged || wipeBinDir();
 		}
 		catch (IOException | GhidraBundleException e) {
 			Msg.showError(this, null, "Source bundle clean error",
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/overview/OverviewColorComponent.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/overview/OverviewColorComponent.java
index 2130af99e8c..f760af980b8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/overview/OverviewColorComponent.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/overview/OverviewColorComponent.java
@@ -223,7 +223,7 @@ public void refresh(Address start, Address end) {
 		int pixelStart = getPixelIndex(start);
 		int pixelEnd = getPixelIndex(end);
 		for (int i = pixelStart; i <= pixelEnd; i++) {
-			if (i >= 0 & i < colors.length) {
+			if (i >= 0 && i < colors.length) {
 				colors[i] = null;
 			}
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/searchtext/SearchOptions.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/searchtext/SearchOptions.java
index 2b525debff4..cae3ea85f42 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/searchtext/SearchOptions.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/searchtext/SearchOptions.java
@@ -112,7 +112,7 @@ public boolean searchComments() {
 	 * Return true if instruction mnemonics should be searched.
 	 */
 	public boolean searchBothInstructionMnemonicAndOperands() {
-		return instructionMnemonics & instructionOperands;
+		return instructionMnemonics && instructionOperands;
 	}
 
 	public boolean searchInstructionMnemonics() {
@@ -135,7 +135,7 @@ public boolean searchOnlyInstructionOperands() {
 	 * Return true if data mnemonics should be searched.
 	 */
 	public boolean searchBothDataMnemonicsAndOperands() {
-		return dataMnemonics & dataOperands;
+		return dataMnemonics && dataOperands;
 	}
 
 	public boolean searchDataMnemonics() {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
index a00a77a08b0..83fe8404c5e 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
@@ -1300,7 +1300,7 @@ else if (!evaluator.followFalseConditionalBranches()) {
 						val2 = vContext.getValue(in[1], true, evaluator);
 						long subbyte = 8 * vContext.getConstant(val2, evaluator);
 
-						if (vContext.isSymbol(val1) & subbyte == 0 &&
+						if (vContext.isSymbol(val1) && subbyte == 0 &&
 							out.getSize() == instruction.getAddress().getPointerSize()) {
 							// assume the subpiece is just downcasting to be used as a pointer, just ignore, since this is already an offset, and shouldn't matter.
 							result = val1;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/PCodeTestAbstractControlBlock.java b/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/PCodeTestAbstractControlBlock.java
index 9b94fec078d..ae99bb8201b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/PCodeTestAbstractControlBlock.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/PCodeTestAbstractControlBlock.java
@@ -491,8 +491,7 @@ public boolean equals(Object obj) {
 				return false;
 			}
 			FunctionInfo other = (FunctionInfo) obj;
-			return functionName.equals(other.functionName) &
-				functionAddr.equals(other.functionAddr);
+			return functionName.equals(other.functionName) && functionAddr.equals(other.functionAddr);
 		}
 
 		@Override
diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/yaffs2/YAFFS2FileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/yaffs2/YAFFS2FileSystem.java
index bd20a7f35d6..0c5a9729f68 100644
--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/yaffs2/YAFFS2FileSystem.java
+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/yaffs2/YAFFS2FileSystem.java
@@ -130,7 +130,7 @@ private void storeEntry(YAFFS2Entry entry, TaskMonitor monitor) {
 		GFile parentFile = (parentObjectId == 1) ? root : map.get(parentObjectId);
 
 		// skip the first header (always a meaningless, "root" header)
-		if ((objectId == 1) & (parentObjectId == 1)) {
+		if ((objectId == 1) && (parentObjectId == 1)) {
 			return;
 		}
 
diff --git a/Ghidra/Features/FunctionGraph/src/main/java/ghidra/graph/viewer/FGViewUpdater.java b/Ghidra/Features/FunctionGraph/src/main/java/ghidra/graph/viewer/FGViewUpdater.java
index 4493cbe896c..f60dae1796c 100644
--- a/Ghidra/Features/FunctionGraph/src/main/java/ghidra/graph/viewer/FGViewUpdater.java
+++ b/Ghidra/Features/FunctionGraph/src/main/java/ghidra/graph/viewer/FGViewUpdater.java
@@ -447,8 +447,8 @@ private boolean installGroupVertex(FGController controller,
 			GroupedFunctionGraphVertex groupVertex, Point2D groupVertexLocation,
 			boolean relayoutOverride, boolean animate, boolean isRegroup) {
 
-		boolean doAnimate = animate & isAnimationEnabled(); // never animate when the user has disabled it
-		if (groupVertex.getVertices().size() == 0) {
+		boolean doAnimate = animate && isAnimationEnabled(); // never animate when the user has disabled it
+		if (groupVertex.getVertices().isEmpty()) {
 			return false;
 		}
 
diff --git a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/CreateRtti1BackgroundCmd.java b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/CreateRtti1BackgroundCmd.java
index c1fe0996ec9..1670d2020f0 100644
--- a/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/CreateRtti1BackgroundCmd.java
+++ b/Ghidra/Features/MicrosoftCodeAnalyzer/src/main/java/ghidra/app/cmd/data/rtti/CreateRtti1BackgroundCmd.java
@@ -71,7 +71,7 @@ protected Rtti1Model createModel(Program program) {
 	@Override
 	protected boolean createAssociatedData() throws CancelledException {
 
-		return createRtti0() | createRtti3();
+		return createRtti0() || createRtti3();
 	}
 
 	private boolean createRtti0() throws CancelledException {
diff --git a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/functiontype/MDFunctionType.java b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/functiontype/MDFunctionType.java
index 7124e005854..f29bc000a6f 100644
--- a/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/functiontype/MDFunctionType.java
+++ b/Ghidra/Features/MicrosoftDmang/src/main/java/mdemangler/functiontype/MDFunctionType.java
@@ -159,7 +159,7 @@ public void insert(StringBuilder builder) {
 			dmang.insertString(builder, "(");
 			dmang.appendString(builder, ")");
 		}
-		if (hasArgs & argsList != null) {
+		if (hasArgs && argsList != null) {
 			dmang.appendString(builder, "(");
 			argsList.insert(builder);
 			dmang.appendString(builder, ")");
diff --git a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
index 2ee3ade9623..9c658793d0f 100644
--- a/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
+++ b/Ghidra/Features/VersionTracking/src/main/java/ghidra/feature/vt/gui/actions/AutoVersionTrackingTask.java
@@ -222,7 +222,7 @@ private void doRun(TaskMonitor realMonitor) throws CancelledException {
 			options.setDouble(scoreOption, minCombinedReferenceCorrelatorScore);
 
 			monitor.setPrefix(String.format(prefix, "Data Reference", ++count));
-			hasApplyErrors = hasApplyErrors | correlateAndPossiblyApply(factory, options, monitor);
+			hasApplyErrors |= correlateAndPossiblyApply(factory, options, monitor);
 			monitor.doIncrementProgress();
 
 			// Get the number of data and function matches again if this correlator ran
@@ -240,7 +240,7 @@ private void doRun(TaskMonitor realMonitor) throws CancelledException {
 			factory = new FunctionReferenceProgramCorrelatorFactory();
 
 			monitor.setPrefix(String.format(prefix, "Function Reference", ++count));
-			hasApplyErrors = hasApplyErrors | correlateAndPossiblyApply(factory, options, monitor);
+			hasApplyErrors |= correlateAndPossiblyApply(factory, options, monitor);
 			monitor.doIncrementProgress();
 
 			// Get the number of data and function matches again if this correlator ran
@@ -257,7 +257,7 @@ private void doRun(TaskMonitor realMonitor) throws CancelledException {
 			options.setDouble(scoreOption, minCombinedReferenceCorrelatorScore);
 
 			monitor.setPrefix(String.format(prefix, "Function and Data", ++count));
-			hasApplyErrors = hasApplyErrors | correlateAndPossiblyApply(factory, options, monitor);
+			hasApplyErrors |= correlateAndPossiblyApply(factory, options, monitor);
 			monitor.doIncrementProgress();
 		}
 
diff --git a/Ghidra/Framework/DB/src/main/java/db/buffers/BufferMgr.java b/Ghidra/Framework/DB/src/main/java/db/buffers/BufferMgr.java
index aa983954dff..703994b3923 100644
--- a/Ghidra/Framework/DB/src/main/java/db/buffers/BufferMgr.java
+++ b/Ghidra/Framework/DB/src/main/java/db/buffers/BufferMgr.java
@@ -1784,7 +1784,7 @@ public void save(String comment, DBChangeSet changeSet, TaskMonitor monitor)
 					// Monitor not supported for remote saves
 					monitor.setCancelEnabled(false);
 					outFile = ((ManagedBufferFile) sourceFile).getSaveFile();
-					monitor.setCancelEnabled(oldCancelState & !monitor.isCancelled());
+					monitor.setCancelEnabled(oldCancelState && !monitor.isCancelled());
 				}
 				if (outFile == null) {
 					throw new IOException("Save not allowed");
@@ -1816,7 +1816,7 @@ public void save(String comment, DBChangeSet changeSet, TaskMonitor monitor)
 				}
 				finally {
 					((ManagedBufferFile) sourceFile).saveCompleted(success);
-					monitor.setCancelEnabled(oldCancelState & !monitor.isCancelled());
+					monitor.setCancelEnabled(oldCancelState && !monitor.isCancelled());
 				}
 
 				setSourceFile(outFile);
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/options/editor/GhidraColorChooser.java b/Ghidra/Framework/Docking/src/main/java/docking/options/editor/GhidraColorChooser.java
index b892ff29192..9070d7ce25d 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/options/editor/GhidraColorChooser.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/options/editor/GhidraColorChooser.java
@@ -129,7 +129,7 @@ private void maybeInstallSettableColorSwatchChooserPanel() {
 
 		List<Color> mruColorList = recentColorCache.getMRUColorList();
 		AbstractColorChooserPanel[] chooserPanels = getChooserPanels();
-		if (chooserPanels != null & chooserPanels.length > 1) {
+		if (chooserPanels != null && chooserPanels.length > 1) {
 			AbstractColorChooserPanel panel = chooserPanels[0];
 			if (panel instanceof SettableColorSwatchChooserPanel) {
 				// we've already added our panel--reuse
diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/util/exception/VersionException.java b/Ghidra/Framework/Project/src/main/java/ghidra/util/exception/VersionException.java
index 65bfdc8b0f8..d8697c16759 100644
--- a/Ghidra/Framework/Project/src/main/java/ghidra/util/exception/VersionException.java
+++ b/Ghidra/Framework/Project/src/main/java/ghidra/util/exception/VersionException.java
@@ -120,7 +120,7 @@ public VersionException combine(VersionException ve) {
 		if (ve != null) {
 			if (this.versionIndicator != ve.versionIndicator)
 				versionIndicator = UNKNOWN_VERSION;
-			upgradeable = upgradeable & ve.upgradeable;
+			upgradeable = upgradeable && ve.upgradeable;
 			if (detailMessage == null) {
 				detailMessage = ve.detailMessage;
 			}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
index 8fc4721d699..86093924f28 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
@@ -164,10 +164,10 @@ public int compareTo(AssemblyParseMachine that) {
 		if (result != 0) {
 			return result;
 		}
-		if (this.accepted & !that.accepted) {
+		if (this.accepted && !that.accepted) {
 			return 1;
 		}
-		if (!this.accepted & that.accepted) {
+		if (!this.accepted && that.accepted) {
 			return -1;
 		}
 		result = (this.error - that.error);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/core/analysis/ReferenceAddressPair.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/core/analysis/ReferenceAddressPair.java
index 95626e9d3fa..948d577d207 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/core/analysis/ReferenceAddressPair.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/core/analysis/ReferenceAddressPair.java
@@ -54,6 +54,6 @@ public boolean equals(Object obj) {
 			return false;
 		}
 		ReferenceAddressPair otherPair = (ReferenceAddressPair) obj;
-		return source.equals(otherPair.source) & destination.equals(otherPair.destination);
+		return source.equals(otherPair.source) && destination.equals(otherPair.destination);
 	}
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/util/PseudoDisassembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/util/PseudoDisassembler.java
index 286cd918573..723533184ba 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/util/PseudoDisassembler.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/util/PseudoDisassembler.java
@@ -730,7 +730,7 @@ else if (flowType.isJump()) {
 							// if jump target is the same as the fallthru
 							// Instructions with delay slots are allowed.
 							if (fallThru != null &&
-								address.equals(fallThru) & !instr.getPrototype().hasDelaySlots()) {
+                                    address.equals(fallThru) && !instr.getPrototype().hasDelaySlots()) {
 								return false;
 							}
 							// if this code jumps to an existing function, allow it
@@ -835,16 +835,13 @@ private boolean checkNonReturning(Program program, FlowType flowType, PseudoInst
 			if (program != null) {
 				func = program.getFunctionManager().getFunctionAt(flows[0]);
 			}
-		}
-		else {
-			if (flowType.isComputed() & !flowType.isConditional()) {
-				for (int opIndex = 0; opIndex < instr.getNumOperands(); opIndex++) {
-					RefType operandRefType = instr.getOperandRefType(opIndex);
-					if (operandRefType.isIndirect()) {
-						Address addr = instr.getAddress(opIndex);
-						if (addr != null) {
-							func = program.getFunctionManager().getReferencedFunction(addr);
-						}
+		} else if (flowType.isComputed() && !flowType.isConditional()) {
+			for (int opIndex = 0; opIndex < instr.getNumOperands(); opIndex++) {
+				RefType operandRefType = instr.getOperandRefType(opIndex);
+				if (operandRefType.isIndirect()) {
+					Address addr = instr.getAddress(opIndex);
+					if (addr != null) {
+						func = program.getFunctionManager().getReferencedFunction(addr);
 					}
 				}
 			}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/floatformat/FloatFormat.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/floatformat/FloatFormat.java
index f0d2b986876..40ae2c7d112 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/floatformat/FloatFormat.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/floatformat/FloatFormat.java
@@ -751,7 +751,7 @@ public long opNotEqual(long a, long b) { // a != b
 	public BigInteger opNotEqual(BigInteger a, BigInteger b) { // a != b
 		BigFloat fa = getHostFloat(a);
 		BigFloat fb = getHostFloat(b);
-		if (fa.isNaN() | fb.isNaN()) {
+		if (fa.isNaN() || fb.isNaN()) {
 			return BigInteger.ONE;
 		}
 		BigInteger res = SystemUtilities.isEqual(fa, fb) ? BigInteger.ZERO : BigInteger.ONE;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
index b627c1f2fae..483ac8563fb 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/FunctionPrototype.java
@@ -158,7 +158,7 @@ void grabFromFunction(Function f, int overrideExtrapop, boolean doOverride) {
 			(f.getSignatureSource() != SourceType.DEFAULT) && f.getParameterCount() == 0;
 		dotdotdot = f.hasVarArgs();
 		isinline = f.isInline();
-		noreturn = f.hasNoReturn() | isNoReturnInjection(f, injectname);
+		noreturn = f.hasNoReturn() || isNoReturnInjection(f, injectname);
 		custom = f.hasCustomVariableStorage();
 
 		// This assumes that the Purge is the value popped from the excluding normal
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java
index 688c0ca6ecf..83350ecc988 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/util/OldLanguage.java
@@ -327,8 +327,8 @@ private boolean parseBooleanAttribute(Element element, String name, Boolean defa
 			throw new SAXException(
 				"Missing required " + element.getName() + " '" + name + "' attribute");
 		}
-		boolean val = valStr.equalsIgnoreCase("yes") | valStr.equalsIgnoreCase("true");
-		if (!val && !valStr.equalsIgnoreCase("no") & !valStr.equalsIgnoreCase("false")) {
+		boolean val = "yes".equalsIgnoreCase(valStr) || "true".equalsIgnoreCase(valStr);
+		if (!val && !"no".equalsIgnoreCase(valStr) && !"false".equalsIgnoreCase(valStr)) {
 			throw new SAXException(
 				"invalid boolean attribute value " + name + "=\"" + valStr + "\"");
 		}
diff --git a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java
index 49063c56784..2656509afed 100644
--- a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java
+++ b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsAddressAnalyzer.java
@@ -385,7 +385,7 @@ public boolean evaluateReference(VarnodeContext context, Instruction instr, int
 					return false;
 				}
 
-				if ((refType.isJump() || refType.isCall()) & refType.isComputed()) {
+				if ((refType.isJump() || refType.isCall()) && refType.isComputed()) {
 					//if (refType.isJump() || refType.isCall()) {
 					addr = MipsExtDisassembly(program, instr, context, address, monitor);
 					//addr = flowISA(program, instr, context, address);
diff --git a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsPreAnalyzer.java b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsPreAnalyzer.java
index 41f665ed57c..b431221ea81 100644
--- a/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsPreAnalyzer.java
+++ b/Ghidra/Processors/MIPS/src/main/java/ghidra/app/plugin/core/analysis/MipsPreAnalyzer.java
@@ -451,7 +451,7 @@ else if ((str.endsWith("dl") || str.endsWith("dr")) && diff != 7) {
 		}
 
 		// Check base and destination registers
-		if (base1.equals(base2) && (destReg1.equals(destReg2) | destReg2.equals(alternateReg))) {
+		if (base1.equals(base2) && (destReg1.equals(destReg2) || destReg2.equals(alternateReg))) {
 			// Match found
 			return curr_inst;
 		}
