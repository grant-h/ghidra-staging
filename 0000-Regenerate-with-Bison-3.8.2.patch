From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Sun, 11 Dec 2022 14:48:25 +0100
Subject: [PATCH] 0000: Regenerate with Bison 3.8.2

---
 .../Decompiler/certification.manifest         |    9 +
 .../Decompiler/src/decompile/cpp/grammar.cc   | 1509 ++++----
 .../src/decompile/cpp/pcodeparse.cc           | 2081 +++++------
 .../Decompiler/src/decompile/cpp/pcodeparse.y |    9 +
 .../Decompiler/src/decompile/cpp/slghparse.cc | 3267 +++++++----------
 .../Decompiler/src/decompile/cpp/slghparse.hh |  264 +-
 .../Decompiler/src/decompile/cpp/slghscan.cc  |  687 ++--
 .../Decompiler/src/decompile/cpp/xml.cc       | 1372 ++++---
 .../Decompiler/src/decompile/cpp/xml.y        |    9 +
 9 files changed, 3828 insertions(+), 5379 deletions(-)

diff --git a/Ghidra/Features/Decompiler/certification.manifest b/Ghidra/Features/Decompiler/certification.manifest
index da903893e..c55b7627e 100644
--- a/Ghidra/Features/Decompiler/certification.manifest
+++ b/Ghidra/Features/Decompiler/certification.manifest
@@ -12,6 +12,15 @@ src/decompile/.project||GHIDRA||||END|
 src/decompile/cpp/.gitignore||GHIDRA||||END|
 src/decompile/cpp/Doxyfile||GHIDRA|||Most of this file is autogenerated by doxygen which falls under the GPL - output from GPL products are NOT GPL! - mjbell4|END|
 src/decompile/cpp/Makefile||GHIDRA||||END|
+src/decompile/cpp/grammar.cc||GHIDRA||||END|
+src/decompile/cpp/grammar.hh||GHIDRA||||END|
+src/decompile/cpp/pcodeparse.cc||GHIDRA||||END|
+src/decompile/cpp/pcodeparse.hh||GHIDRA||||END|
+src/decompile/cpp/slghparse.cc||GHIDRA||||END|
+src/decompile/cpp/slghparse.hh||GHIDRA||||END|
+src/decompile/cpp/slghscan.cc||GHIDRA||||END|
+src/decompile/cpp/xml.cc||GHIDRA||||END|
+src/decompile/cpp/xml.hh||GHIDRA||||END|
 src/decompile/datatests/convert.xml||GHIDRA||||END|
 src/decompile/datatests/deadvolatile.xml||GHIDRA||||END|
 src/decompile/datatests/deindirect.xml||GHIDRA||||END|
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
index aab637f39..156d48f6e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
@@ -1,23 +1,9 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -48,6 +34,10 @@
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
@@ -55,11 +45,11 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Identify Bison output.  */
-#define YYBISON 1
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30802
 
-/* Bison version.  */
-#define YYBISON_VERSION "3.0.4"
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -74,18 +64,9 @@
 #define YYPULL 1
 
 
-/* Substitute the variable and function names.  */
-#define yyparse         grammarparse
-#define yylex           grammarlex
-#define yyerror         grammarerror
-#define yydebug         grammardebug
-#define yynerrs         grammarnerrs
 
-#define yylval          grammarlval
-#define yychar          grammarchar
 
-/* Copy the first part of user declarations.  */
-#line 16 "src/decompile/cpp/grammar.y" /* yacc.c:339  */
+/* First part of user prologue.  */
 
 #include "grammar.hh"
 
@@ -94,60 +75,85 @@ extern int yyerror(const char *str);
 static CParse *parse;
 extern int yydebug;
 
-#line 83 "src/decompile/cpp/grammar.cc" /* yacc.c:339  */
 
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
 # ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
 #  else
-#   define YY_NULLPTR 0
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
 
 /* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
 #endif
 #if YYDEBUG
-extern int grammardebug;
+extern int yydebug;
 #endif
 
-/* Token type.  */
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
   enum yytokentype
   {
-    DOTDOTDOT = 258,
-    BADTOKEN = 259,
-    STRUCT = 260,
-    UNION = 261,
-    ENUM = 262,
-    DECLARATION_RESULT = 263,
-    PARAM_RESULT = 264,
-    NUMBER = 265,
-    IDENTIFIER = 266,
-    STORAGE_CLASS_SPECIFIER = 267,
-    TYPE_QUALIFIER = 268,
-    FUNCTION_SPECIFIER = 269,
-    TYPE_NAME = 270
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    DOTDOTDOT = 258,               /* DOTDOTDOT  */
+    BADTOKEN = 259,                /* BADTOKEN  */
+    STRUCT = 260,                  /* STRUCT  */
+    UNION = 261,                   /* UNION  */
+    ENUM = 262,                    /* ENUM  */
+    DECLARATION_RESULT = 263,      /* DECLARATION_RESULT  */
+    PARAM_RESULT = 264,            /* PARAM_RESULT  */
+    NUMBER = 265,                  /* NUMBER  */
+    IDENTIFIER = 266,              /* IDENTIFIER  */
+    STORAGE_CLASS_SPECIFIER = 267, /* STORAGE_CLASS_SPECIFIER  */
+    TYPE_QUALIFIER = 268,          /* TYPE_QUALIFIER  */
+    FUNCTION_SPECIFIER = 269,      /* FUNCTION_SPECIFIER  */
+    TYPE_NAME = 270                /* TYPE_NAME  */
   };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define DOTDOTDOT 258
+#define BADTOKEN 259
+#define STRUCT 260
+#define UNION 261
+#define ENUM 262
+#define DECLARATION_RESULT 263
+#define PARAM_RESULT 264
+#define NUMBER 265
+#define IDENTIFIER 266
+#define STORAGE_CLASS_SPECIFIER 267
+#define TYPE_QUALIFIER 268
+#define FUNCTION_SPECIFIER 269
+#define TYPE_NAME 270
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 25 "src/decompile/cpp/grammar.y" /* yacc.c:355  */
 
   uint4 flags;
   TypeDeclarator *dec;
@@ -160,51 +166,168 @@ union YYSTYPE
   string *str;
   uintb *i;
 
-#line 149 "src/decompile/cpp/grammar.cc" /* yacc.c:355  */
-};
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
 #endif
 
 
-extern YYSTYPE grammarlval;
-
-int grammarparse (void);
-
+extern YYSTYPE yylval;
+
+
+int yyparse (void);
+
+
+
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_DOTDOTDOT = 3,                  /* DOTDOTDOT  */
+  YYSYMBOL_BADTOKEN = 4,                   /* BADTOKEN  */
+  YYSYMBOL_STRUCT = 5,                     /* STRUCT  */
+  YYSYMBOL_UNION = 6,                      /* UNION  */
+  YYSYMBOL_ENUM = 7,                       /* ENUM  */
+  YYSYMBOL_DECLARATION_RESULT = 8,         /* DECLARATION_RESULT  */
+  YYSYMBOL_PARAM_RESULT = 9,               /* PARAM_RESULT  */
+  YYSYMBOL_NUMBER = 10,                    /* NUMBER  */
+  YYSYMBOL_IDENTIFIER = 11,                /* IDENTIFIER  */
+  YYSYMBOL_STORAGE_CLASS_SPECIFIER = 12,   /* STORAGE_CLASS_SPECIFIER  */
+  YYSYMBOL_TYPE_QUALIFIER = 13,            /* TYPE_QUALIFIER  */
+  YYSYMBOL_FUNCTION_SPECIFIER = 14,        /* FUNCTION_SPECIFIER  */
+  YYSYMBOL_TYPE_NAME = 15,                 /* TYPE_NAME  */
+  YYSYMBOL_16_ = 16,                       /* ';'  */
+  YYSYMBOL_17_ = 17,                       /* ','  */
+  YYSYMBOL_18_ = 18,                       /* '{'  */
+  YYSYMBOL_19_ = 19,                       /* '}'  */
+  YYSYMBOL_20_ = 20,                       /* '='  */
+  YYSYMBOL_21_ = 21,                       /* '('  */
+  YYSYMBOL_22_ = 22,                       /* ')'  */
+  YYSYMBOL_23_ = 23,                       /* '['  */
+  YYSYMBOL_24_ = 24,                       /* ']'  */
+  YYSYMBOL_25_ = 25,                       /* '*'  */
+  YYSYMBOL_YYACCEPT = 26,                  /* $accept  */
+  YYSYMBOL_document = 27,                  /* document  */
+  YYSYMBOL_declaration = 28,               /* declaration  */
+  YYSYMBOL_declaration_specifiers = 29,    /* declaration_specifiers  */
+  YYSYMBOL_init_declarator_list = 30,      /* init_declarator_list  */
+  YYSYMBOL_init_declarator = 31,           /* init_declarator  */
+  YYSYMBOL_type_specifier = 32,            /* type_specifier  */
+  YYSYMBOL_struct_or_union_specifier = 33, /* struct_or_union_specifier  */
+  YYSYMBOL_struct_declaration_list = 34,   /* struct_declaration_list  */
+  YYSYMBOL_struct_declaration = 35,        /* struct_declaration  */
+  YYSYMBOL_specifier_qualifier_list = 36,  /* specifier_qualifier_list  */
+  YYSYMBOL_struct_declarator_list = 37,    /* struct_declarator_list  */
+  YYSYMBOL_struct_declarator = 38,         /* struct_declarator  */
+  YYSYMBOL_enum_specifier = 39,            /* enum_specifier  */
+  YYSYMBOL_enumerator_list = 40,           /* enumerator_list  */
+  YYSYMBOL_enumerator = 41,                /* enumerator  */
+  YYSYMBOL_declarator = 42,                /* declarator  */
+  YYSYMBOL_direct_declarator = 43,         /* direct_declarator  */
+  YYSYMBOL_pointer = 44,                   /* pointer  */
+  YYSYMBOL_type_qualifier_list = 45,       /* type_qualifier_list  */
+  YYSYMBOL_parameter_type_list = 46,       /* parameter_type_list  */
+  YYSYMBOL_parameter_list = 47,            /* parameter_list  */
+  YYSYMBOL_parameter_declaration = 48,     /* parameter_declaration  */
+  YYSYMBOL_abstract_declarator = 49,       /* abstract_declarator  */
+  YYSYMBOL_direct_abstract_declarator = 50, /* direct_abstract_declarator  */
+  YYSYMBOL_assignment_expression = 51      /* assignment_expression  */
+};
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
 
-/* Copy the second part of user declarations.  */
 
-#line 166 "src/decompile/cpp/grammar.cc" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
 #endif
 
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
 #else
 typedef signed char yytype_int8;
 #endif
 
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
 #else
-typedef unsigned short int yytype_uint16;
+typedef short yytype_int16;
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
+#endif
+
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
+#else
+typedef short yytype_uint8;
+#endif
+
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
 #else
-typedef short int yytype_int16;
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
 #endif
 
 #ifndef YYSIZE_T
@@ -212,15 +335,28 @@ typedef short int yytype_int16;
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
-#  define YYSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_int8 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
 #ifndef YY_
 # if defined YYENABLE_NLS && YYENABLE_NLS
@@ -234,47 +370,43 @@ typedef short int yytype_int16;
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
 
 #ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
 #endif
 
 #ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
+# define YY_USE(E) ((void) (E))
 #else
-# define YYUSE(E) /* empty */
+# define YY_USE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
 /* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
 # define YY_INITIAL_VALUE(Value) Value
@@ -287,8 +419,22 @@ typedef short int yytype_int16;
 # define YY_INITIAL_VALUE(Value) /* Nothing. */
 #endif
 
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
 
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -353,8 +499,7 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
@@ -363,17 +508,17 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
+  yy_state_t yyss_alloc;
   YYSTYPE yyvs_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 # define YYCOPY_NEEDED 1
@@ -386,11 +531,11 @@ union yyalloc
 # define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
+        YYPTRDIFF_T yynewbytes;                                         \
         YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
         Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
@@ -402,12 +547,12 @@ union yyalloc
 # ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
 #   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          YYSIZE_T yyi;                         \
+          YYPTRDIFF_T yyi;                      \
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
@@ -430,17 +575,20 @@ union yyalloc
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  115
 
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
-#define YYUNDEFTOK  2
+/* YYMAXUTOK -- Last valid token kind.  */
 #define YYMAXUTOK   270
 
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
-static const yytype_uint8 yytranslate[] =
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -473,7 +621,7 @@ static const yytype_uint8 yytranslate[] =
 };
 
 #if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint8 yyrline[] =
 {
        0,    60,    60,    61,    65,    66,    70,    71,    72,    73,
@@ -487,50 +635,53 @@ static const yytype_uint8 yyrline[] =
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 0
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "DOTDOTDOT", "BADTOKEN", "STRUCT",
-  "UNION", "ENUM", "DECLARATION_RESULT", "PARAM_RESULT", "NUMBER",
-  "IDENTIFIER", "STORAGE_CLASS_SPECIFIER", "TYPE_QUALIFIER",
-  "FUNCTION_SPECIFIER", "TYPE_NAME", "';'", "','", "'{'", "'}'", "'='",
-  "'('", "')'", "'['", "']'", "'*'", "$accept", "document", "declaration",
-  "declaration_specifiers", "init_declarator_list", "init_declarator",
-  "type_specifier", "struct_or_union_specifier", "struct_declaration_list",
-  "struct_declaration", "specifier_qualifier_list",
-  "struct_declarator_list", "struct_declarator", "enum_specifier",
-  "enumerator_list", "enumerator", "declarator", "direct_declarator",
-  "pointer", "type_qualifier_list", "parameter_type_list",
-  "parameter_list", "parameter_declaration", "abstract_declarator",
-  "direct_abstract_declarator", "assignment_expression", YY_NULLPTR
+  "\"end of file\"", "error", "\"invalid token\"", "DOTDOTDOT",
+  "BADTOKEN", "STRUCT", "UNION", "ENUM", "DECLARATION_RESULT",
+  "PARAM_RESULT", "NUMBER", "IDENTIFIER", "STORAGE_CLASS_SPECIFIER",
+  "TYPE_QUALIFIER", "FUNCTION_SPECIFIER", "TYPE_NAME", "';'", "','", "'{'",
+  "'}'", "'='", "'('", "')'", "'['", "']'", "'*'", "$accept", "document",
+  "declaration", "declaration_specifiers", "init_declarator_list",
+  "init_declarator", "type_specifier", "struct_or_union_specifier",
+  "struct_declaration_list", "struct_declaration",
+  "specifier_qualifier_list", "struct_declarator_list",
+  "struct_declarator", "enum_specifier", "enumerator_list", "enumerator",
+  "declarator", "direct_declarator", "pointer", "type_qualifier_list",
+  "parameter_type_list", "parameter_list", "parameter_declaration",
+  "abstract_declarator", "direct_abstract_declarator",
+  "assignment_expression", YY_NULLPTR
 };
-#endif
 
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
 {
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,    59,    44,   123,   125,
-      61,    40,    41,    91,    93,    42
-};
-# endif
+  return yytname[yysymbol];
+}
+#endif
 
-#define YYPACT_NINF -71
+#define YYPACT_NINF (-71)
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-71)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define YYTABLE_NINF -1
+#define YYTABLE_NINF (-1)
 
-#define yytable_value_is_error(Yytable_value) \
+#define yytable_value_is_error(Yyn) \
   0
 
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
      114,   102,   102,    16,    41,    59,   108,   102,   102,   102,
@@ -547,10 +698,10 @@ static const yytype_int16 yypact[] =
      -71,   -71,   -71,   -71,   -71
 };
 
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint8 yydefact[] =
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_int8 yydefact[] =
 {
        0,     0,     0,     0,     0,     0,     0,     6,     8,     9,
       17,     2,     0,     7,    18,    19,    63,     3,     1,    22,
@@ -566,7 +717,7 @@ static const yytype_uint8 yydefact[] =
       34,    38,    59,    61,    49
 };
 
-  /* YYPGOTO[NTERM-NUM].  */
+/* YYPGOTO[NTERM-NUM].  */
 static const yytype_int8 yypgoto[] =
 {
      -71,   -71,   -71,    93,   -71,    82,    -1,   -71,   -11,   -37,
@@ -574,18 +725,18 @@ static const yytype_int8 yypgoto[] =
       84,   -71,     0,   113,   115,   -62
 };
 
-  /* YYDEFGOTO[NTERM-NUM].  */
+/* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int8 yydefgoto[] =
 {
-      -1,     3,    11,    16,    32,    33,    45,    14,    46,    47,
+       0,     3,    11,    16,    32,    33,    45,    14,    46,    47,
       48,    73,    74,    15,    53,    54,    34,    35,    36,    58,
       86,    87,    88,    41,    42,    91
 };
 
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
-static const yytype_uint8 yytable[] =
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
 {
       13,    13,    17,    39,    40,    94,    13,    13,    13,    72,
      103,    50,    13,    72,    52,    56,    18,    55,    89,    57,
@@ -625,9 +776,9 @@ static const yytype_int8 yycheck[] =
       66,    38,    -1,    -1,    -1,    40
 };
 
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
+static const yytype_int8 yystos[] =
 {
        0,     8,     9,    27,     5,     6,     7,    12,    13,    14,
       15,    28,    29,    32,    33,    39,    29,    48,     0,    11,
@@ -643,8 +794,8 @@ static const yytype_uint8 yystos[] =
       38,    19,     3,    48,    24
 };
 
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr1[] =
 {
        0,    26,    27,    27,    28,    28,    29,    29,    29,    29,
       29,    29,    29,    29,    30,    30,    31,    32,    32,    32,
@@ -656,8 +807,8 @@ static const yytype_uint8 yyr1[] =
       50,    51
 };
 
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
 {
        0,     2,     2,     2,     2,     3,     1,     1,     1,     1,
        2,     2,     2,     2,     1,     3,     1,     1,     1,     1,
@@ -670,39 +821,39 @@ static const yytype_uint8 yyr2[] =
 };
 
 
+enum { YYENOMEM = -2 };
+
 #define yyerrok         (yyerrstatus = 0)
 #define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
 
 #define YYACCEPT        goto yyacceptlab
 #define YYABORT         goto yyabortlab
 #define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
 
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
 
 
 /* Enable debugging if requested.  */
@@ -719,55 +870,52 @@ do {                                            \
     YYFPRINTF Args;                             \
 } while (0)
 
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
 
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
   if (yydebug)                                                            \
     {                                                                     \
       YYFPRINTF (stderr, "%s ", Title);                                   \
       yy_symbol_print (stderr,                                            \
-                  Type, Value); \
+                  Kind, Value); \
       YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
   if (!yyvaluep)
     return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  YYFPRINTF (yyoutput, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
+  yy_symbol_value_print (yyo, yykind, yyvaluep);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
@@ -776,7 +924,7 @@ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
 `------------------------------------------------------------------*/
 
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -799,21 +947,21 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule)
 {
-  unsigned long int yylno = yyrline[yyrule];
+  int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
              yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
-                                              );
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)]);
       YYFPRINTF (stderr, "\n");
     }
 }
@@ -828,8 +976,8 @@ do {                                    \
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -852,249 +1000,30 @@ int yydebug;
 #endif
 
 
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
 
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
 
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
 {
-  YYUSE (yyvaluep);
+  YY_USE (yyvaluep);
   if (!yymsg)
     yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
+  YY_USE (yykind);
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-
-
-/* The lookahead symbol.  */
+/* Lookahead token kind.  */
 int yychar;
 
 /* The semantic value of the lookahead symbol.  */
@@ -1103,6 +1032,8 @@ YYSTYPE yylval;
 int yynerrs;
 
 
+
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1110,43 +1041,36 @@ int yynerrs;
 int
 yyparse (void)
 {
-    int yystate;
+    yy_state_fast_t yystate = 0;
     /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
+    int yyerrstatus = 0;
 
-       Refer to the stacks through separate pointers, to allow yyoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-    YYSIZE_T yystacksize;
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
   int yyn;
+  /* The return value of yyparse.  */
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
@@ -1154,71 +1078,75 @@ yyparse (void)
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
+
   goto yysetstate;
 
+
 /*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- yynewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
- yysetstate:
-  *yyssp = yystate;
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
 
   if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef yyoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
+        yy_state_t *yyss1 = yyss;
         YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
 
         /* Each stack pointer address is followed by the size of the
            data in use in that stack, in bytes.  This used to be a
            conditional around just the two extra args, but that might
            be undefined if yyoverflow is a macro.  */
         yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                     &yystacksize);
-
         yyss = yyss1;
         yyvs = yyvs1;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
+        YYNOMEM;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
 
       {
-        yytype_int16 *yyss1 = yyss;
+        yy_state_t *yyss1 = yyss;
         union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
         if (! yyptr)
-          goto yyexhaustedlab;
+          YYNOMEM;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
@@ -1226,30 +1154,31 @@ yyparse (void)
           YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no yyoverflow */
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
+
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
-
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
@@ -1260,18 +1189,29 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF ((stderr, "Reading a token\n"));
       yychar = yylex ();
     }
 
   if (yychar <= YYEOF)
     {
-      yychar = yytoken = YYEOF;
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
+    }
   else
     {
       yytoken = YYTRANSLATE (yychar);
@@ -1299,15 +1239,13 @@ yybackup:
 
   /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
 
@@ -1322,7 +1260,7 @@ yydefault:
 
 
 /*-----------------------------.
-| yyreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
@@ -1342,428 +1280,288 @@ yyreduce:
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-        case 2:
-#line 60 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { parse->setResultDeclarations((yyvsp[0].declist)); }
-#line 1334 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 2: /* document: DECLARATION_RESULT declaration  */
+                                 { parse->setResultDeclarations((yyvsp[0].declist)); }
     break;
 
-  case 3:
-#line 61 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { vector<TypeDeclarator *> *res = parse->newVecDeclarator(); res->push_back((yyvsp[0].dec)); parse->setResultDeclarations(res); }
-#line 1340 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 3: /* document: PARAM_RESULT parameter_declaration  */
+                                     { vector<TypeDeclarator *> *res = parse->newVecDeclarator(); res->push_back((yyvsp[0].dec)); parse->setResultDeclarations(res); }
     break;
 
-  case 4:
-#line 65 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-1].spec)); }
-#line 1346 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 4: /* declaration: declaration_specifiers ';'  */
+                             { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-1].spec)); }
     break;
 
-  case 5:
-#line 66 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-2].spec),(yyvsp[-1].declist)); }
-#line 1352 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 5: /* declaration: declaration_specifiers init_declarator_list ';'  */
+                                                    { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-2].spec),(yyvsp[-1].declist)); }
     break;
 
-  case 6:
-#line 70 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
-#line 1358 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 6: /* declaration_specifiers: STORAGE_CLASS_SPECIFIER  */
+                          { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
     break;
 
-  case 7:
-#line 71 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addTypeSpecifier((yyval.spec),(yyvsp[0].type)); }
-#line 1364 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 7: /* declaration_specifiers: type_specifier  */
+                   { (yyval.spec) = parse->newSpecifier(); parse->addTypeSpecifier((yyval.spec),(yyvsp[0].type)); }
     break;
 
-  case 8:
-#line 72 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
-#line 1370 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 8: /* declaration_specifiers: TYPE_QUALIFIER  */
+                   { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
     break;
 
-  case 9:
-#line 73 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addFuncSpecifier((yyval.spec),(yyvsp[0].str)); }
-#line 1376 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 9: /* declaration_specifiers: FUNCTION_SPECIFIER  */
+                       { (yyval.spec) = parse->newSpecifier(); parse->addFuncSpecifier((yyval.spec),(yyvsp[0].str)); }
     break;
 
-  case 10:
-#line 74 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
-#line 1382 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 10: /* declaration_specifiers: STORAGE_CLASS_SPECIFIER declaration_specifiers  */
+                                                   { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
     break;
 
-  case 11:
-#line 75 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addTypeSpecifier((yyvsp[0].spec),(yyvsp[-1].type)); }
-#line 1388 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 11: /* declaration_specifiers: type_specifier declaration_specifiers  */
+                                          { (yyval.spec) = parse->addTypeSpecifier((yyvsp[0].spec),(yyvsp[-1].type)); }
     break;
 
-  case 12:
-#line 76 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
-#line 1394 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 12: /* declaration_specifiers: TYPE_QUALIFIER declaration_specifiers  */
+                                          { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
     break;
 
-  case 13:
-#line 77 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addFuncSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
-#line 1400 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 13: /* declaration_specifiers: FUNCTION_SPECIFIER declaration_specifiers  */
+                                              { (yyval.spec) = parse->addFuncSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
     break;
 
-  case 14:
-#line 81 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1406 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 14: /* init_declarator_list: init_declarator  */
+                  { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 15:
-#line 82 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1412 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 15: /* init_declarator_list: init_declarator_list ',' init_declarator  */
+                                             { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 16:
-#line 86 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[0].dec); }
-#line 1418 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 16: /* init_declarator: declarator  */
+             { (yyval.dec) = (yyvsp[0].dec); }
     break;
 
-  case 17:
-#line 91 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = (yyvsp[0].type); }
-#line 1424 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 17: /* type_specifier: TYPE_NAME  */
+            { (yyval.type) = (yyvsp[0].type); }
     break;
 
-  case 18:
-#line 92 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = (yyvsp[0].type); }
-#line 1430 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 18: /* type_specifier: struct_or_union_specifier  */
+                              { (yyval.type) = (yyvsp[0].type); }
     break;
 
-  case 19:
-#line 93 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = (yyvsp[0].type); }
-#line 1436 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 19: /* type_specifier: enum_specifier  */
+                   { (yyval.type) = (yyvsp[0].type); }
     break;
 
-  case 20:
-#line 97 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newStruct("",(yyvsp[-1].declist)); }
-#line 1442 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 20: /* struct_or_union_specifier: STRUCT '{' struct_declaration_list '}'  */
+                                         { (yyval.type) = parse->newStruct("",(yyvsp[-1].declist)); }
     break;
 
-  case 21:
-#line 98 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newStruct(*(yyvsp[-3].str),(yyvsp[-1].declist)); }
-#line 1448 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 21: /* struct_or_union_specifier: STRUCT IDENTIFIER '{' struct_declaration_list '}'  */
+                                                      { (yyval.type) = parse->newStruct(*(yyvsp[-3].str),(yyvsp[-1].declist)); }
     break;
 
-  case 22:
-#line 99 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->oldStruct(*(yyvsp[0].str)); }
-#line 1454 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 22: /* struct_or_union_specifier: STRUCT IDENTIFIER  */
+                      { (yyval.type) = parse->oldStruct(*(yyvsp[0].str)); }
     break;
 
-  case 23:
-#line 100 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newUnion("",(yyvsp[-1].declist)); }
-#line 1460 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 23: /* struct_or_union_specifier: UNION '{' struct_declaration_list '}'  */
+                                          { (yyval.type) = parse->newUnion("",(yyvsp[-1].declist)); }
     break;
 
-  case 24:
-#line 101 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newUnion(*(yyvsp[-3].str),(yyvsp[-1].declist)); }
-#line 1466 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 24: /* struct_or_union_specifier: UNION IDENTIFIER '{' struct_declaration_list '}'  */
+                                                     { (yyval.type) = parse->newUnion(*(yyvsp[-3].str),(yyvsp[-1].declist)); }
     break;
 
-  case 25:
-#line 102 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->oldUnion(*(yyvsp[0].str)); }
-#line 1472 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 25: /* struct_or_union_specifier: UNION IDENTIFIER  */
+                     { (yyval.type) = parse->oldUnion(*(yyvsp[0].str)); }
     break;
 
-  case 26:
-#line 106 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[0].declist); }
-#line 1478 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 26: /* struct_declaration_list: struct_declaration  */
+                     { (yyval.declist) = (yyvsp[0].declist); }
     break;
 
-  case 27:
-#line 107 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[-1].declist); (yyval.declist)->insert((yyval.declist)->end(),(yyvsp[0].declist)->begin(),(yyvsp[0].declist)->end()); }
-#line 1484 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 27: /* struct_declaration_list: struct_declaration_list struct_declaration  */
+                                               { (yyval.declist) = (yyvsp[-1].declist); (yyval.declist)->insert((yyval.declist)->end(),(yyvsp[0].declist)->begin(),(yyvsp[0].declist)->end()); }
     break;
 
-  case 28:
-#line 111 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-2].spec),(yyvsp[-1].declist)); }
-#line 1490 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 28: /* struct_declaration: specifier_qualifier_list struct_declarator_list ';'  */
+                                                      { (yyval.declist) = parse->mergeSpecDecVec((yyvsp[-2].spec),(yyvsp[-1].declist)); }
     break;
 
-  case 29:
-#line 115 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addTypeSpecifier((yyval.spec),(yyvsp[0].type)); }
-#line 1496 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 29: /* specifier_qualifier_list: type_specifier  */
+                 { (yyval.spec) = parse->newSpecifier(); parse->addTypeSpecifier((yyval.spec),(yyvsp[0].type)); }
     break;
 
-  case 30:
-#line 116 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addTypeSpecifier((yyvsp[0].spec),(yyvsp[-1].type)); }
-#line 1502 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 30: /* specifier_qualifier_list: type_specifier specifier_qualifier_list  */
+                                            { (yyval.spec) = parse->addTypeSpecifier((yyvsp[0].spec),(yyvsp[-1].type)); }
     break;
 
-  case 31:
-#line 117 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
-#line 1508 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 31: /* specifier_qualifier_list: TYPE_QUALIFIER  */
+                   { (yyval.spec) = parse->newSpecifier(); parse->addSpecifier((yyval.spec),(yyvsp[0].str)); }
     break;
 
-  case 32:
-#line 118 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
-#line 1514 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 32: /* specifier_qualifier_list: TYPE_QUALIFIER specifier_qualifier_list  */
+                                            { (yyval.spec) = parse->addSpecifier((yyvsp[0].spec),(yyvsp[-1].str)); }
     break;
 
-  case 33:
-#line 122 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1520 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 33: /* struct_declarator_list: struct_declarator  */
+                    { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 34:
-#line 123 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1526 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 34: /* struct_declarator_list: struct_declarator_list ',' struct_declarator  */
+                                                 { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 35:
-#line 127 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[0].dec); }
-#line 1532 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 35: /* struct_declarator: declarator  */
+             { (yyval.dec) = (yyvsp[0].dec); }
     break;
 
-  case 36:
-#line 132 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newEnum(*(yyvsp[-3].str),(yyvsp[-1].vecenum)); }
-#line 1538 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 36: /* enum_specifier: ENUM IDENTIFIER '{' enumerator_list '}'  */
+                                          { (yyval.type) = parse->newEnum(*(yyvsp[-3].str),(yyvsp[-1].vecenum)); }
     break;
 
-  case 37:
-#line 133 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newEnum("",(yyvsp[-1].vecenum)); }
-#line 1544 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 37: /* enum_specifier: ENUM '{' enumerator_list '}'  */
+                                 { (yyval.type) = parse->newEnum("",(yyvsp[-1].vecenum)); }
     break;
 
-  case 38:
-#line 134 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newEnum(*(yyvsp[-4].str),(yyvsp[-2].vecenum)); }
-#line 1550 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 38: /* enum_specifier: ENUM IDENTIFIER '{' enumerator_list ',' '}'  */
+                                                { (yyval.type) = parse->newEnum(*(yyvsp[-4].str),(yyvsp[-2].vecenum)); }
     break;
 
-  case 39:
-#line 135 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->newEnum("",(yyvsp[-2].vecenum)); }
-#line 1556 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 39: /* enum_specifier: ENUM '{' enumerator_list ',' '}'  */
+                                     { (yyval.type) = parse->newEnum("",(yyvsp[-2].vecenum)); }
     break;
 
-  case 40:
-#line 136 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.type) = parse->oldEnum(*(yyvsp[0].str)); }
-#line 1562 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 40: /* enum_specifier: ENUM IDENTIFIER  */
+                    { (yyval.type) = parse->oldEnum(*(yyvsp[0].str)); }
     break;
 
-  case 41:
-#line 140 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.vecenum) = parse->newVecEnumerator(); (yyval.vecenum)->push_back((yyvsp[0].enumer)); }
-#line 1568 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 41: /* enumerator_list: enumerator  */
+             { (yyval.vecenum) = parse->newVecEnumerator(); (yyval.vecenum)->push_back((yyvsp[0].enumer)); }
     break;
 
-  case 42:
-#line 141 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.vecenum) = (yyvsp[-2].vecenum); (yyval.vecenum)->push_back((yyvsp[0].enumer)); }
-#line 1574 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 42: /* enumerator_list: enumerator_list ',' enumerator  */
+                                   { (yyval.vecenum) = (yyvsp[-2].vecenum); (yyval.vecenum)->push_back((yyvsp[0].enumer)); }
     break;
 
-  case 43:
-#line 145 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.enumer) = parse->newEnumerator(*(yyvsp[0].str)); }
-#line 1580 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 43: /* enumerator: IDENTIFIER  */
+             { (yyval.enumer) = parse->newEnumerator(*(yyvsp[0].str)); }
     break;
 
-  case 44:
-#line 146 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.enumer) = parse->newEnumerator(*(yyvsp[-2].str),*(yyvsp[0].i)); }
-#line 1586 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 44: /* enumerator: IDENTIFIER '=' NUMBER  */
+                          { (yyval.enumer) = parse->newEnumerator(*(yyvsp[-2].str),*(yyvsp[0].i)); }
     break;
 
-  case 45:
-#line 150 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[0].dec); }
-#line 1592 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 45: /* declarator: direct_declarator  */
+                    { (yyval.dec) = (yyvsp[0].dec); }
     break;
 
-  case 46:
-#line 151 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->mergePointer((yyvsp[-1].ptrspec),(yyvsp[0].dec)); }
-#line 1598 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 46: /* declarator: pointer direct_declarator  */
+                              { (yyval.dec) = parse->mergePointer((yyvsp[-1].ptrspec),(yyvsp[0].dec)); }
     break;
 
-  case 47:
-#line 155 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newDeclarator((yyvsp[0].str)); }
-#line 1604 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 47: /* direct_declarator: IDENTIFIER  */
+             { (yyval.dec) = parse->newDeclarator((yyvsp[0].str)); }
     break;
 
-  case 48:
-#line 156 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[-1].dec); }
-#line 1610 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 48: /* direct_declarator: '(' declarator ')'  */
+                       { (yyval.dec) = (yyvsp[-1].dec); }
     break;
 
-  case 49:
-#line 157 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newArray((yyvsp[-4].dec),(yyvsp[-2].flags),(yyvsp[-1].i)); }
-#line 1616 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 49: /* direct_declarator: direct_declarator '[' type_qualifier_list assignment_expression ']'  */
+                                                                        { (yyval.dec) = parse->newArray((yyvsp[-4].dec),(yyvsp[-2].flags),(yyvsp[-1].i)); }
     break;
 
-  case 50:
-#line 158 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newArray((yyvsp[-3].dec),0,(yyvsp[-1].i)); }
-#line 1622 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 50: /* direct_declarator: direct_declarator '[' assignment_expression ']'  */
+                                                    { (yyval.dec) = parse->newArray((yyvsp[-3].dec),0,(yyvsp[-1].i)); }
     break;
 
-  case 51:
-#line 160 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newFunc((yyvsp[-3].dec),(yyvsp[-1].declist)); }
-#line 1628 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 51: /* direct_declarator: direct_declarator '(' parameter_type_list ')'  */
+                                                  { (yyval.dec) = parse->newFunc((yyvsp[-3].dec),(yyvsp[-1].declist)); }
     break;
 
-  case 52:
-#line 165 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.ptrspec) = parse->newPointer(); (yyval.ptrspec)->push_back(0); }
-#line 1634 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 52: /* pointer: '*'  */
+      { (yyval.ptrspec) = parse->newPointer(); (yyval.ptrspec)->push_back(0); }
     break;
 
-  case 53:
-#line 166 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.ptrspec) = parse->newPointer(); (yyval.ptrspec)->push_back((yyvsp[0].flags)); }
-#line 1640 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 53: /* pointer: '*' type_qualifier_list  */
+                            { (yyval.ptrspec) = parse->newPointer(); (yyval.ptrspec)->push_back((yyvsp[0].flags)); }
     break;
 
-  case 54:
-#line 167 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.ptrspec) = (yyvsp[0].ptrspec); (yyval.ptrspec)->push_back(0); }
-#line 1646 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 54: /* pointer: '*' pointer  */
+                { (yyval.ptrspec) = (yyvsp[0].ptrspec); (yyval.ptrspec)->push_back(0); }
     break;
 
-  case 55:
-#line 168 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.ptrspec) = (yyvsp[0].ptrspec); (yyval.ptrspec)->push_back((yyvsp[-1].flags)); }
-#line 1652 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 55: /* pointer: '*' type_qualifier_list pointer  */
+                                    { (yyval.ptrspec) = (yyvsp[0].ptrspec); (yyval.ptrspec)->push_back((yyvsp[-1].flags)); }
     break;
 
-  case 56:
-#line 172 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.flags) = parse->convertFlag((yyvsp[0].str)); }
-#line 1658 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 56: /* type_qualifier_list: TYPE_QUALIFIER  */
+                 { (yyval.flags) = parse->convertFlag((yyvsp[0].str)); }
     break;
 
-  case 57:
-#line 173 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.flags) = (yyvsp[-1].flags); (yyval.flags) |= parse->convertFlag((yyvsp[0].str)); }
-#line 1664 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 57: /* type_qualifier_list: type_qualifier_list TYPE_QUALIFIER  */
+                                       { (yyval.flags) = (yyvsp[-1].flags); (yyval.flags) |= parse->convertFlag((yyvsp[0].str)); }
     break;
 
-  case 58:
-#line 177 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[0].declist); }
-#line 1670 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 58: /* parameter_type_list: parameter_list  */
+                 { (yyval.declist) = (yyvsp[0].declist); }
     break;
 
-  case 59:
-#line 178 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((TypeDeclarator *)0); }
-#line 1676 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 59: /* parameter_type_list: parameter_list ',' DOTDOTDOT  */
+                                 { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((TypeDeclarator *)0); }
     break;
 
-  case 60:
-#line 182 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1682 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 60: /* parameter_list: parameter_declaration  */
+                        { (yyval.declist) = parse->newVecDeclarator(); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 61:
-#line 183 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
-#line 1688 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 61: /* parameter_list: parameter_list ',' parameter_declaration  */
+                                             { (yyval.declist) = (yyvsp[-2].declist); (yyval.declist)->push_back((yyvsp[0].dec)); }
     break;
 
-  case 62:
-#line 187 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->mergeSpecDec((yyvsp[-1].spec),(yyvsp[0].dec)); }
-#line 1694 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 62: /* parameter_declaration: declaration_specifiers declarator  */
+                                    { (yyval.dec) = parse->mergeSpecDec((yyvsp[-1].spec),(yyvsp[0].dec)); }
     break;
 
-  case 63:
-#line 188 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->mergeSpecDec((yyvsp[0].spec)); }
-#line 1700 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 63: /* parameter_declaration: declaration_specifiers  */
+                           { (yyval.dec) = parse->mergeSpecDec((yyvsp[0].spec)); }
     break;
 
-  case 64:
-#line 189 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->mergeSpecDec((yyvsp[-1].spec),(yyvsp[0].dec)); }
-#line 1706 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 64: /* parameter_declaration: declaration_specifiers abstract_declarator  */
+                                               { (yyval.dec) = parse->mergeSpecDec((yyvsp[-1].spec),(yyvsp[0].dec)); }
     break;
 
-  case 65:
-#line 193 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newDeclarator(); parse->mergePointer((yyvsp[0].ptrspec),(yyval.dec)); }
-#line 1712 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 65: /* abstract_declarator: pointer  */
+          { (yyval.dec) = parse->newDeclarator(); parse->mergePointer((yyvsp[0].ptrspec),(yyval.dec)); }
     break;
 
-  case 66:
-#line 194 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[0].dec); }
-#line 1718 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 66: /* abstract_declarator: direct_abstract_declarator  */
+                               { (yyval.dec) = (yyvsp[0].dec); }
     break;
 
-  case 67:
-#line 195 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->mergePointer((yyvsp[-1].ptrspec),(yyvsp[0].dec)); }
-#line 1724 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 67: /* abstract_declarator: pointer direct_abstract_declarator  */
+                                       { (yyval.dec) = parse->mergePointer((yyvsp[-1].ptrspec),(yyvsp[0].dec)); }
     break;
 
-  case 68:
-#line 199 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = (yyvsp[-1].dec); }
-#line 1730 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 68: /* direct_abstract_declarator: '(' abstract_declarator ')'  */
+                              { (yyval.dec) = (yyvsp[-1].dec); }
     break;
 
-  case 69:
-#line 201 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newArray((yyvsp[-3].dec),0,(yyvsp[-1].i)); }
-#line 1736 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 69: /* direct_abstract_declarator: direct_abstract_declarator '[' assignment_expression ']'  */
+                                                             { (yyval.dec) = parse->newArray((yyvsp[-3].dec),0,(yyvsp[-1].i)); }
     break;
 
-  case 70:
-#line 203 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.dec) = parse->newFunc((yyvsp[-3].dec),(yyvsp[-1].declist)); }
-#line 1742 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 70: /* direct_abstract_declarator: direct_abstract_declarator '(' parameter_type_list ')'  */
+                                                           { (yyval.dec) = parse->newFunc((yyvsp[-3].dec),(yyvsp[-1].declist)); }
     break;
 
-  case 71:
-#line 207 "src/decompile/cpp/grammar.y" /* yacc.c:1646  */
-    { (yyval.i) = (yyvsp[0].i); }
-#line 1748 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+  case 71: /* assignment_expression: NUMBER  */
+         { (yyval.i) = (yyvsp[0].i); }
     break;
 
 
-#line 1752 "src/decompile/cpp/grammar.cc" /* yacc.c:1646  */
+
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -1777,25 +1575,23 @@ yyreduce:
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
@@ -1806,50 +1602,14 @@ yyreduce:
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
     }
 
-
-
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -1878,12 +1638,11 @@ yyerrlab:
 | yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
 yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
 
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
@@ -1900,13 +1659,14 @@ yyerrorlab:
 yyerrlab1:
   yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
@@ -1920,7 +1680,7 @@ yyerrlab1:
 
 
       yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp);
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -1932,7 +1692,7 @@ yyerrlab1:
 
 
   /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -1943,26 +1703,30 @@ yyerrlab1:
 `-------------------------------------*/
 yyacceptlab:
   yyresult = 0;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
 /*-----------------------------------.
 | yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
 yyabortlab:
   yyresult = 1;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
 yyexhaustedlab:
   yyerror (YY_("memory exhausted"));
   yyresult = 2;
-  /* Fall through.  */
-#endif
+  goto yyreturnlab;
+
 
-yyreturn:
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
   if (yychar != YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
@@ -1978,20 +1742,17 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp);
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
+
   return yyresult;
 }
-#line 210 "src/decompile/cpp/grammar.y" /* yacc.c:1906  */
+
 
 
 void GrammarToken::set(uint4 tp)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
index c562c0f83..ed08071c8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
@@ -1,23 +1,9 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -48,6 +34,10 @@
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
@@ -55,11 +45,11 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Identify Bison output.  */
-#define YYBISON 1
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30802
 
-/* Bison version.  */
-#define YYBISON_VERSION "3.0.4"
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -74,19 +64,19 @@
 #define YYPULL 1
 
 
+
+
+/* First part of user prologue.  */
+
 /* Substitute the variable and function names.  */
 #define yyparse         pcodeparse
 #define yylex           pcodelex
 #define yyerror         pcodeerror
 #define yydebug         pcodedebug
 #define yynerrs         pcodenerrs
-
 #define yylval          pcodelval
 #define yychar          pcodechar
 
-/* Copy the first part of user declarations.  */
-#line 16 "pcodeparse.y" /* yacc.c:339  */
-
 #include "pcodeparse.hh"
 
   //#define YYERROR_VERBOSE
@@ -95,106 +85,177 @@
   extern int yydebug;
   extern int yyerror(const char *str );
 
-#line 84 "pcodeparse.cc" /* yacc.c:339  */
 
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
 # ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
 #  else
-#   define YY_NULLPTR 0
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
 
 /* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
 #endif
 #if YYDEBUG
-extern int pcodedebug;
+extern int yydebug;
 #endif
 
-/* Token type.  */
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
   enum yytokentype
   {
-    OP_BOOL_OR = 258,
-    OP_BOOL_AND = 259,
-    OP_BOOL_XOR = 260,
-    OP_EQUAL = 261,
-    OP_NOTEQUAL = 262,
-    OP_FEQUAL = 263,
-    OP_FNOTEQUAL = 264,
-    OP_GREATEQUAL = 265,
-    OP_LESSEQUAL = 266,
-    OP_SLESS = 267,
-    OP_SGREATEQUAL = 268,
-    OP_SLESSEQUAL = 269,
-    OP_SGREAT = 270,
-    OP_FLESS = 271,
-    OP_FGREAT = 272,
-    OP_FLESSEQUAL = 273,
-    OP_FGREATEQUAL = 274,
-    OP_LEFT = 275,
-    OP_RIGHT = 276,
-    OP_SRIGHT = 277,
-    OP_FADD = 278,
-    OP_FSUB = 279,
-    OP_SDIV = 280,
-    OP_SREM = 281,
-    OP_FMULT = 282,
-    OP_FDIV = 283,
-    OP_ZEXT = 284,
-    OP_CARRY = 285,
-    OP_BORROW = 286,
-    OP_SEXT = 287,
-    OP_SCARRY = 288,
-    OP_SBORROW = 289,
-    OP_NAN = 290,
-    OP_ABS = 291,
-    OP_SQRT = 292,
-    OP_CEIL = 293,
-    OP_FLOOR = 294,
-    OP_ROUND = 295,
-    OP_INT2FLOAT = 296,
-    OP_FLOAT2FLOAT = 297,
-    OP_TRUNC = 298,
-    OP_NEW = 299,
-    BADINTEGER = 300,
-    GOTO_KEY = 301,
-    CALL_KEY = 302,
-    RETURN_KEY = 303,
-    IF_KEY = 304,
-    ENDOFSTREAM = 305,
-    LOCAL_KEY = 306,
-    INTEGER = 307,
-    STRING = 308,
-    SPACESYM = 309,
-    USEROPSYM = 310,
-    VARSYM = 311,
-    OPERANDSYM = 312,
-    STARTSYM = 313,
-    ENDSYM = 314,
-    NEXT2SYM = 315,
-    LABELSYM = 316
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    OP_BOOL_OR = 258,              /* OP_BOOL_OR  */
+    OP_BOOL_AND = 259,             /* OP_BOOL_AND  */
+    OP_BOOL_XOR = 260,             /* OP_BOOL_XOR  */
+    OP_EQUAL = 261,                /* OP_EQUAL  */
+    OP_NOTEQUAL = 262,             /* OP_NOTEQUAL  */
+    OP_FEQUAL = 263,               /* OP_FEQUAL  */
+    OP_FNOTEQUAL = 264,            /* OP_FNOTEQUAL  */
+    OP_GREATEQUAL = 265,           /* OP_GREATEQUAL  */
+    OP_LESSEQUAL = 266,            /* OP_LESSEQUAL  */
+    OP_SLESS = 267,                /* OP_SLESS  */
+    OP_SGREATEQUAL = 268,          /* OP_SGREATEQUAL  */
+    OP_SLESSEQUAL = 269,           /* OP_SLESSEQUAL  */
+    OP_SGREAT = 270,               /* OP_SGREAT  */
+    OP_FLESS = 271,                /* OP_FLESS  */
+    OP_FGREAT = 272,               /* OP_FGREAT  */
+    OP_FLESSEQUAL = 273,           /* OP_FLESSEQUAL  */
+    OP_FGREATEQUAL = 274,          /* OP_FGREATEQUAL  */
+    OP_LEFT = 275,                 /* OP_LEFT  */
+    OP_RIGHT = 276,                /* OP_RIGHT  */
+    OP_SRIGHT = 277,               /* OP_SRIGHT  */
+    OP_FADD = 278,                 /* OP_FADD  */
+    OP_FSUB = 279,                 /* OP_FSUB  */
+    OP_SDIV = 280,                 /* OP_SDIV  */
+    OP_SREM = 281,                 /* OP_SREM  */
+    OP_FMULT = 282,                /* OP_FMULT  */
+    OP_FDIV = 283,                 /* OP_FDIV  */
+    OP_ZEXT = 284,                 /* OP_ZEXT  */
+    OP_CARRY = 285,                /* OP_CARRY  */
+    OP_BORROW = 286,               /* OP_BORROW  */
+    OP_SEXT = 287,                 /* OP_SEXT  */
+    OP_SCARRY = 288,               /* OP_SCARRY  */
+    OP_SBORROW = 289,              /* OP_SBORROW  */
+    OP_NAN = 290,                  /* OP_NAN  */
+    OP_ABS = 291,                  /* OP_ABS  */
+    OP_SQRT = 292,                 /* OP_SQRT  */
+    OP_CEIL = 293,                 /* OP_CEIL  */
+    OP_FLOOR = 294,                /* OP_FLOOR  */
+    OP_ROUND = 295,                /* OP_ROUND  */
+    OP_INT2FLOAT = 296,            /* OP_INT2FLOAT  */
+    OP_FLOAT2FLOAT = 297,          /* OP_FLOAT2FLOAT  */
+    OP_TRUNC = 298,                /* OP_TRUNC  */
+    OP_NEW = 299,                  /* OP_NEW  */
+    BADINTEGER = 300,              /* BADINTEGER  */
+    GOTO_KEY = 301,                /* GOTO_KEY  */
+    CALL_KEY = 302,                /* CALL_KEY  */
+    RETURN_KEY = 303,              /* RETURN_KEY  */
+    IF_KEY = 304,                  /* IF_KEY  */
+    ENDOFSTREAM = 305,             /* ENDOFSTREAM  */
+    LOCAL_KEY = 306,               /* LOCAL_KEY  */
+    INTEGER = 307,                 /* INTEGER  */
+    STRING = 308,                  /* STRING  */
+    SPACESYM = 309,                /* SPACESYM  */
+    USEROPSYM = 310,               /* USEROPSYM  */
+    VARSYM = 311,                  /* VARSYM  */
+    OPERANDSYM = 312,              /* OPERANDSYM  */
+    STARTSYM = 313,                /* STARTSYM  */
+    ENDSYM = 314,                  /* ENDSYM  */
+    NEXT2SYM = 315,                /* NEXT2SYM  */
+    LABELSYM = 316                 /* LABELSYM  */
   };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define OP_BOOL_OR 258
+#define OP_BOOL_AND 259
+#define OP_BOOL_XOR 260
+#define OP_EQUAL 261
+#define OP_NOTEQUAL 262
+#define OP_FEQUAL 263
+#define OP_FNOTEQUAL 264
+#define OP_GREATEQUAL 265
+#define OP_LESSEQUAL 266
+#define OP_SLESS 267
+#define OP_SGREATEQUAL 268
+#define OP_SLESSEQUAL 269
+#define OP_SGREAT 270
+#define OP_FLESS 271
+#define OP_FGREAT 272
+#define OP_FLESSEQUAL 273
+#define OP_FGREATEQUAL 274
+#define OP_LEFT 275
+#define OP_RIGHT 276
+#define OP_SRIGHT 277
+#define OP_FADD 278
+#define OP_FSUB 279
+#define OP_SDIV 280
+#define OP_SREM 281
+#define OP_FMULT 282
+#define OP_FDIV 283
+#define OP_ZEXT 284
+#define OP_CARRY 285
+#define OP_BORROW 286
+#define OP_SEXT 287
+#define OP_SCARRY 288
+#define OP_SBORROW 289
+#define OP_NAN 290
+#define OP_ABS 291
+#define OP_SQRT 292
+#define OP_CEIL 293
+#define OP_FLOOR 294
+#define OP_ROUND 295
+#define OP_INT2FLOAT 296
+#define OP_FLOAT2FLOAT 297
+#define OP_TRUNC 298
+#define OP_NEW 299
+#define BADINTEGER 300
+#define GOTO_KEY 301
+#define CALL_KEY 302
+#define RETURN_KEY 303
+#define IF_KEY 304
+#define ENDOFSTREAM 305
+#define LOCAL_KEY 306
+#define INTEGER 307
+#define STRING 308
+#define SPACESYM 309
+#define USEROPSYM 310
+#define VARSYM 311
+#define OPERANDSYM 312
+#define STARTSYM 313
+#define ENDSYM 314
+#define NEXT2SYM 315
+#define LABELSYM 316
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 26 "pcodeparse.y" /* yacc.c:355  */
 
   uintb *i;
   string *str;
@@ -215,51 +276,211 @@ union YYSTYPE
   VarnodeSymbol *varsym;
   SpecificSymbol *specsym;
 
-#line 204 "pcodeparse.cc" /* yacc.c:355  */
-};
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
 #endif
 
 
-extern YYSTYPE pcodelval;
+extern YYSTYPE yylval;
 
-int pcodeparse (void);
 
+int yyparse (void);
+
+
+
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_OP_BOOL_OR = 3,                 /* OP_BOOL_OR  */
+  YYSYMBOL_OP_BOOL_AND = 4,                /* OP_BOOL_AND  */
+  YYSYMBOL_OP_BOOL_XOR = 5,                /* OP_BOOL_XOR  */
+  YYSYMBOL_6_ = 6,                         /* '|'  */
+  YYSYMBOL_7_ = 7,                         /* ';'  */
+  YYSYMBOL_8_ = 8,                         /* '^'  */
+  YYSYMBOL_9_ = 9,                         /* '&'  */
+  YYSYMBOL_OP_EQUAL = 10,                  /* OP_EQUAL  */
+  YYSYMBOL_OP_NOTEQUAL = 11,               /* OP_NOTEQUAL  */
+  YYSYMBOL_OP_FEQUAL = 12,                 /* OP_FEQUAL  */
+  YYSYMBOL_OP_FNOTEQUAL = 13,              /* OP_FNOTEQUAL  */
+  YYSYMBOL_14_ = 14,                       /* '<'  */
+  YYSYMBOL_15_ = 15,                       /* '>'  */
+  YYSYMBOL_OP_GREATEQUAL = 16,             /* OP_GREATEQUAL  */
+  YYSYMBOL_OP_LESSEQUAL = 17,              /* OP_LESSEQUAL  */
+  YYSYMBOL_OP_SLESS = 18,                  /* OP_SLESS  */
+  YYSYMBOL_OP_SGREATEQUAL = 19,            /* OP_SGREATEQUAL  */
+  YYSYMBOL_OP_SLESSEQUAL = 20,             /* OP_SLESSEQUAL  */
+  YYSYMBOL_OP_SGREAT = 21,                 /* OP_SGREAT  */
+  YYSYMBOL_OP_FLESS = 22,                  /* OP_FLESS  */
+  YYSYMBOL_OP_FGREAT = 23,                 /* OP_FGREAT  */
+  YYSYMBOL_OP_FLESSEQUAL = 24,             /* OP_FLESSEQUAL  */
+  YYSYMBOL_OP_FGREATEQUAL = 25,            /* OP_FGREATEQUAL  */
+  YYSYMBOL_OP_LEFT = 26,                   /* OP_LEFT  */
+  YYSYMBOL_OP_RIGHT = 27,                  /* OP_RIGHT  */
+  YYSYMBOL_OP_SRIGHT = 28,                 /* OP_SRIGHT  */
+  YYSYMBOL_29_ = 29,                       /* '+'  */
+  YYSYMBOL_30_ = 30,                       /* '-'  */
+  YYSYMBOL_OP_FADD = 31,                   /* OP_FADD  */
+  YYSYMBOL_OP_FSUB = 32,                   /* OP_FSUB  */
+  YYSYMBOL_33_ = 33,                       /* '*'  */
+  YYSYMBOL_34_ = 34,                       /* '/'  */
+  YYSYMBOL_35_ = 35,                       /* '%'  */
+  YYSYMBOL_OP_SDIV = 36,                   /* OP_SDIV  */
+  YYSYMBOL_OP_SREM = 37,                   /* OP_SREM  */
+  YYSYMBOL_OP_FMULT = 38,                  /* OP_FMULT  */
+  YYSYMBOL_OP_FDIV = 39,                   /* OP_FDIV  */
+  YYSYMBOL_40_ = 40,                       /* '!'  */
+  YYSYMBOL_41_ = 41,                       /* '~'  */
+  YYSYMBOL_OP_ZEXT = 42,                   /* OP_ZEXT  */
+  YYSYMBOL_OP_CARRY = 43,                  /* OP_CARRY  */
+  YYSYMBOL_OP_BORROW = 44,                 /* OP_BORROW  */
+  YYSYMBOL_OP_SEXT = 45,                   /* OP_SEXT  */
+  YYSYMBOL_OP_SCARRY = 46,                 /* OP_SCARRY  */
+  YYSYMBOL_OP_SBORROW = 47,                /* OP_SBORROW  */
+  YYSYMBOL_OP_NAN = 48,                    /* OP_NAN  */
+  YYSYMBOL_OP_ABS = 49,                    /* OP_ABS  */
+  YYSYMBOL_OP_SQRT = 50,                   /* OP_SQRT  */
+  YYSYMBOL_OP_CEIL = 51,                   /* OP_CEIL  */
+  YYSYMBOL_OP_FLOOR = 52,                  /* OP_FLOOR  */
+  YYSYMBOL_OP_ROUND = 53,                  /* OP_ROUND  */
+  YYSYMBOL_OP_INT2FLOAT = 54,              /* OP_INT2FLOAT  */
+  YYSYMBOL_OP_FLOAT2FLOAT = 55,            /* OP_FLOAT2FLOAT  */
+  YYSYMBOL_OP_TRUNC = 56,                  /* OP_TRUNC  */
+  YYSYMBOL_OP_NEW = 57,                    /* OP_NEW  */
+  YYSYMBOL_BADINTEGER = 58,                /* BADINTEGER  */
+  YYSYMBOL_GOTO_KEY = 59,                  /* GOTO_KEY  */
+  YYSYMBOL_CALL_KEY = 60,                  /* CALL_KEY  */
+  YYSYMBOL_RETURN_KEY = 61,                /* RETURN_KEY  */
+  YYSYMBOL_IF_KEY = 62,                    /* IF_KEY  */
+  YYSYMBOL_ENDOFSTREAM = 63,               /* ENDOFSTREAM  */
+  YYSYMBOL_LOCAL_KEY = 64,                 /* LOCAL_KEY  */
+  YYSYMBOL_INTEGER = 65,                   /* INTEGER  */
+  YYSYMBOL_STRING = 66,                    /* STRING  */
+  YYSYMBOL_SPACESYM = 67,                  /* SPACESYM  */
+  YYSYMBOL_USEROPSYM = 68,                 /* USEROPSYM  */
+  YYSYMBOL_VARSYM = 69,                    /* VARSYM  */
+  YYSYMBOL_OPERANDSYM = 70,                /* OPERANDSYM  */
+  YYSYMBOL_STARTSYM = 71,                  /* STARTSYM  */
+  YYSYMBOL_ENDSYM = 72,                    /* ENDSYM  */
+  YYSYMBOL_NEXT2SYM = 73,                  /* NEXT2SYM  */
+  YYSYMBOL_LABELSYM = 74,                  /* LABELSYM  */
+  YYSYMBOL_75_ = 75,                       /* ':'  */
+  YYSYMBOL_76_ = 76,                       /* '='  */
+  YYSYMBOL_77_ = 77,                       /* '('  */
+  YYSYMBOL_78_ = 78,                       /* ')'  */
+  YYSYMBOL_79_ = 79,                       /* '['  */
+  YYSYMBOL_80_ = 80,                       /* ','  */
+  YYSYMBOL_81_ = 81,                       /* ']'  */
+  YYSYMBOL_YYACCEPT = 82,                  /* $accept  */
+  YYSYMBOL_rtl = 83,                       /* rtl  */
+  YYSYMBOL_rtlmid = 84,                    /* rtlmid  */
+  YYSYMBOL_statement = 85,                 /* statement  */
+  YYSYMBOL_expr = 86,                      /* expr  */
+  YYSYMBOL_sizedstar = 87,                 /* sizedstar  */
+  YYSYMBOL_jumpdest = 88,                  /* jumpdest  */
+  YYSYMBOL_varnode = 89,                   /* varnode  */
+  YYSYMBOL_integervarnode = 90,            /* integervarnode  */
+  YYSYMBOL_lhsvarnode = 91,                /* lhsvarnode  */
+  YYSYMBOL_label = 92,                     /* label  */
+  YYSYMBOL_specificsymbol = 93,            /* specificsymbol  */
+  YYSYMBOL_paramlist = 94                  /* paramlist  */
+};
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
 
-/* Copy the second part of user declarations.  */
 
-#line 221 "pcodeparse.cc" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
 #endif
 
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
 #else
 typedef signed char yytype_int8;
 #endif
 
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
 #else
-typedef unsigned short int yytype_uint16;
+typedef short yytype_int16;
+#endif
+
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
 #else
-typedef short int yytype_int16;
+typedef short yytype_uint8;
+#endif
+
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
+#else
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
 #endif
 
 #ifndef YYSIZE_T
@@ -267,15 +488,28 @@ typedef short int yytype_int16;
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
-#  define YYSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_int16 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
 #ifndef YY_
 # if defined YYENABLE_NLS && YYENABLE_NLS
@@ -289,47 +523,43 @@ typedef short int yytype_int16;
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
 
 #ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
 #endif
 
 #ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
+# define YY_USE(E) ((void) (E))
 #else
-# define YYUSE(E) /* empty */
+# define YY_USE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
 /* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
 # define YY_INITIAL_VALUE(Value) Value
@@ -342,8 +572,22 @@ typedef short int yytype_int16;
 # define YY_INITIAL_VALUE(Value) /* Nothing. */
 #endif
 
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
 
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -408,8 +652,7 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
@@ -418,17 +661,17 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
+  yy_state_t yyss_alloc;
   YYSTYPE yyvs_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 # define YYCOPY_NEEDED 1
@@ -441,11 +684,11 @@ union yyalloc
 # define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
+        YYPTRDIFF_T yynewbytes;                                         \
         YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
         Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
@@ -457,12 +700,12 @@ union yyalloc
 # ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
 #   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          YYSIZE_T yyi;                         \
+          YYPTRDIFF_T yyi;                      \
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
@@ -485,17 +728,20 @@ union yyalloc
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  298
 
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
-#define YYUNDEFTOK  2
+/* YYMAXUTOK -- Last valid token kind.  */
 #define YYMAXUTOK   316
 
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
-static const yytype_uint8 yytranslate[] =
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -532,78 +778,74 @@ static const yytype_uint8 yytranslate[] =
 };
 
 #if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint8 yyrline[] =
 {
-       0,   102,   102,   104,   105,   106,   107,   109,   110,   111,
-     112,   113,   114,   115,   116,   117,   118,   119,   120,   121,
-     122,   123,   124,   125,   126,   127,   129,   130,   131,   132,
-     133,   134,   135,   136,   137,   138,   139,   140,   141,   142,
-     143,   144,   145,   146,   147,   148,   149,   150,   151,   152,
-     153,   154,   155,   156,   157,   158,   159,   160,   161,   162,
-     163,   164,   165,   166,   167,   168,   169,   170,   171,   172,
-     173,   174,   175,   176,   177,   178,   179,   180,   181,   182,
-     183,   184,   185,   186,   187,   188,   189,   190,   191,   193,
-     194,   195,   196,   198,   199,   200,   201,   202,   203,   204,
-     205,   207,   208,   209,   211,   212,   213,   214,   215,   217,
-     218,   220,   221,   223,   224,   225,   226,   227,   229,   230,
-     231
+       0,   111,   111,   113,   114,   115,   116,   118,   119,   120,
+     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   138,   139,   140,   141,
+     142,   143,   144,   145,   146,   147,   148,   149,   150,   151,
+     152,   153,   154,   155,   156,   157,   158,   159,   160,   161,
+     162,   163,   164,   165,   166,   167,   168,   169,   170,   171,
+     172,   173,   174,   175,   176,   177,   178,   179,   180,   181,
+     182,   183,   184,   185,   186,   187,   188,   189,   190,   191,
+     192,   193,   194,   195,   196,   197,   198,   199,   200,   202,
+     203,   204,   205,   207,   208,   209,   210,   211,   212,   213,
+     214,   216,   217,   218,   220,   221,   222,   223,   224,   226,
+     227,   229,   230,   232,   233,   234,   235,   236,   238,   239,
+     240
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 0
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "OP_BOOL_OR", "OP_BOOL_AND",
-  "OP_BOOL_XOR", "'|'", "';'", "'^'", "'&'", "OP_EQUAL", "OP_NOTEQUAL",
-  "OP_FEQUAL", "OP_FNOTEQUAL", "'<'", "'>'", "OP_GREATEQUAL",
-  "OP_LESSEQUAL", "OP_SLESS", "OP_SGREATEQUAL", "OP_SLESSEQUAL",
-  "OP_SGREAT", "OP_FLESS", "OP_FGREAT", "OP_FLESSEQUAL", "OP_FGREATEQUAL",
-  "OP_LEFT", "OP_RIGHT", "OP_SRIGHT", "'+'", "'-'", "OP_FADD", "OP_FSUB",
-  "'*'", "'/'", "'%'", "OP_SDIV", "OP_SREM", "OP_FMULT", "OP_FDIV", "'!'",
-  "'~'", "OP_ZEXT", "OP_CARRY", "OP_BORROW", "OP_SEXT", "OP_SCARRY",
-  "OP_SBORROW", "OP_NAN", "OP_ABS", "OP_SQRT", "OP_CEIL", "OP_FLOOR",
-  "OP_ROUND", "OP_INT2FLOAT", "OP_FLOAT2FLOAT", "OP_TRUNC", "OP_NEW",
-  "BADINTEGER", "GOTO_KEY", "CALL_KEY", "RETURN_KEY", "IF_KEY",
-  "ENDOFSTREAM", "LOCAL_KEY", "INTEGER", "STRING", "SPACESYM", "USEROPSYM",
-  "VARSYM", "OPERANDSYM", "STARTSYM", "ENDSYM", "NEXT2SYM", "LABELSYM",
-  "':'", "'='", "'('", "')'", "'['", "','", "']'", "$accept", "rtl",
-  "rtlmid", "statement", "expr", "sizedstar", "jumpdest", "varnode",
+  "\"end of file\"", "error", "\"invalid token\"", "OP_BOOL_OR",
+  "OP_BOOL_AND", "OP_BOOL_XOR", "'|'", "';'", "'^'", "'&'", "OP_EQUAL",
+  "OP_NOTEQUAL", "OP_FEQUAL", "OP_FNOTEQUAL", "'<'", "'>'",
+  "OP_GREATEQUAL", "OP_LESSEQUAL", "OP_SLESS", "OP_SGREATEQUAL",
+  "OP_SLESSEQUAL", "OP_SGREAT", "OP_FLESS", "OP_FGREAT", "OP_FLESSEQUAL",
+  "OP_FGREATEQUAL", "OP_LEFT", "OP_RIGHT", "OP_SRIGHT", "'+'", "'-'",
+  "OP_FADD", "OP_FSUB", "'*'", "'/'", "'%'", "OP_SDIV", "OP_SREM",
+  "OP_FMULT", "OP_FDIV", "'!'", "'~'", "OP_ZEXT", "OP_CARRY", "OP_BORROW",
+  "OP_SEXT", "OP_SCARRY", "OP_SBORROW", "OP_NAN", "OP_ABS", "OP_SQRT",
+  "OP_CEIL", "OP_FLOOR", "OP_ROUND", "OP_INT2FLOAT", "OP_FLOAT2FLOAT",
+  "OP_TRUNC", "OP_NEW", "BADINTEGER", "GOTO_KEY", "CALL_KEY", "RETURN_KEY",
+  "IF_KEY", "ENDOFSTREAM", "LOCAL_KEY", "INTEGER", "STRING", "SPACESYM",
+  "USEROPSYM", "VARSYM", "OPERANDSYM", "STARTSYM", "ENDSYM", "NEXT2SYM",
+  "LABELSYM", "':'", "'='", "'('", "')'", "'['", "','", "']'", "$accept",
+  "rtl", "rtlmid", "statement", "expr", "sizedstar", "jumpdest", "varnode",
   "integervarnode", "lhsvarnode", "label", "specificsymbol", "paramlist", YY_NULLPTR
 };
-#endif
 
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
 {
-       0,   256,   257,   258,   259,   260,   124,    59,    94,    38,
-     261,   262,   263,   264,    60,    62,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   277,    43,
-      45,   278,   279,    42,    47,    37,   280,   281,   282,   283,
-      33,   126,   284,   285,   286,   287,   288,   289,   290,   291,
-     292,   293,   294,   295,   296,   297,   298,   299,   300,   301,
-     302,   303,   304,   305,   306,   307,   308,   309,   310,   311,
-     312,   313,   314,   315,   316,    58,    61,    40,    41,    91,
-      44,    93
-};
-# endif
+  return yytname[yysymbol];
+}
+#endif
 
-#define YYPACT_NINF -68
+#define YYPACT_NINF (-68)
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-68)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define YYTABLE_NINF -111
+#define YYTABLE_NINF (-111)
 
-#define yytable_value_is_error(Yytable_value) \
-  (!!((Yytable_value) == (-111)))
+#define yytable_value_is_error(Yyn) \
+  ((Yyn) == YYTABLE_NINF)
 
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
      -68,     9,  1480,   -68,   459,   -40,   -46,   -68,   564,   672,
@@ -638,10 +880,10 @@ static const yytype_int16 yypact[] =
      -68,   -68,   -68,   -68,   -68,  1430,  1830,   -68
 };
 
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint8 yydefact[] =
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_int8 yydefact[] =
 {
        3,     0,     0,     1,     0,     0,    92,   105,     0,     0,
        0,     0,     2,     0,   104,   103,     0,   113,   114,   115,
@@ -675,23 +917,23 @@ static const yytype_uint8 yydefact[] =
       74,    75,    84,    87,    10,     0,     0,    15
 };
 
-  /* YYPGOTO[NTERM-NUM].  */
+/* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
      -68,   -68,   -68,   -68,   -11,   264,    -8,     1,   110,   -68,
      267,     0,   154
 };
 
-  /* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int16 yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_uint8 yydefgoto[] =
 {
-      -1,     1,     2,    22,   166,    72,    44,    73,    25,    26,
+       0,     1,     2,    22,   166,    72,    44,    73,    25,    26,
       45,    74,   167
 };
 
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
       71,    47,    28,    24,    32,    31,    48,     4,    82,     3,
@@ -1094,9 +1336,9 @@ static const yytype_int16 yycheck[] =
       31,    32,    33,    34,    35,    36,    37,    38,    39
 };
 
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
+static const yytype_int8 yystos[] =
 {
        0,    83,    84,     0,     9,    14,    33,    58,    59,    60,
       61,    62,    63,    64,    65,    66,    68,    69,    70,    71,
@@ -1130,8 +1372,8 @@ static const yytype_uint8 yystos[] =
       78,    78,    78,    81,     7,    76,    86,     7
 };
 
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr1[] =
 {
        0,    82,    83,    84,    84,    84,    84,    85,    85,    85,
       85,    85,    85,    85,    85,    85,    85,    85,    85,    85,
@@ -1148,8 +1390,8 @@ static const yytype_uint8 yyr1[] =
       94
 };
 
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
 {
        0,     2,     2,     0,     2,     4,     6,     4,     5,     4,
        7,     6,     3,     5,     5,     9,     4,     4,     3,     5,
@@ -1167,39 +1409,39 @@ static const yytype_uint8 yyr2[] =
 };
 
 
+enum { YYENOMEM = -2 };
+
 #define yyerrok         (yyerrstatus = 0)
 #define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
 
 #define YYACCEPT        goto yyacceptlab
 #define YYABORT         goto yyabortlab
 #define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
 
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
 
 
 /* Enable debugging if requested.  */
@@ -1216,55 +1458,52 @@ do {                                            \
     YYFPRINTF Args;                             \
 } while (0)
 
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
 
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
   if (yydebug)                                                            \
     {                                                                     \
       YYFPRINTF (stderr, "%s ", Title);                                   \
       yy_symbol_print (stderr,                                            \
-                  Type, Value); \
+                  Kind, Value); \
       YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
   if (!yyvaluep)
     return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  YYFPRINTF (yyoutput, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
+  yy_symbol_value_print (yyo, yykind, yyvaluep);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
@@ -1273,7 +1512,7 @@ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
 `------------------------------------------------------------------*/
 
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -1296,21 +1535,21 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule)
 {
-  unsigned long int yylno = yyrline[yyrule];
+  int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
              yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
-                                              );
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)]);
       YYFPRINTF (stderr, "\n");
     }
 }
@@ -1325,8 +1564,8 @@ do {                                    \
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1349,310 +1588,70 @@ int yydebug;
 #endif
 
 
-#if YYERROR_VERBOSE
 
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
 
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
 
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
 {
-  YYUSE (yyvaluep);
+  YY_USE (yyvaluep);
   if (!yymsg)
     yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  switch (yytype)
+  switch (yykind)
     {
-          case 65: /* INTEGER  */
-#line 92 "pcodeparse.y" /* yacc.c:1257  */
-      { delete ((*yyvaluep).i); }
-#line 1578 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_INTEGER: /* INTEGER  */
+            { delete ((*yyvaluep).i); }
         break;
 
-    case 66: /* STRING  */
-#line 93 "pcodeparse.y" /* yacc.c:1257  */
-      { delete ((*yyvaluep).str); }
-#line 1584 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_STRING: /* STRING  */
+            { delete ((*yyvaluep).str); }
         break;
 
-    case 84: /* rtlmid  */
-#line 95 "pcodeparse.y" /* yacc.c:1257  */
-      { delete ((*yyvaluep).sem); }
-#line 1590 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_rtlmid: /* rtlmid  */
+            { delete ((*yyvaluep).sem); }
         break;
 
-    case 85: /* statement  */
-#line 96 "pcodeparse.y" /* yacc.c:1257  */
-      { if (((*yyvaluep).stmt) != (vector<OpTpl *> *)0) { for(int4 i=0;i<((*yyvaluep).stmt)->size();++i) delete (*((*yyvaluep).stmt))[i]; delete ((*yyvaluep).stmt);} }
-#line 1596 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_statement: /* statement  */
+            { if (((*yyvaluep).stmt) != (vector<OpTpl *> *)0) { for(int4 i=0;i<((*yyvaluep).stmt)->size();++i) delete (*((*yyvaluep).stmt))[i]; delete ((*yyvaluep).stmt);} }
         break;
 
-    case 86: /* expr  */
-#line 97 "pcodeparse.y" /* yacc.c:1257  */
-      { delete ((*yyvaluep).tree); }
-#line 1602 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_expr: /* expr  */
+            { delete ((*yyvaluep).tree); }
         break;
 
-    case 87: /* sizedstar  */
-#line 99 "pcodeparse.y" /* yacc.c:1257  */
-      { delete ((*yyvaluep).starqual); }
-#line 1608 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_sizedstar: /* sizedstar  */
+            { delete ((*yyvaluep).starqual); }
         break;
 
-    case 88: /* jumpdest  */
-#line 98 "pcodeparse.y" /* yacc.c:1257  */
-      { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
-#line 1614 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_jumpdest: /* jumpdest  */
+            { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
         break;
 
-    case 89: /* varnode  */
-#line 98 "pcodeparse.y" /* yacc.c:1257  */
-      { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
-#line 1620 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_varnode: /* varnode  */
+            { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
         break;
 
-    case 90: /* integervarnode  */
-#line 98 "pcodeparse.y" /* yacc.c:1257  */
-      { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
-#line 1626 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_integervarnode: /* integervarnode  */
+            { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
         break;
 
-    case 91: /* lhsvarnode  */
-#line 98 "pcodeparse.y" /* yacc.c:1257  */
-      { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
-#line 1632 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_lhsvarnode: /* lhsvarnode  */
+            { if (((*yyvaluep).varnode) != (VarnodeTpl *)0) delete ((*yyvaluep).varnode); }
         break;
 
-    case 94: /* paramlist  */
-#line 94 "pcodeparse.y" /* yacc.c:1257  */
-      { for(int4 i=0;i<((*yyvaluep).param)->size();++i) delete (*((*yyvaluep).param))[i]; delete ((*yyvaluep).param); }
-#line 1638 "pcodeparse.cc" /* yacc.c:1257  */
+    case YYSYMBOL_paramlist: /* paramlist  */
+            { for(int4 i=0;i<((*yyvaluep).param)->size();++i) delete (*((*yyvaluep).param))[i]; delete ((*yyvaluep).param); }
         break;
 
-
       default:
         break;
     }
@@ -1660,9 +1659,7 @@ yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 }
 
 
-
-
-/* The lookahead symbol.  */
+/* Lookahead token kind.  */
 int yychar;
 
 /* The semantic value of the lookahead symbol.  */
@@ -1671,6 +1668,8 @@ YYSTYPE yylval;
 int yynerrs;
 
 
+
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1678,43 +1677,36 @@ int yynerrs;
 int
 yyparse (void)
 {
-    int yystate;
+    yy_state_fast_t yystate = 0;
     /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
+    int yyerrstatus = 0;
 
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
-
-       Refer to the stacks through separate pointers, to allow yyoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-    YYSIZE_T yystacksize;
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
   int yyn;
+  /* The return value of yyparse.  */
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
@@ -1722,71 +1714,75 @@ yyparse (void)
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
+
   goto yysetstate;
 
+
 /*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- yynewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
- yysetstate:
-  *yyssp = yystate;
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
 
   if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef yyoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
+        yy_state_t *yyss1 = yyss;
         YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
 
         /* Each stack pointer address is followed by the size of the
            data in use in that stack, in bytes.  This used to be a
            conditional around just the two extra args, but that might
            be undefined if yyoverflow is a macro.  */
         yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                     &yystacksize);
-
         yyss = yyss1;
         yyvs = yyvs1;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
+        YYNOMEM;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
 
       {
-        yytype_int16 *yyss1 = yyss;
+        yy_state_t *yyss1 = yyss;
         union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
         if (! yyptr)
-          goto yyexhaustedlab;
+          YYNOMEM;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
@@ -1794,30 +1790,31 @@ yyparse (void)
           YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no yyoverflow */
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
+
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
-
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
@@ -1828,18 +1825,29 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF ((stderr, "Reading a token\n"));
       yychar = yylex ();
     }
 
   if (yychar <= YYEOF)
     {
-      yychar = yytoken = YYEOF;
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
+    }
   else
     {
       yytoken = YYTRANSLATE (yychar);
@@ -1867,15 +1875,13 @@ yybackup:
 
   /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
 
@@ -1890,7 +1896,7 @@ yydefault:
 
 
 /*-----------------------------.
-| yyreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
@@ -1910,722 +1916,484 @@ yyreduce:
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-        case 2:
-#line 102 "pcodeparse.y" /* yacc.c:1646  */
-    { pcode->setResult((yyvsp[-1].sem)); }
-#line 1902 "pcodeparse.cc" /* yacc.c:1646  */
+  case 2: /* rtl: rtlmid ENDOFSTREAM  */
+                                        { pcode->setResult((yyvsp[-1].sem)); }
     break;
 
-  case 3:
-#line 104 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = new ConstructTpl(); }
-#line 1908 "pcodeparse.cc" /* yacc.c:1646  */
+  case 3: /* rtlmid: %empty  */
+                                        { (yyval.sem) = new ConstructTpl(); }
     break;
 
-  case 4:
-#line 105 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-1].sem); if (!(yyval.sem)->addOpList(*(yyvsp[0].stmt))) { delete (yyvsp[0].stmt); yyerror("Multiple delayslot declarations"); YYERROR; } delete (yyvsp[0].stmt); }
-#line 1914 "pcodeparse.cc" /* yacc.c:1646  */
+  case 4: /* rtlmid: rtlmid statement  */
+                                        { (yyval.sem) = (yyvsp[-1].sem); if (!(yyval.sem)->addOpList(*(yyvsp[0].stmt))) { delete (yyvsp[0].stmt); yyerror("Multiple delayslot declarations"); YYERROR; } delete (yyvsp[0].stmt); }
     break;
 
-  case 5:
-#line 106 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-3].sem); pcode->newLocalDefinition((yyvsp[-1].str)); }
-#line 1920 "pcodeparse.cc" /* yacc.c:1646  */
+  case 5: /* rtlmid: rtlmid LOCAL_KEY STRING ';'  */
+                                { (yyval.sem) = (yyvsp[-3].sem); pcode->newLocalDefinition((yyvsp[-1].str)); }
     break;
 
-  case 6:
-#line 107 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-5].sem); pcode->newLocalDefinition((yyvsp[-3].str),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 1926 "pcodeparse.cc" /* yacc.c:1646  */
+  case 6: /* rtlmid: rtlmid LOCAL_KEY STRING ':' INTEGER ';'  */
+                                            { (yyval.sem) = (yyvsp[-5].sem); pcode->newLocalDefinition((yyvsp[-3].str),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 7:
-#line 109 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyvsp[-1].tree)->setOutput((yyvsp[-3].varnode)); (yyval.stmt) = ExprTree::toVector((yyvsp[-1].tree)); }
-#line 1932 "pcodeparse.cc" /* yacc.c:1646  */
+  case 7: /* statement: lhsvarnode '=' expr ';'  */
+                                        { (yyvsp[-1].tree)->setOutput((yyvsp[-3].varnode)); (yyval.stmt) = ExprTree::toVector((yyvsp[-1].tree)); }
     break;
 
-  case 8:
-#line 110 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-3].str)); }
-#line 1938 "pcodeparse.cc" /* yacc.c:1646  */
+  case 8: /* statement: LOCAL_KEY STRING '=' expr ';'  */
+                                        { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-3].str)); }
     break;
 
-  case 9:
-#line 111 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->newOutput(false,(yyvsp[-1].tree),(yyvsp[-3].str)); }
-#line 1944 "pcodeparse.cc" /* yacc.c:1646  */
+  case 9: /* statement: STRING '=' expr ';'  */
+                                        { (yyval.stmt) = pcode->newOutput(false,(yyvsp[-1].tree),(yyvsp[-3].str)); }
     break;
 
-  case 10:
-#line 112 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
-#line 1950 "pcodeparse.cc" /* yacc.c:1646  */
+  case 10: /* statement: LOCAL_KEY STRING ':' INTEGER '=' expr ';'  */
+                                                { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
     break;
 
-  case 11:
-#line 113 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
-#line 1956 "pcodeparse.cc" /* yacc.c:1646  */
+  case 11: /* statement: STRING ':' INTEGER '=' expr ';'  */
+                                        { (yyval.stmt) = pcode->newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
     break;
 
-  case 12:
-#line 114 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = (vector<OpTpl *> *)0; string errmsg = "Redefinition of symbol: "+(yyvsp[-1].specsym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
-#line 1962 "pcodeparse.cc" /* yacc.c:1646  */
+  case 12: /* statement: LOCAL_KEY specificsymbol '='  */
+                                 { (yyval.stmt) = (vector<OpTpl *> *)0; string errmsg = "Redefinition of symbol: "+(yyvsp[-1].specsym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 13:
-#line 115 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createStore((yyvsp[-4].starqual),(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 1968 "pcodeparse.cc" /* yacc.c:1646  */
+  case 13: /* statement: sizedstar expr '=' expr ';'  */
+                                        { (yyval.stmt) = pcode->createStore((yyvsp[-4].starqual),(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 14:
-#line 116 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createUserOpNoOut((yyvsp[-4].useropsym),(yyvsp[-2].param)); }
-#line 1974 "pcodeparse.cc" /* yacc.c:1646  */
+  case 14: /* statement: USEROPSYM '(' paramlist ')' ';'  */
+                                        { (yyval.stmt) = pcode->createUserOpNoOut((yyvsp[-4].useropsym),(yyvsp[-2].param)); }
     break;
 
-  case 15:
-#line 117 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->assignBitRange((yyvsp[-8].varnode),(uint4)*(yyvsp[-6].i),(uint4)*(yyvsp[-4].i),(yyvsp[-1].tree)); delete (yyvsp[-6].i), delete (yyvsp[-4].i); }
-#line 1980 "pcodeparse.cc" /* yacc.c:1646  */
+  case 15: /* statement: lhsvarnode '[' INTEGER ',' INTEGER ']' '=' expr ';'  */
+                                                        { (yyval.stmt) = pcode->assignBitRange((yyvsp[-8].varnode),(uint4)*(yyvsp[-6].i),(uint4)*(yyvsp[-4].i),(yyvsp[-1].tree)); delete (yyvsp[-6].i), delete (yyvsp[-4].i); }
     break;
 
-  case 16:
-#line 118 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = (vector<OpTpl *> *)0; delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal truncation on left-hand side of assignment"); YYERROR; }
-#line 1986 "pcodeparse.cc" /* yacc.c:1646  */
+  case 16: /* statement: varnode ':' INTEGER '='  */
+                                        { (yyval.stmt) = (vector<OpTpl *> *)0; delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal truncation on left-hand side of assignment"); YYERROR; }
     break;
 
-  case 17:
-#line 119 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = (vector<OpTpl *> *)0; delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal subpiece on left-hand side of assignment"); YYERROR; }
-#line 1992 "pcodeparse.cc" /* yacc.c:1646  */
+  case 17: /* statement: varnode '(' INTEGER ')'  */
+                                        { (yyval.stmt) = (vector<OpTpl *> *)0; delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal subpiece on left-hand side of assignment"); YYERROR; }
     break;
 
-  case 18:
-#line 120 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_BRANCH,new ExprTree((yyvsp[-1].varnode))); }
-#line 1998 "pcodeparse.cc" /* yacc.c:1646  */
+  case 18: /* statement: GOTO_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_BRANCH,new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 19:
-#line 121 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_CBRANCH,new ExprTree((yyvsp[-1].varnode)),(yyvsp[-3].tree)); }
-#line 2004 "pcodeparse.cc" /* yacc.c:1646  */
+  case 19: /* statement: IF_KEY expr GOTO_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_CBRANCH,new ExprTree((yyvsp[-1].varnode)),(yyvsp[-3].tree)); }
     break;
 
-  case 20:
-#line 122 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_BRANCHIND,(yyvsp[-2].tree)); }
-#line 2010 "pcodeparse.cc" /* yacc.c:1646  */
+  case 20: /* statement: GOTO_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_BRANCHIND,(yyvsp[-2].tree)); }
     break;
 
-  case 21:
-#line 123 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_CALL,new ExprTree((yyvsp[-1].varnode))); }
-#line 2016 "pcodeparse.cc" /* yacc.c:1646  */
+  case 21: /* statement: CALL_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_CALL,new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 22:
-#line 124 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_CALLIND,(yyvsp[-2].tree)); }
-#line 2022 "pcodeparse.cc" /* yacc.c:1646  */
+  case 22: /* statement: CALL_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_CALLIND,(yyvsp[-2].tree)); }
     break;
 
-  case 23:
-#line 125 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = (vector<OpTpl *> *)0; yyerror("Must specify an indirect parameter for return"); YYERROR; }
-#line 2028 "pcodeparse.cc" /* yacc.c:1646  */
+  case 23: /* statement: RETURN_KEY ';'  */
+                                        { (yyval.stmt) = (vector<OpTpl *> *)0; yyerror("Must specify an indirect parameter for return"); YYERROR; }
     break;
 
-  case 24:
-#line 126 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->createOpNoOut(CPUI_RETURN,(yyvsp[-2].tree)); }
-#line 2034 "pcodeparse.cc" /* yacc.c:1646  */
+  case 24: /* statement: RETURN_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = pcode->createOpNoOut(CPUI_RETURN,(yyvsp[-2].tree)); }
     break;
 
-  case 25:
-#line 127 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = pcode->placeLabel( (yyvsp[0].labelsym) ); }
-#line 2040 "pcodeparse.cc" /* yacc.c:1646  */
+  case 25: /* statement: label  */
+                                        { (yyval.stmt) = pcode->placeLabel( (yyvsp[0].labelsym) ); }
     break;
 
-  case 26:
-#line 129 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = new ExprTree((yyvsp[0].varnode)); }
-#line 2046 "pcodeparse.cc" /* yacc.c:1646  */
+  case 26: /* expr: varnode  */
+              { (yyval.tree) = new ExprTree((yyvsp[0].varnode)); }
     break;
 
-  case 27:
-#line 130 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createLoad((yyvsp[-1].starqual),(yyvsp[0].tree)); }
-#line 2052 "pcodeparse.cc" /* yacc.c:1646  */
+  case 27: /* expr: sizedstar expr  */
+                                { (yyval.tree) = pcode->createLoad((yyvsp[-1].starqual),(yyvsp[0].tree)); }
     break;
 
-  case 28:
-#line 131 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = (yyvsp[-1].tree); }
-#line 2058 "pcodeparse.cc" /* yacc.c:1646  */
+  case 28: /* expr: '(' expr ')'  */
+                                { (yyval.tree) = (yyvsp[-1].tree); }
     break;
 
-  case 29:
-#line 132 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2064 "pcodeparse.cc" /* yacc.c:1646  */
+  case 29: /* expr: expr '+' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 30:
-#line 133 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2070 "pcodeparse.cc" /* yacc.c:1646  */
+  case 30: /* expr: expr '-' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 31:
-#line 134 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2076 "pcodeparse.cc" /* yacc.c:1646  */
+  case 31: /* expr: expr OP_EQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 32:
-#line 135 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2082 "pcodeparse.cc" /* yacc.c:1646  */
+  case 32: /* expr: expr OP_NOTEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 33:
-#line 136 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2088 "pcodeparse.cc" /* yacc.c:1646  */
+  case 33: /* expr: expr '<' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 34:
-#line 137 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2094 "pcodeparse.cc" /* yacc.c:1646  */
+  case 34: /* expr: expr OP_GREATEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 35:
-#line 138 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2100 "pcodeparse.cc" /* yacc.c:1646  */
+  case 35: /* expr: expr OP_LESSEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 36:
-#line 139 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2106 "pcodeparse.cc" /* yacc.c:1646  */
+  case 36: /* expr: expr '>' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 37:
-#line 140 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SLESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2112 "pcodeparse.cc" /* yacc.c:1646  */
+  case 37: /* expr: expr OP_SLESS expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SLESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 38:
-#line 141 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SLESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2118 "pcodeparse.cc" /* yacc.c:1646  */
+  case 38: /* expr: expr OP_SGREATEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SLESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 39:
-#line 142 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SLESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2124 "pcodeparse.cc" /* yacc.c:1646  */
+  case 39: /* expr: expr OP_SLESSEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SLESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 40:
-#line 143 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SLESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2130 "pcodeparse.cc" /* yacc.c:1646  */
+  case 40: /* expr: expr OP_SGREAT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SLESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 41:
-#line 144 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_2COMP,(yyvsp[0].tree)); }
-#line 2136 "pcodeparse.cc" /* yacc.c:1646  */
+  case 41: /* expr: '-' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_2COMP,(yyvsp[0].tree)); }
     break;
 
-  case 42:
-#line 145 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_NEGATE,(yyvsp[0].tree)); }
-#line 2142 "pcodeparse.cc" /* yacc.c:1646  */
+  case 42: /* expr: '~' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_NEGATE,(yyvsp[0].tree)); }
     break;
 
-  case 43:
-#line 146 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2148 "pcodeparse.cc" /* yacc.c:1646  */
+  case 43: /* expr: expr '^' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 44:
-#line 147 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2154 "pcodeparse.cc" /* yacc.c:1646  */
+  case 44: /* expr: expr '&' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 45:
-#line 148 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2160 "pcodeparse.cc" /* yacc.c:1646  */
+  case 45: /* expr: expr '|' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 46:
-#line 149 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_LEFT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2166 "pcodeparse.cc" /* yacc.c:1646  */
+  case 46: /* expr: expr OP_LEFT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_LEFT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 47:
-#line 150 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_RIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2172 "pcodeparse.cc" /* yacc.c:1646  */
+  case 47: /* expr: expr OP_RIGHT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_RIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 48:
-#line 151 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SRIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2178 "pcodeparse.cc" /* yacc.c:1646  */
+  case 48: /* expr: expr OP_SRIGHT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SRIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 49:
-#line 152 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2184 "pcodeparse.cc" /* yacc.c:1646  */
+  case 49: /* expr: expr '*' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 50:
-#line 153 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2190 "pcodeparse.cc" /* yacc.c:1646  */
+  case 50: /* expr: expr '/' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 51:
-#line 154 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SDIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2196 "pcodeparse.cc" /* yacc.c:1646  */
+  case 51: /* expr: expr OP_SDIV expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SDIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 52:
-#line 155 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_REM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2202 "pcodeparse.cc" /* yacc.c:1646  */
+  case 52: /* expr: expr '%' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_REM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 53:
-#line 156 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SREM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2208 "pcodeparse.cc" /* yacc.c:1646  */
+  case 53: /* expr: expr OP_SREM expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SREM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 54:
-#line 157 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_BOOL_NEGATE,(yyvsp[0].tree)); }
-#line 2214 "pcodeparse.cc" /* yacc.c:1646  */
+  case 54: /* expr: '!' expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_BOOL_NEGATE,(yyvsp[0].tree)); }
     break;
 
-  case 55:
-#line 158 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_BOOL_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2220 "pcodeparse.cc" /* yacc.c:1646  */
+  case 55: /* expr: expr OP_BOOL_XOR expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_BOOL_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 56:
-#line 159 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_BOOL_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2226 "pcodeparse.cc" /* yacc.c:1646  */
+  case 56: /* expr: expr OP_BOOL_AND expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_BOOL_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 57:
-#line 160 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_BOOL_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2232 "pcodeparse.cc" /* yacc.c:1646  */
+  case 57: /* expr: expr OP_BOOL_OR expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_BOOL_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 58:
-#line 161 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2238 "pcodeparse.cc" /* yacc.c:1646  */
+  case 58: /* expr: expr OP_FEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 59:
-#line 162 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2244 "pcodeparse.cc" /* yacc.c:1646  */
+  case 59: /* expr: expr OP_FNOTEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 60:
-#line 163 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2250 "pcodeparse.cc" /* yacc.c:1646  */
+  case 60: /* expr: expr OP_FLESS expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 61:
-#line 164 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2256 "pcodeparse.cc" /* yacc.c:1646  */
+  case 61: /* expr: expr OP_FGREAT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 62:
-#line 165 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2262 "pcodeparse.cc" /* yacc.c:1646  */
+  case 62: /* expr: expr OP_FLESSEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 63:
-#line 166 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 2268 "pcodeparse.cc" /* yacc.c:1646  */
+  case 63: /* expr: expr OP_FGREATEQUAL expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 64:
-#line 167 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2274 "pcodeparse.cc" /* yacc.c:1646  */
+  case 64: /* expr: expr OP_FADD expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 65:
-#line 168 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2280 "pcodeparse.cc" /* yacc.c:1646  */
+  case 65: /* expr: expr OP_FSUB expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 66:
-#line 169 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2286 "pcodeparse.cc" /* yacc.c:1646  */
+  case 66: /* expr: expr OP_FMULT expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 67:
-#line 170 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 2292 "pcodeparse.cc" /* yacc.c:1646  */
+  case 67: /* expr: expr OP_FDIV expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 68:
-#line 171 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NEG,(yyvsp[0].tree)); }
-#line 2298 "pcodeparse.cc" /* yacc.c:1646  */
+  case 68: /* expr: OP_FSUB expr  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NEG,(yyvsp[0].tree)); }
     break;
 
-  case 69:
-#line 172 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ABS,(yyvsp[-1].tree)); }
-#line 2304 "pcodeparse.cc" /* yacc.c:1646  */
+  case 69: /* expr: OP_ABS '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ABS,(yyvsp[-1].tree)); }
     break;
 
-  case 70:
-#line 173 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_SQRT,(yyvsp[-1].tree)); }
-#line 2310 "pcodeparse.cc" /* yacc.c:1646  */
+  case 70: /* expr: OP_SQRT '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_SQRT,(yyvsp[-1].tree)); }
     break;
 
-  case 71:
-#line 174 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SEXT,(yyvsp[-1].tree)); }
-#line 2316 "pcodeparse.cc" /* yacc.c:1646  */
+  case 71: /* expr: OP_SEXT '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_SEXT,(yyvsp[-1].tree)); }
     break;
 
-  case 72:
-#line 175 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_ZEXT,(yyvsp[-1].tree)); }
-#line 2322 "pcodeparse.cc" /* yacc.c:1646  */
+  case 72: /* expr: OP_ZEXT '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_INT_ZEXT,(yyvsp[-1].tree)); }
     break;
 
-  case 73:
-#line 176 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_CARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 2328 "pcodeparse.cc" /* yacc.c:1646  */
+  case 73: /* expr: OP_CARRY '(' expr ',' expr ')'  */
+                                   { (yyval.tree) = pcode->createOp(CPUI_INT_CARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 74:
-#line 177 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SCARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 2334 "pcodeparse.cc" /* yacc.c:1646  */
+  case 74: /* expr: OP_SCARRY '(' expr ',' expr ')'  */
+                                    { (yyval.tree) = pcode->createOp(CPUI_INT_SCARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 75:
-#line 178 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_INT_SBORROW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 2340 "pcodeparse.cc" /* yacc.c:1646  */
+  case 75: /* expr: OP_SBORROW '(' expr ',' expr ')'  */
+                                     { (yyval.tree) = pcode->createOp(CPUI_INT_SBORROW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 76:
-#line 179 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_FLOAT2FLOAT,(yyvsp[-1].tree)); }
-#line 2346 "pcodeparse.cc" /* yacc.c:1646  */
+  case 76: /* expr: OP_FLOAT2FLOAT '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_FLOAT2FLOAT,(yyvsp[-1].tree)); }
     break;
 
-  case 77:
-#line 180 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_INT2FLOAT,(yyvsp[-1].tree)); }
-#line 2352 "pcodeparse.cc" /* yacc.c:1646  */
+  case 77: /* expr: OP_INT2FLOAT '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_INT2FLOAT,(yyvsp[-1].tree)); }
     break;
 
-  case 78:
-#line 181 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NAN,(yyvsp[-1].tree)); }
-#line 2358 "pcodeparse.cc" /* yacc.c:1646  */
+  case 78: /* expr: OP_NAN '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_NAN,(yyvsp[-1].tree)); }
     break;
 
-  case 79:
-#line 182 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_TRUNC,(yyvsp[-1].tree)); }
-#line 2364 "pcodeparse.cc" /* yacc.c:1646  */
+  case 79: /* expr: OP_TRUNC '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_TRUNC,(yyvsp[-1].tree)); }
     break;
 
-  case 80:
-#line 183 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_CEIL,(yyvsp[-1].tree)); }
-#line 2370 "pcodeparse.cc" /* yacc.c:1646  */
+  case 80: /* expr: OP_CEIL '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_CEIL,(yyvsp[-1].tree)); }
     break;
 
-  case 81:
-#line 184 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_FLOOR,(yyvsp[-1].tree)); }
-#line 2376 "pcodeparse.cc" /* yacc.c:1646  */
+  case 81: /* expr: OP_FLOOR '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_FLOOR,(yyvsp[-1].tree)); }
     break;
 
-  case 82:
-#line 185 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ROUND,(yyvsp[-1].tree)); }
-#line 2382 "pcodeparse.cc" /* yacc.c:1646  */
+  case 82: /* expr: OP_ROUND '(' expr ')'  */
+                                { (yyval.tree) = pcode->createOp(CPUI_FLOAT_ROUND,(yyvsp[-1].tree)); }
     break;
 
-  case 83:
-#line 186 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_NEW,(yyvsp[-1].tree)); }
-#line 2388 "pcodeparse.cc" /* yacc.c:1646  */
+  case 83: /* expr: OP_NEW '(' expr ')'  */
+                            { (yyval.tree) = pcode->createOp(CPUI_NEW,(yyvsp[-1].tree)); }
     break;
 
-  case 84:
-#line 187 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_NEW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 2394 "pcodeparse.cc" /* yacc.c:1646  */
+  case 84: /* expr: OP_NEW '(' expr ',' expr ')'  */
+                                 { (yyval.tree) = pcode->createOp(CPUI_NEW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 85:
-#line 188 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createOp(CPUI_SUBPIECE,new ExprTree((yyvsp[-3].specsym)->getVarnode()),new ExprTree((yyvsp[-1].varnode))); }
-#line 2400 "pcodeparse.cc" /* yacc.c:1646  */
+  case 85: /* expr: specificsymbol '(' integervarnode ')'  */
+                                          { (yyval.tree) = pcode->createOp(CPUI_SUBPIECE,new ExprTree((yyvsp[-3].specsym)->getVarnode()),new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 86:
-#line 189 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createBitRange((yyvsp[-2].specsym),0,(uint4)(*(yyvsp[0].i) * 8)); delete (yyvsp[0].i); }
-#line 2406 "pcodeparse.cc" /* yacc.c:1646  */
+  case 86: /* expr: specificsymbol ':' INTEGER  */
+                                { (yyval.tree) = pcode->createBitRange((yyvsp[-2].specsym),0,(uint4)(*(yyvsp[0].i) * 8)); delete (yyvsp[0].i); }
     break;
 
-  case 87:
-#line 190 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createBitRange((yyvsp[-5].specsym),(uint4)*(yyvsp[-3].i),(uint4)*(yyvsp[-1].i)); delete (yyvsp[-3].i), delete (yyvsp[-1].i); }
-#line 2412 "pcodeparse.cc" /* yacc.c:1646  */
+  case 87: /* expr: specificsymbol '[' INTEGER ',' INTEGER ']'  */
+                                               { (yyval.tree) = pcode->createBitRange((yyvsp[-5].specsym),(uint4)*(yyvsp[-3].i),(uint4)*(yyvsp[-1].i)); delete (yyvsp[-3].i), delete (yyvsp[-1].i); }
     break;
 
-  case 88:
-#line 191 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = pcode->createUserOp((yyvsp[-3].useropsym),(yyvsp[-1].param)); }
-#line 2418 "pcodeparse.cc" /* yacc.c:1646  */
+  case 88: /* expr: USEROPSYM '(' paramlist ')'  */
+                                { (yyval.tree) = pcode->createUserOp((yyvsp[-3].useropsym),(yyvsp[-1].param)); }
     break;
 
-  case 89:
-#line 193 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl((yyvsp[-3].spacesym)->getSpace()); }
-#line 2424 "pcodeparse.cc" /* yacc.c:1646  */
+  case 89: /* sizedstar: '*' '[' SPACESYM ']' ':' INTEGER  */
+                                            { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl((yyvsp[-3].spacesym)->getSpace()); }
     break;
 
-  case 90:
-#line 194 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl((yyvsp[-1].spacesym)->getSpace()); }
-#line 2430 "pcodeparse.cc" /* yacc.c:1646  */
+  case 90: /* sizedstar: '*' '[' SPACESYM ']'  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl((yyvsp[-1].spacesym)->getSpace()); }
     break;
 
-  case 91:
-#line 195 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl(pcode->getDefaultSpace()); }
-#line 2436 "pcodeparse.cc" /* yacc.c:1646  */
+  case 91: /* sizedstar: '*' ':' INTEGER  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl(pcode->getDefaultSpace()); }
     break;
 
-  case 92:
-#line 196 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl(pcode->getDefaultSpace()); }
-#line 2442 "pcodeparse.cc" /* yacc.c:1646  */
+  case 92: /* sizedstar: '*'  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl(pcode->getDefaultSpace()); }
     break;
 
-  case 93:
-#line 198 "pcodeparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].startsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 2448 "pcodeparse.cc" /* yacc.c:1646  */
+  case 93: /* jumpdest: STARTSYM  */
+                                { VarnodeTpl *sym = (yyvsp[0].startsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 94:
-#line 199 "pcodeparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].endsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 2454 "pcodeparse.cc" /* yacc.c:1646  */
+  case 94: /* jumpdest: ENDSYM  */
+                                { VarnodeTpl *sym = (yyvsp[0].endsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 95:
-#line 200 "pcodeparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].next2sym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 2460 "pcodeparse.cc" /* yacc.c:1646  */
+  case 95: /* jumpdest: NEXT2SYM  */
+                        { VarnodeTpl *sym = (yyvsp[0].next2sym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 96:
-#line 201 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::j_curspace_size)); delete (yyvsp[0].i); }
-#line 2466 "pcodeparse.cc" /* yacc.c:1646  */
+  case 96: /* jumpdest: INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::j_curspace_size)); delete (yyvsp[0].i); }
     break;
 
-  case 97:
-#line 202 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::j_curspace_size)); yyerror("Parsed integer is too big (overflow)"); }
-#line 2472 "pcodeparse.cc" /* yacc.c:1646  */
+  case 97: /* jumpdest: BADINTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::j_curspace_size)); yyerror("Parsed integer is too big (overflow)"); }
     break;
 
-  case 98:
-#line 203 "pcodeparse.y" /* yacc.c:1646  */
-    { AddrSpace *spc = (yyvsp[-1].spacesym)->getSpace(); (yyval.varnode) = new VarnodeTpl(ConstTpl(spc),ConstTpl(ConstTpl::real,*(yyvsp[-3].i)),ConstTpl(ConstTpl::real,spc->getAddrSize())); delete (yyvsp[-3].i); }
-#line 2478 "pcodeparse.cc" /* yacc.c:1646  */
+  case 98: /* jumpdest: INTEGER '[' SPACESYM ']'  */
+                                { AddrSpace *spc = (yyvsp[-1].spacesym)->getSpace(); (yyval.varnode) = new VarnodeTpl(ConstTpl(spc),ConstTpl(ConstTpl::real,*(yyvsp[-3].i)),ConstTpl(ConstTpl::real,spc->getAddrSize())); delete (yyvsp[-3].i); }
     break;
 
-  case 99:
-#line 204 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::j_relative,(yyvsp[0].labelsym)->getIndex()),ConstTpl(ConstTpl::real,sizeof(uintm))); (yyvsp[0].labelsym)->incrementRefCount(); }
-#line 2484 "pcodeparse.cc" /* yacc.c:1646  */
+  case 99: /* jumpdest: label  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::j_relative,(yyvsp[0].labelsym)->getIndex()),ConstTpl(ConstTpl::real,sizeof(uintm))); (yyvsp[0].labelsym)->incrementRefCount(); }
     break;
 
-  case 100:
-#line 205 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown jump destination: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2490 "pcodeparse.cc" /* yacc.c:1646  */
+  case 100: /* jumpdest: STRING  */
+                                { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown jump destination: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 101:
-#line 207 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
-#line 2496 "pcodeparse.cc" /* yacc.c:1646  */
+  case 101: /* varnode: specificsymbol  */
+                                { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
     break;
 
-  case 102:
-#line 208 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].varnode); }
-#line 2502 "pcodeparse.cc" /* yacc.c:1646  */
+  case 102: /* varnode: integervarnode  */
+                                { (yyval.varnode) = (yyvsp[0].varnode); }
     break;
 
-  case 103:
-#line 209 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown varnode parameter: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2508 "pcodeparse.cc" /* yacc.c:1646  */
+  case 103: /* varnode: STRING  */
+                                { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown varnode parameter: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 104:
-#line 211 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::real,0)); delete (yyvsp[0].i); }
-#line 2514 "pcodeparse.cc" /* yacc.c:1646  */
+  case 104: /* integervarnode: INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::real,0)); delete (yyvsp[0].i); }
     break;
 
-  case 105:
-#line 212 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::real,0)); yyerror("Parsed integer is too big (overflow)"); }
-#line 2520 "pcodeparse.cc" /* yacc.c:1646  */
+  case 105: /* integervarnode: BADINTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::real,0)); yyerror("Parsed integer is too big (overflow)"); }
     break;
 
-  case 106:
-#line 213 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
-#line 2526 "pcodeparse.cc" /* yacc.c:1646  */
+  case 106: /* integervarnode: INTEGER ':' INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(pcode->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
     break;
 
-  case 107:
-#line 214 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = pcode->addressOf((yyvsp[0].varnode),0); }
-#line 2532 "pcodeparse.cc" /* yacc.c:1646  */
+  case 107: /* integervarnode: '&' varnode  */
+                                { (yyval.varnode) = pcode->addressOf((yyvsp[0].varnode),0); }
     break;
 
-  case 108:
-#line 215 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = pcode->addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 2538 "pcodeparse.cc" /* yacc.c:1646  */
+  case 108: /* integervarnode: '&' ':' INTEGER varnode  */
+                                { (yyval.varnode) = pcode->addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 109:
-#line 217 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
-#line 2544 "pcodeparse.cc" /* yacc.c:1646  */
+  case 109: /* lhsvarnode: specificsymbol  */
+                                { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
     break;
 
-  case 110:
-#line 218 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown assignment varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2550 "pcodeparse.cc" /* yacc.c:1646  */
+  case 110: /* lhsvarnode: STRING  */
+                                { (yyval.varnode) = (VarnodeTpl *)0; string errmsg = "Unknown assignment varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 111:
-#line 220 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.labelsym) = (yyvsp[-1].labelsym); }
-#line 2556 "pcodeparse.cc" /* yacc.c:1646  */
+  case 111: /* label: '<' LABELSYM '>'  */
+                                { (yyval.labelsym) = (yyvsp[-1].labelsym); }
     break;
 
-  case 112:
-#line 221 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.labelsym) = pcode->defineLabel( (yyvsp[-1].str) ); }
-#line 2562 "pcodeparse.cc" /* yacc.c:1646  */
+  case 112: /* label: '<' STRING '>'  */
+                                { (yyval.labelsym) = pcode->defineLabel( (yyvsp[-1].str) ); }
     break;
 
-  case 113:
-#line 223 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].varsym); }
-#line 2568 "pcodeparse.cc" /* yacc.c:1646  */
+  case 113: /* specificsymbol: VARSYM  */
+                                { (yyval.specsym) = (yyvsp[0].varsym); }
     break;
 
-  case 114:
-#line 224 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].operandsym); }
-#line 2574 "pcodeparse.cc" /* yacc.c:1646  */
+  case 114: /* specificsymbol: OPERANDSYM  */
+                                { (yyval.specsym) = (yyvsp[0].operandsym); }
     break;
 
-  case 115:
-#line 225 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].startsym); }
-#line 2580 "pcodeparse.cc" /* yacc.c:1646  */
+  case 115: /* specificsymbol: STARTSYM  */
+                                { (yyval.specsym) = (yyvsp[0].startsym); }
     break;
 
-  case 116:
-#line 226 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].endsym); }
-#line 2586 "pcodeparse.cc" /* yacc.c:1646  */
+  case 116: /* specificsymbol: ENDSYM  */
+                                { (yyval.specsym) = (yyvsp[0].endsym); }
     break;
 
-  case 117:
-#line 227 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].next2sym); }
-#line 2592 "pcodeparse.cc" /* yacc.c:1646  */
+  case 117: /* specificsymbol: NEXT2SYM  */
+                                { (yyval.specsym) = (yyvsp[0].next2sym); }
     break;
 
-  case 118:
-#line 229 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.param) = new vector<ExprTree *>; }
-#line 2598 "pcodeparse.cc" /* yacc.c:1646  */
+  case 118: /* paramlist: %empty  */
+                                { (yyval.param) = new vector<ExprTree *>; }
     break;
 
-  case 119:
-#line 230 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.param) = new vector<ExprTree *>; (yyval.param)->push_back((yyvsp[0].tree)); }
-#line 2604 "pcodeparse.cc" /* yacc.c:1646  */
+  case 119: /* paramlist: expr  */
+                                { (yyval.param) = new vector<ExprTree *>; (yyval.param)->push_back((yyvsp[0].tree)); }
     break;
 
-  case 120:
-#line 231 "pcodeparse.y" /* yacc.c:1646  */
-    { (yyval.param) = (yyvsp[-2].param); (yyval.param)->push_back((yyvsp[0].tree)); }
-#line 2610 "pcodeparse.cc" /* yacc.c:1646  */
+  case 120: /* paramlist: paramlist ',' expr  */
+                                { (yyval.param) = (yyvsp[-2].param); (yyval.param)->push_back((yyvsp[0].tree)); }
     break;
 
 
-#line 2614 "pcodeparse.cc" /* yacc.c:1646  */
+
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -2639,25 +2407,23 @@ yyreduce:
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
@@ -2668,50 +2434,14 @@ yyreduce:
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
     }
 
-
-
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -2740,12 +2470,11 @@ yyerrlab:
 | yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
 yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
 
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
@@ -2762,13 +2491,14 @@ yyerrorlab:
 yyerrlab1:
   yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
@@ -2782,7 +2512,7 @@ yyerrlab1:
 
 
       yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp);
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -2794,7 +2524,7 @@ yyerrlab1:
 
 
   /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -2805,26 +2535,30 @@ yyerrlab1:
 `-------------------------------------*/
 yyacceptlab:
   yyresult = 0;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
 /*-----------------------------------.
 | yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
 yyabortlab:
   yyresult = 1;
-  goto yyreturn;
+  goto yyreturnlab;
 
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
+
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
 yyexhaustedlab:
   yyerror (YY_("memory exhausted"));
   yyresult = 2;
-  /* Fall through.  */
-#endif
+  goto yyreturnlab;
+
 
-yyreturn:
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
   if (yychar != YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
@@ -2840,20 +2574,17 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp);
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
+
   return yyresult;
 }
-#line 233 "pcodeparse.y" /* yacc.c:1906  */
+
 
 
 #define IDENTREC_SIZE 46
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
index c858fa148..a77fd3371 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
@@ -14,6 +14,15 @@
  * limitations under the License.
  */
 %{
+/* Substitute the variable and function names.  */
+#define yyparse         pcodeparse
+#define yylex           pcodelex
+#define yyerror         pcodeerror
+#define yydebug         pcodedebug
+#define yynerrs         pcodenerrs
+#define yylval          pcodelval
+#define yychar          pcodechar
+
 #include "pcodeparse.hh"
 
   //#define YYERROR_VERBOSE
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
index 746d70a81..fe40d59a6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
@@ -1,23 +1,9 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -48,6 +34,10 @@
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
@@ -55,11 +45,11 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Identify Bison output.  */
-#define YYBISON 1
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30802
 
-/* Bison version.  */
-#define YYBISON_VERSION "3.0.4"
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -76,8 +66,7 @@
 
 
 
-/* Copy the first part of user declarations.  */
-#line 16 "slghparse.y" /* yacc.c:339  */
+/* First part of user prologue.  */
 
 #include "slgh_compile.hh"
 
@@ -90,251 +79,333 @@
   extern int yylex(void);
   extern int yyerror(const char *str );
 
-#line 79 "slghparse.cc" /* yacc.c:339  */
 
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
 # ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
 #  else
-#   define YY_NULLPTR 0
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* In a future release of Bison, this section will be replaced
-   by #include "slghparse.hh".  */
-#ifndef YY_YY_SLGHPARSE_HH_INCLUDED
-# define YY_YY_SLGHPARSE_HH_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int yydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    OP_BOOL_OR = 258,
-    OP_BOOL_AND = 259,
-    OP_BOOL_XOR = 260,
-    OP_OR = 261,
-    OP_XOR = 262,
-    OP_AND = 263,
-    OP_EQUAL = 264,
-    OP_NOTEQUAL = 265,
-    OP_FEQUAL = 266,
-    OP_FNOTEQUAL = 267,
-    OP_GREATEQUAL = 268,
-    OP_LESSEQUAL = 269,
-    OP_SLESS = 270,
-    OP_SGREATEQUAL = 271,
-    OP_SLESSEQUAL = 272,
-    OP_SGREAT = 273,
-    OP_FLESS = 274,
-    OP_FGREAT = 275,
-    OP_FLESSEQUAL = 276,
-    OP_FGREATEQUAL = 277,
-    OP_LEFT = 278,
-    OP_RIGHT = 279,
-    OP_SRIGHT = 280,
-    OP_FADD = 281,
-    OP_FSUB = 282,
-    OP_SDIV = 283,
-    OP_SREM = 284,
-    OP_FMULT = 285,
-    OP_FDIV = 286,
-    OP_ZEXT = 287,
-    OP_CARRY = 288,
-    OP_BORROW = 289,
-    OP_SEXT = 290,
-    OP_SCARRY = 291,
-    OP_SBORROW = 292,
-    OP_NAN = 293,
-    OP_ABS = 294,
-    OP_SQRT = 295,
-    OP_CEIL = 296,
-    OP_FLOOR = 297,
-    OP_ROUND = 298,
-    OP_INT2FLOAT = 299,
-    OP_FLOAT2FLOAT = 300,
-    OP_TRUNC = 301,
-    OP_CPOOLREF = 302,
-    OP_NEW = 303,
-    OP_POPCOUNT = 304,
-    BADINTEGER = 305,
-    GOTO_KEY = 306,
-    CALL_KEY = 307,
-    RETURN_KEY = 308,
-    IF_KEY = 309,
-    DEFINE_KEY = 310,
-    ATTACH_KEY = 311,
-    MACRO_KEY = 312,
-    SPACE_KEY = 313,
-    TYPE_KEY = 314,
-    RAM_KEY = 315,
-    DEFAULT_KEY = 316,
-    REGISTER_KEY = 317,
-    ENDIAN_KEY = 318,
-    WITH_KEY = 319,
-    ALIGN_KEY = 320,
-    OP_UNIMPL = 321,
-    TOKEN_KEY = 322,
-    SIGNED_KEY = 323,
-    NOFLOW_KEY = 324,
-    HEX_KEY = 325,
-    DEC_KEY = 326,
-    BIG_KEY = 327,
-    LITTLE_KEY = 328,
-    SIZE_KEY = 329,
-    WORDSIZE_KEY = 330,
-    OFFSET_KEY = 331,
-    NAMES_KEY = 332,
-    VALUES_KEY = 333,
-    VARIABLES_KEY = 334,
-    PCODEOP_KEY = 335,
-    IS_KEY = 336,
-    LOCAL_KEY = 337,
-    DELAYSLOT_KEY = 338,
-    CROSSBUILD_KEY = 339,
-    EXPORT_KEY = 340,
-    BUILD_KEY = 341,
-    CONTEXT_KEY = 342,
-    ELLIPSIS_KEY = 343,
-    GLOBALSET_KEY = 344,
-    BITRANGE_KEY = 345,
-    CHAR = 346,
-    INTEGER = 347,
-    INTB = 348,
-    STRING = 349,
-    SYMBOLSTRING = 350,
-    SPACESYM = 351,
-    SECTIONSYM = 352,
-    TOKENSYM = 353,
-    USEROPSYM = 354,
-    VALUESYM = 355,
-    VALUEMAPSYM = 356,
-    CONTEXTSYM = 357,
-    NAMESYM = 358,
-    VARSYM = 359,
-    BITSYM = 360,
-    SPECSYM = 361,
-    VARLISTSYM = 362,
-    OPERANDSYM = 363,
-    STARTSYM = 364,
-    ENDSYM = 365,
-    NEXT2SYM = 366,
-    MACROSYM = 367,
-    LABELSYM = 368,
-    SUBTABLESYM = 369
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
-union YYSTYPE
+#include "slghparse.hh"
+/* Symbol kind.  */
+enum yysymbol_kind_t
 {
-#line 29 "slghparse.y" /* yacc.c:355  */
-
-  char ch;
-  uintb *i;
-  intb *big;
-  string *str;
-  vector<string> *strlist;
-  vector<intb> *biglist;
-  vector<ExprTree *> *param;
-  SpaceQuality *spacequal;
-  FieldQuality *fieldqual;
-  StarQuality *starqual;
-  VarnodeTpl *varnode;
-  ExprTree *tree;
-  vector<OpTpl *> *stmt;
-  ConstructTpl *sem;
-  SectionVector *sectionstart;
-  Constructor *construct;
-  PatternEquation *pateq;
-  PatternExpression *patexp;
-
-  vector<SleighSymbol *> *symlist;
-  vector<ContextChange *> *contop;
-  SleighSymbol *anysym;
-  SpaceSymbol *spacesym;
-  SectionSymbol *sectionsym;
-  TokenSymbol *tokensym;
-  UserOpSymbol *useropsym;
-  MacroSymbol *macrosym;
-  LabelSymbol *labelsym;
-  SubtableSymbol *subtablesym;
-  StartSymbol *startsym;
-  EndSymbol *endsym;
-  Next2Symbol *next2sym;
-  OperandSymbol *operandsym;
-  VarnodeListSymbol *varlistsym;
-  VarnodeSymbol *varsym;
-  BitrangeSymbol *bitsym;
-  NameSymbol *namesym;
-  ValueSymbol *valuesym;
-  ValueMapSymbol *valuemapsym;
-  ContextSymbol *contextsym;
-  FamilySymbol *famsym;
-  SpecificSymbol *specsym;
-
-#line 279 "slghparse.cc" /* yacc.c:355  */
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_OP_BOOL_OR = 3,                 /* OP_BOOL_OR  */
+  YYSYMBOL_OP_BOOL_AND = 4,                /* OP_BOOL_AND  */
+  YYSYMBOL_OP_BOOL_XOR = 5,                /* OP_BOOL_XOR  */
+  YYSYMBOL_6_ = 6,                         /* '|'  */
+  YYSYMBOL_OP_OR = 7,                      /* OP_OR  */
+  YYSYMBOL_8_ = 8,                         /* ';'  */
+  YYSYMBOL_9_ = 9,                         /* '^'  */
+  YYSYMBOL_OP_XOR = 10,                    /* OP_XOR  */
+  YYSYMBOL_11_ = 11,                       /* '&'  */
+  YYSYMBOL_OP_AND = 12,                    /* OP_AND  */
+  YYSYMBOL_OP_EQUAL = 13,                  /* OP_EQUAL  */
+  YYSYMBOL_OP_NOTEQUAL = 14,               /* OP_NOTEQUAL  */
+  YYSYMBOL_OP_FEQUAL = 15,                 /* OP_FEQUAL  */
+  YYSYMBOL_OP_FNOTEQUAL = 16,              /* OP_FNOTEQUAL  */
+  YYSYMBOL_17_ = 17,                       /* '<'  */
+  YYSYMBOL_18_ = 18,                       /* '>'  */
+  YYSYMBOL_OP_GREATEQUAL = 19,             /* OP_GREATEQUAL  */
+  YYSYMBOL_OP_LESSEQUAL = 20,              /* OP_LESSEQUAL  */
+  YYSYMBOL_OP_SLESS = 21,                  /* OP_SLESS  */
+  YYSYMBOL_OP_SGREATEQUAL = 22,            /* OP_SGREATEQUAL  */
+  YYSYMBOL_OP_SLESSEQUAL = 23,             /* OP_SLESSEQUAL  */
+  YYSYMBOL_OP_SGREAT = 24,                 /* OP_SGREAT  */
+  YYSYMBOL_OP_FLESS = 25,                  /* OP_FLESS  */
+  YYSYMBOL_OP_FGREAT = 26,                 /* OP_FGREAT  */
+  YYSYMBOL_OP_FLESSEQUAL = 27,             /* OP_FLESSEQUAL  */
+  YYSYMBOL_OP_FGREATEQUAL = 28,            /* OP_FGREATEQUAL  */
+  YYSYMBOL_OP_LEFT = 29,                   /* OP_LEFT  */
+  YYSYMBOL_OP_RIGHT = 30,                  /* OP_RIGHT  */
+  YYSYMBOL_OP_SRIGHT = 31,                 /* OP_SRIGHT  */
+  YYSYMBOL_32_ = 32,                       /* '+'  */
+  YYSYMBOL_33_ = 33,                       /* '-'  */
+  YYSYMBOL_OP_FADD = 34,                   /* OP_FADD  */
+  YYSYMBOL_OP_FSUB = 35,                   /* OP_FSUB  */
+  YYSYMBOL_36_ = 36,                       /* '*'  */
+  YYSYMBOL_37_ = 37,                       /* '/'  */
+  YYSYMBOL_38_ = 38,                       /* '%'  */
+  YYSYMBOL_OP_SDIV = 39,                   /* OP_SDIV  */
+  YYSYMBOL_OP_SREM = 40,                   /* OP_SREM  */
+  YYSYMBOL_OP_FMULT = 41,                  /* OP_FMULT  */
+  YYSYMBOL_OP_FDIV = 42,                   /* OP_FDIV  */
+  YYSYMBOL_43_ = 43,                       /* '!'  */
+  YYSYMBOL_44_ = 44,                       /* '~'  */
+  YYSYMBOL_OP_ZEXT = 45,                   /* OP_ZEXT  */
+  YYSYMBOL_OP_CARRY = 46,                  /* OP_CARRY  */
+  YYSYMBOL_OP_BORROW = 47,                 /* OP_BORROW  */
+  YYSYMBOL_OP_SEXT = 48,                   /* OP_SEXT  */
+  YYSYMBOL_OP_SCARRY = 49,                 /* OP_SCARRY  */
+  YYSYMBOL_OP_SBORROW = 50,                /* OP_SBORROW  */
+  YYSYMBOL_OP_NAN = 51,                    /* OP_NAN  */
+  YYSYMBOL_OP_ABS = 52,                    /* OP_ABS  */
+  YYSYMBOL_OP_SQRT = 53,                   /* OP_SQRT  */
+  YYSYMBOL_OP_CEIL = 54,                   /* OP_CEIL  */
+  YYSYMBOL_OP_FLOOR = 55,                  /* OP_FLOOR  */
+  YYSYMBOL_OP_ROUND = 56,                  /* OP_ROUND  */
+  YYSYMBOL_OP_INT2FLOAT = 57,              /* OP_INT2FLOAT  */
+  YYSYMBOL_OP_FLOAT2FLOAT = 58,            /* OP_FLOAT2FLOAT  */
+  YYSYMBOL_OP_TRUNC = 59,                  /* OP_TRUNC  */
+  YYSYMBOL_OP_CPOOLREF = 60,               /* OP_CPOOLREF  */
+  YYSYMBOL_OP_NEW = 61,                    /* OP_NEW  */
+  YYSYMBOL_OP_POPCOUNT = 62,               /* OP_POPCOUNT  */
+  YYSYMBOL_BADINTEGER = 63,                /* BADINTEGER  */
+  YYSYMBOL_GOTO_KEY = 64,                  /* GOTO_KEY  */
+  YYSYMBOL_CALL_KEY = 65,                  /* CALL_KEY  */
+  YYSYMBOL_RETURN_KEY = 66,                /* RETURN_KEY  */
+  YYSYMBOL_IF_KEY = 67,                    /* IF_KEY  */
+  YYSYMBOL_DEFINE_KEY = 68,                /* DEFINE_KEY  */
+  YYSYMBOL_ATTACH_KEY = 69,                /* ATTACH_KEY  */
+  YYSYMBOL_MACRO_KEY = 70,                 /* MACRO_KEY  */
+  YYSYMBOL_SPACE_KEY = 71,                 /* SPACE_KEY  */
+  YYSYMBOL_TYPE_KEY = 72,                  /* TYPE_KEY  */
+  YYSYMBOL_RAM_KEY = 73,                   /* RAM_KEY  */
+  YYSYMBOL_DEFAULT_KEY = 74,               /* DEFAULT_KEY  */
+  YYSYMBOL_REGISTER_KEY = 75,              /* REGISTER_KEY  */
+  YYSYMBOL_ENDIAN_KEY = 76,                /* ENDIAN_KEY  */
+  YYSYMBOL_WITH_KEY = 77,                  /* WITH_KEY  */
+  YYSYMBOL_ALIGN_KEY = 78,                 /* ALIGN_KEY  */
+  YYSYMBOL_OP_UNIMPL = 79,                 /* OP_UNIMPL  */
+  YYSYMBOL_TOKEN_KEY = 80,                 /* TOKEN_KEY  */
+  YYSYMBOL_SIGNED_KEY = 81,                /* SIGNED_KEY  */
+  YYSYMBOL_NOFLOW_KEY = 82,                /* NOFLOW_KEY  */
+  YYSYMBOL_HEX_KEY = 83,                   /* HEX_KEY  */
+  YYSYMBOL_DEC_KEY = 84,                   /* DEC_KEY  */
+  YYSYMBOL_BIG_KEY = 85,                   /* BIG_KEY  */
+  YYSYMBOL_LITTLE_KEY = 86,                /* LITTLE_KEY  */
+  YYSYMBOL_SIZE_KEY = 87,                  /* SIZE_KEY  */
+  YYSYMBOL_WORDSIZE_KEY = 88,              /* WORDSIZE_KEY  */
+  YYSYMBOL_OFFSET_KEY = 89,                /* OFFSET_KEY  */
+  YYSYMBOL_NAMES_KEY = 90,                 /* NAMES_KEY  */
+  YYSYMBOL_VALUES_KEY = 91,                /* VALUES_KEY  */
+  YYSYMBOL_VARIABLES_KEY = 92,             /* VARIABLES_KEY  */
+  YYSYMBOL_PCODEOP_KEY = 93,               /* PCODEOP_KEY  */
+  YYSYMBOL_IS_KEY = 94,                    /* IS_KEY  */
+  YYSYMBOL_LOCAL_KEY = 95,                 /* LOCAL_KEY  */
+  YYSYMBOL_DELAYSLOT_KEY = 96,             /* DELAYSLOT_KEY  */
+  YYSYMBOL_CROSSBUILD_KEY = 97,            /* CROSSBUILD_KEY  */
+  YYSYMBOL_EXPORT_KEY = 98,                /* EXPORT_KEY  */
+  YYSYMBOL_BUILD_KEY = 99,                 /* BUILD_KEY  */
+  YYSYMBOL_CONTEXT_KEY = 100,              /* CONTEXT_KEY  */
+  YYSYMBOL_ELLIPSIS_KEY = 101,             /* ELLIPSIS_KEY  */
+  YYSYMBOL_GLOBALSET_KEY = 102,            /* GLOBALSET_KEY  */
+  YYSYMBOL_BITRANGE_KEY = 103,             /* BITRANGE_KEY  */
+  YYSYMBOL_CHAR = 104,                     /* CHAR  */
+  YYSYMBOL_INTEGER = 105,                  /* INTEGER  */
+  YYSYMBOL_INTB = 106,                     /* INTB  */
+  YYSYMBOL_STRING = 107,                   /* STRING  */
+  YYSYMBOL_SYMBOLSTRING = 108,             /* SYMBOLSTRING  */
+  YYSYMBOL_SPACESYM = 109,                 /* SPACESYM  */
+  YYSYMBOL_SECTIONSYM = 110,               /* SECTIONSYM  */
+  YYSYMBOL_TOKENSYM = 111,                 /* TOKENSYM  */
+  YYSYMBOL_USEROPSYM = 112,                /* USEROPSYM  */
+  YYSYMBOL_VALUESYM = 113,                 /* VALUESYM  */
+  YYSYMBOL_VALUEMAPSYM = 114,              /* VALUEMAPSYM  */
+  YYSYMBOL_CONTEXTSYM = 115,               /* CONTEXTSYM  */
+  YYSYMBOL_NAMESYM = 116,                  /* NAMESYM  */
+  YYSYMBOL_VARSYM = 117,                   /* VARSYM  */
+  YYSYMBOL_BITSYM = 118,                   /* BITSYM  */
+  YYSYMBOL_SPECSYM = 119,                  /* SPECSYM  */
+  YYSYMBOL_VARLISTSYM = 120,               /* VARLISTSYM  */
+  YYSYMBOL_OPERANDSYM = 121,               /* OPERANDSYM  */
+  YYSYMBOL_STARTSYM = 122,                 /* STARTSYM  */
+  YYSYMBOL_ENDSYM = 123,                   /* ENDSYM  */
+  YYSYMBOL_NEXT2SYM = 124,                 /* NEXT2SYM  */
+  YYSYMBOL_MACROSYM = 125,                 /* MACROSYM  */
+  YYSYMBOL_LABELSYM = 126,                 /* LABELSYM  */
+  YYSYMBOL_SUBTABLESYM = 127,              /* SUBTABLESYM  */
+  YYSYMBOL_128_ = 128,                     /* '}'  */
+  YYSYMBOL_129_ = 129,                     /* '='  */
+  YYSYMBOL_130_ = 130,                     /* '('  */
+  YYSYMBOL_131_ = 131,                     /* ')'  */
+  YYSYMBOL_132_ = 132,                     /* ','  */
+  YYSYMBOL_133_ = 133,                     /* '['  */
+  YYSYMBOL_134_ = 134,                     /* ']'  */
+  YYSYMBOL_135_ = 135,                     /* '{'  */
+  YYSYMBOL_136_ = 136,                     /* ':'  */
+  YYSYMBOL_137_ = 137,                     /* ' '  */
+  YYSYMBOL_YYACCEPT = 138,                 /* $accept  */
+  YYSYMBOL_spec = 139,                     /* spec  */
+  YYSYMBOL_definition = 140,               /* definition  */
+  YYSYMBOL_constructorlike = 141,          /* constructorlike  */
+  YYSYMBOL_endiandef = 142,                /* endiandef  */
+  YYSYMBOL_aligndef = 143,                 /* aligndef  */
+  YYSYMBOL_tokendef = 144,                 /* tokendef  */
+  YYSYMBOL_tokenprop = 145,                /* tokenprop  */
+  YYSYMBOL_contextdef = 146,               /* contextdef  */
+  YYSYMBOL_contextprop = 147,              /* contextprop  */
+  YYSYMBOL_fielddef = 148,                 /* fielddef  */
+  YYSYMBOL_contextfielddef = 149,          /* contextfielddef  */
+  YYSYMBOL_spacedef = 150,                 /* spacedef  */
+  YYSYMBOL_spaceprop = 151,                /* spaceprop  */
+  YYSYMBOL_varnodedef = 152,               /* varnodedef  */
+  YYSYMBOL_bitrangedef = 153,              /* bitrangedef  */
+  YYSYMBOL_bitrangelist = 154,             /* bitrangelist  */
+  YYSYMBOL_bitrangesingle = 155,           /* bitrangesingle  */
+  YYSYMBOL_pcodeopdef = 156,               /* pcodeopdef  */
+  YYSYMBOL_valueattach = 157,              /* valueattach  */
+  YYSYMBOL_nameattach = 158,               /* nameattach  */
+  YYSYMBOL_varattach = 159,                /* varattach  */
+  YYSYMBOL_macrodef = 160,                 /* macrodef  */
+  YYSYMBOL_withblockstart = 161,           /* withblockstart  */
+  YYSYMBOL_withblockmid = 162,             /* withblockmid  */
+  YYSYMBOL_withblock = 163,                /* withblock  */
+  YYSYMBOL_id_or_nil = 164,                /* id_or_nil  */
+  YYSYMBOL_bitpat_or_nil = 165,            /* bitpat_or_nil  */
+  YYSYMBOL_macrostart = 166,               /* macrostart  */
+  YYSYMBOL_rtlbody = 167,                  /* rtlbody  */
+  YYSYMBOL_constructor = 168,              /* constructor  */
+  YYSYMBOL_constructprint = 169,           /* constructprint  */
+  YYSYMBOL_subtablestart = 170,            /* subtablestart  */
+  YYSYMBOL_pexpression = 171,              /* pexpression  */
+  YYSYMBOL_pequation = 172,                /* pequation  */
+  YYSYMBOL_elleq = 173,                    /* elleq  */
+  YYSYMBOL_ellrt = 174,                    /* ellrt  */
+  YYSYMBOL_atomic = 175,                   /* atomic  */
+  YYSYMBOL_constraint = 176,               /* constraint  */
+  YYSYMBOL_contextblock = 177,             /* contextblock  */
+  YYSYMBOL_contextlist = 178,              /* contextlist  */
+  YYSYMBOL_section_def = 179,              /* section_def  */
+  YYSYMBOL_rtlfirstsection = 180,          /* rtlfirstsection  */
+  YYSYMBOL_rtlcontinue = 181,              /* rtlcontinue  */
+  YYSYMBOL_rtl = 182,                      /* rtl  */
+  YYSYMBOL_rtlmid = 183,                   /* rtlmid  */
+  YYSYMBOL_statement = 184,                /* statement  */
+  YYSYMBOL_expr = 185,                     /* expr  */
+  YYSYMBOL_sizedstar = 186,                /* sizedstar  */
+  YYSYMBOL_jumpdest = 187,                 /* jumpdest  */
+  YYSYMBOL_varnode = 188,                  /* varnode  */
+  YYSYMBOL_integervarnode = 189,           /* integervarnode  */
+  YYSYMBOL_lhsvarnode = 190,               /* lhsvarnode  */
+  YYSYMBOL_label = 191,                    /* label  */
+  YYSYMBOL_exportvarnode = 192,            /* exportvarnode  */
+  YYSYMBOL_familysymbol = 193,             /* familysymbol  */
+  YYSYMBOL_specificsymbol = 194,           /* specificsymbol  */
+  YYSYMBOL_charstring = 195,               /* charstring  */
+  YYSYMBOL_intblist = 196,                 /* intblist  */
+  YYSYMBOL_intbpart = 197,                 /* intbpart  */
+  YYSYMBOL_stringlist = 198,               /* stringlist  */
+  YYSYMBOL_stringpart = 199,               /* stringpart  */
+  YYSYMBOL_anystringlist = 200,            /* anystringlist  */
+  YYSYMBOL_anystringpart = 201,            /* anystringpart  */
+  YYSYMBOL_valuelist = 202,                /* valuelist  */
+  YYSYMBOL_valuepart = 203,                /* valuepart  */
+  YYSYMBOL_varlist = 204,                  /* varlist  */
+  YYSYMBOL_varpart = 205,                  /* varpart  */
+  YYSYMBOL_paramlist = 206,                /* paramlist  */
+  YYSYMBOL_oplist = 207,                   /* oplist  */
+  YYSYMBOL_anysymbol = 208                 /* anysymbol  */
 };
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
-typedef union YYSTYPE YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
 
 
-extern YYSTYPE yylval;
 
-int yyparse (void);
+#ifdef short
+# undef short
+#endif
 
-#endif /* !YY_YY_SLGHPARSE_HH_INCLUDED  */
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
 
-/* Copy the second part of user declarations.  */
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
+#endif
 
-#line 296 "slghparse.cc" /* yacc.c:358  */
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
 
-#ifdef short
-# undef short
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
+#else
+typedef signed char yytype_int8;
 #endif
 
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
 #else
-typedef unsigned char yytype_uint8;
+typedef short yytype_int16;
 #endif
 
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#else
-typedef signed char yytype_int8;
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
 #endif
 
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
 #else
-typedef unsigned short int yytype_uint16;
+typedef short yytype_uint8;
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
 #else
-typedef short int yytype_int16;
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
 #endif
 
 #ifndef YYSIZE_T
@@ -342,15 +413,28 @@ typedef short int yytype_int16;
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
-#  define YYSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_int16 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
 #ifndef YY_
 # if defined YYENABLE_NLS && YYENABLE_NLS
@@ -364,47 +448,43 @@ typedef short int yytype_int16;
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
 
 #ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
 #endif
 
 #ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
+# define YY_USE(E) ((void) (E))
 #else
-# define YYUSE(E) /* empty */
+# define YY_USE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
 /* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
 # define YY_INITIAL_VALUE(Value) Value
@@ -417,8 +497,22 @@ typedef short int yytype_int16;
 # define YY_INITIAL_VALUE(Value) /* Nothing. */
 #endif
 
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
 
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -483,8 +577,7 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
@@ -493,17 +586,17 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
+  yy_state_t yyss_alloc;
   YYSTYPE yyvs_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 # define YYCOPY_NEEDED 1
@@ -516,11 +609,11 @@ union yyalloc
 # define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
+        YYPTRDIFF_T yynewbytes;                                         \
         YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
         Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
@@ -532,12 +625,12 @@ union yyalloc
 # ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
 #   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          YYSIZE_T yyi;                         \
+          YYPTRDIFF_T yyi;                      \
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
@@ -560,16 +653,19 @@ union yyalloc
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  716
 
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
-#define YYUNDEFTOK  2
+/* YYMAXUTOK -- Last valid token kind.  */
 #define YYMAXUTOK   369
 
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
+   as returned by yylex.  */
 static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -612,8 +708,8 @@ static const yytype_uint8 yytranslate[] =
 };
 
 #if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_int16 yyrline[] =
 {
        0,   158,   158,   159,   160,   161,   163,   164,   165,   166,
      167,   168,   169,   170,   171,   172,   174,   175,   176,   177,
@@ -653,36 +749,43 @@ static const yytype_uint16 yyrline[] =
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 0
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "OP_BOOL_OR", "OP_BOOL_AND",
-  "OP_BOOL_XOR", "'|'", "OP_OR", "';'", "'^'", "OP_XOR", "'&'", "OP_AND",
-  "OP_EQUAL", "OP_NOTEQUAL", "OP_FEQUAL", "OP_FNOTEQUAL", "'<'", "'>'",
-  "OP_GREATEQUAL", "OP_LESSEQUAL", "OP_SLESS", "OP_SGREATEQUAL",
-  "OP_SLESSEQUAL", "OP_SGREAT", "OP_FLESS", "OP_FGREAT", "OP_FLESSEQUAL",
-  "OP_FGREATEQUAL", "OP_LEFT", "OP_RIGHT", "OP_SRIGHT", "'+'", "'-'",
-  "OP_FADD", "OP_FSUB", "'*'", "'/'", "'%'", "OP_SDIV", "OP_SREM",
-  "OP_FMULT", "OP_FDIV", "'!'", "'~'", "OP_ZEXT", "OP_CARRY", "OP_BORROW",
-  "OP_SEXT", "OP_SCARRY", "OP_SBORROW", "OP_NAN", "OP_ABS", "OP_SQRT",
-  "OP_CEIL", "OP_FLOOR", "OP_ROUND", "OP_INT2FLOAT", "OP_FLOAT2FLOAT",
-  "OP_TRUNC", "OP_CPOOLREF", "OP_NEW", "OP_POPCOUNT", "BADINTEGER",
-  "GOTO_KEY", "CALL_KEY", "RETURN_KEY", "IF_KEY", "DEFINE_KEY",
-  "ATTACH_KEY", "MACRO_KEY", "SPACE_KEY", "TYPE_KEY", "RAM_KEY",
-  "DEFAULT_KEY", "REGISTER_KEY", "ENDIAN_KEY", "WITH_KEY", "ALIGN_KEY",
-  "OP_UNIMPL", "TOKEN_KEY", "SIGNED_KEY", "NOFLOW_KEY", "HEX_KEY",
-  "DEC_KEY", "BIG_KEY", "LITTLE_KEY", "SIZE_KEY", "WORDSIZE_KEY",
-  "OFFSET_KEY", "NAMES_KEY", "VALUES_KEY", "VARIABLES_KEY", "PCODEOP_KEY",
-  "IS_KEY", "LOCAL_KEY", "DELAYSLOT_KEY", "CROSSBUILD_KEY", "EXPORT_KEY",
-  "BUILD_KEY", "CONTEXT_KEY", "ELLIPSIS_KEY", "GLOBALSET_KEY",
-  "BITRANGE_KEY", "CHAR", "INTEGER", "INTB", "STRING", "SYMBOLSTRING",
-  "SPACESYM", "SECTIONSYM", "TOKENSYM", "USEROPSYM", "VALUESYM",
-  "VALUEMAPSYM", "CONTEXTSYM", "NAMESYM", "VARSYM", "BITSYM", "SPECSYM",
-  "VARLISTSYM", "OPERANDSYM", "STARTSYM", "ENDSYM", "NEXT2SYM", "MACROSYM",
-  "LABELSYM", "SUBTABLESYM", "'}'", "'='", "'('", "')'", "','", "'['",
-  "']'", "'{'", "':'", "' '", "$accept", "spec", "definition",
+  "\"end of file\"", "error", "\"invalid token\"", "OP_BOOL_OR",
+  "OP_BOOL_AND", "OP_BOOL_XOR", "'|'", "OP_OR", "';'", "'^'", "OP_XOR",
+  "'&'", "OP_AND", "OP_EQUAL", "OP_NOTEQUAL", "OP_FEQUAL", "OP_FNOTEQUAL",
+  "'<'", "'>'", "OP_GREATEQUAL", "OP_LESSEQUAL", "OP_SLESS",
+  "OP_SGREATEQUAL", "OP_SLESSEQUAL", "OP_SGREAT", "OP_FLESS", "OP_FGREAT",
+  "OP_FLESSEQUAL", "OP_FGREATEQUAL", "OP_LEFT", "OP_RIGHT", "OP_SRIGHT",
+  "'+'", "'-'", "OP_FADD", "OP_FSUB", "'*'", "'/'", "'%'", "OP_SDIV",
+  "OP_SREM", "OP_FMULT", "OP_FDIV", "'!'", "'~'", "OP_ZEXT", "OP_CARRY",
+  "OP_BORROW", "OP_SEXT", "OP_SCARRY", "OP_SBORROW", "OP_NAN", "OP_ABS",
+  "OP_SQRT", "OP_CEIL", "OP_FLOOR", "OP_ROUND", "OP_INT2FLOAT",
+  "OP_FLOAT2FLOAT", "OP_TRUNC", "OP_CPOOLREF", "OP_NEW", "OP_POPCOUNT",
+  "BADINTEGER", "GOTO_KEY", "CALL_KEY", "RETURN_KEY", "IF_KEY",
+  "DEFINE_KEY", "ATTACH_KEY", "MACRO_KEY", "SPACE_KEY", "TYPE_KEY",
+  "RAM_KEY", "DEFAULT_KEY", "REGISTER_KEY", "ENDIAN_KEY", "WITH_KEY",
+  "ALIGN_KEY", "OP_UNIMPL", "TOKEN_KEY", "SIGNED_KEY", "NOFLOW_KEY",
+  "HEX_KEY", "DEC_KEY", "BIG_KEY", "LITTLE_KEY", "SIZE_KEY",
+  "WORDSIZE_KEY", "OFFSET_KEY", "NAMES_KEY", "VALUES_KEY", "VARIABLES_KEY",
+  "PCODEOP_KEY", "IS_KEY", "LOCAL_KEY", "DELAYSLOT_KEY", "CROSSBUILD_KEY",
+  "EXPORT_KEY", "BUILD_KEY", "CONTEXT_KEY", "ELLIPSIS_KEY",
+  "GLOBALSET_KEY", "BITRANGE_KEY", "CHAR", "INTEGER", "INTB", "STRING",
+  "SYMBOLSTRING", "SPACESYM", "SECTIONSYM", "TOKENSYM", "USEROPSYM",
+  "VALUESYM", "VALUEMAPSYM", "CONTEXTSYM", "NAMESYM", "VARSYM", "BITSYM",
+  "SPECSYM", "VARLISTSYM", "OPERANDSYM", "STARTSYM", "ENDSYM", "NEXT2SYM",
+  "MACROSYM", "LABELSYM", "SUBTABLESYM", "'}'", "'='", "'('", "')'", "','",
+  "'['", "']'", "'{'", "':'", "' '", "$accept", "spec", "definition",
   "constructorlike", "endiandef", "aligndef", "tokendef", "tokenprop",
   "contextdef", "contextprop", "fielddef", "contextfielddef", "spacedef",
   "spaceprop", "varnodedef", "bitrangedef", "bitrangelist",
@@ -698,42 +801,26 @@ static const char *const yytname[] =
   "stringpart", "anystringlist", "anystringpart", "valuelist", "valuepart",
   "varlist", "varpart", "paramlist", "oplist", "anysymbol", YY_NULLPTR
 };
-#endif
 
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
 {
-       0,   256,   257,   258,   259,   260,   124,   261,    59,    94,
-     262,    38,   263,   264,   265,   266,   267,    60,    62,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   277,   278,
-     279,   280,    43,    45,   281,   282,    42,    47,    37,   283,
-     284,   285,   286,    33,   126,   287,   288,   289,   290,   291,
-     292,   293,   294,   295,   296,   297,   298,   299,   300,   301,
-     302,   303,   304,   305,   306,   307,   308,   309,   310,   311,
-     312,   313,   314,   315,   316,   317,   318,   319,   320,   321,
-     322,   323,   324,   325,   326,   327,   328,   329,   330,   331,
-     332,   333,   334,   335,   336,   337,   338,   339,   340,   341,
-     342,   343,   344,   345,   346,   347,   348,   349,   350,   351,
-     352,   353,   354,   355,   356,   357,   358,   359,   360,   361,
-     362,   363,   364,   365,   366,   367,   368,   369,   125,    61,
-      40,    41,    44,    91,    93,   123,    58,    32
-};
-# endif
+  return yytname[yysymbol];
+}
+#endif
 
-#define YYPACT_NINF -316
+#define YYPACT_NINF (-316)
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-316)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define YYTABLE_NINF -272
+#define YYTABLE_NINF (-272)
 
-#define yytable_value_is_error(Yytable_value) \
-  (!!((Yytable_value) == (-272)))
+#define yytable_value_is_error(Yyn) \
+  ((Yyn) == YYTABLE_NINF)
 
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
      -39,   -23,     8,  -316,   -41,  -316,     2,    88,   245,     0,
@@ -810,10 +897,10 @@ static const yytype_int16 yypact[] =
     2154,  1585,  1586,  -316,  -316,  -316
 };
 
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint16 yydefact[] =
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_int16 yydefact[] =
 {
        0,     0,     0,     2,     0,     1,     0,     0,     0,     0,
       67,     0,     0,    89,     4,     5,     3,     6,     0,     7,
@@ -889,7 +976,7 @@ static const yytype_uint16 yydefact[] =
        0,     0,     0,   157,   131,   132
 };
 
-  /* YYPGOTO[NTERM-NUM].  */
+/* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
     -316,  -316,  1564,  1565,  -316,  -316,  -316,  -316,  -316,  -316,
@@ -902,10 +989,10 @@ static const yytype_int16 yypgoto[] =
        7
 };
 
-  /* YYDEFGOTO[NTERM-NUM].  */
+/* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int16 yydefgoto[] =
 {
-      -1,     2,    14,    15,     3,    16,    17,    18,    19,    20,
+       0,     2,    14,    15,     3,    16,    17,    18,    19,    20,
       75,    79,    21,    22,    23,    24,   116,   117,    25,    26,
       27,    28,    29,    30,    31,    32,    53,   186,    33,   366,
       34,    35,    36,   356,   153,   154,   155,   156,   157,   236,
@@ -915,9 +1002,9 @@ static const yytype_int16 yydefgoto[] =
       76
 };
 
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
      158,   223,   227,   197,   298,   325,   251,   158,     5,     6,
@@ -1450,8 +1537,8 @@ static const yytype_int16 yycheck[] =
       35,    36,    37,    38,    39,    40,    41,    42
 };
 
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
 static const yytype_uint8 yystos[] =
 {
        0,    68,   139,   142,    76,     0,     1,    68,    69,    70,
@@ -1528,7 +1615,7 @@ static const yytype_uint8 yystos[] =
      185,   131,   131,     8,     8,     8
 };
 
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
 static const yytype_uint8 yyr1[] =
 {
        0,   138,   139,   139,   139,   139,   140,   140,   140,   140,
@@ -1568,8 +1655,8 @@ static const yytype_uint8 yyr1[] =
      208,   208
 };
 
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
 {
        0,     2,     1,     2,     2,     2,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     2,     1,     1,     1,     2,
@@ -1609,39 +1696,39 @@ static const yytype_uint8 yyr2[] =
 };
 
 
+enum { YYENOMEM = -2 };
+
 #define yyerrok         (yyerrstatus = 0)
 #define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
 
 #define YYACCEPT        goto yyacceptlab
 #define YYABORT         goto yyabortlab
 #define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
 
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
 
 
 /* Enable debugging if requested.  */
@@ -1658,55 +1745,52 @@ do {                                            \
     YYFPRINTF Args;                             \
 } while (0)
 
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
 
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
   if (yydebug)                                                            \
     {                                                                     \
       YYFPRINTF (stderr, "%s ", Title);                                   \
       yy_symbol_print (stderr,                                            \
-                  Type, Value); \
+                  Kind, Value); \
       YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
   if (!yyvaluep)
     return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  YYFPRINTF (yyoutput, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
+  yy_symbol_value_print (yyo, yykind, yyvaluep);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
@@ -1715,7 +1799,7 @@ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
 `------------------------------------------------------------------*/
 
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -1738,21 +1822,21 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule)
 {
-  unsigned long int yylno = yyrline[yyrule];
+  int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
              yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
-                                              );
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)]);
       YYFPRINTF (stderr, "\n");
     }
 }
@@ -1767,8 +1851,8 @@ do {                                    \
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1791,249 +1875,30 @@ int yydebug;
 #endif
 
 
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
 
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
 {
-  YYUSE (yyvaluep);
+  YY_USE (yyvaluep);
   if (!yymsg)
     yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
+  YY_USE (yykind);
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-
-
-/* The lookahead symbol.  */
+/* Lookahead token kind.  */
 int yychar;
 
 /* The semantic value of the lookahead symbol.  */
@@ -2042,6 +1907,8 @@ YYSTYPE yylval;
 int yynerrs;
 
 
+
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -2049,43 +1916,36 @@ int yynerrs;
 int
 yyparse (void)
 {
-    int yystate;
+    yy_state_fast_t yystate = 0;
     /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
+    int yyerrstatus = 0;
 
-       Refer to the stacks through separate pointers, to allow yyoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-    YYSIZE_T yystacksize;
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
   int yyn;
+  /* The return value of yyparse.  */
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
@@ -2093,71 +1953,75 @@ yyparse (void)
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
+
   goto yysetstate;
 
+
 /*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- yynewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
- yysetstate:
-  *yyssp = yystate;
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
 
   if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef yyoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
+        yy_state_t *yyss1 = yyss;
         YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
 
         /* Each stack pointer address is followed by the size of the
            data in use in that stack, in bytes.  This used to be a
            conditional around just the two extra args, but that might
            be undefined if yyoverflow is a macro.  */
         yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                     &yystacksize);
-
         yyss = yyss1;
         yyvs = yyvs1;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
+        YYNOMEM;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
 
       {
-        yytype_int16 *yyss1 = yyss;
+        yy_state_t *yyss1 = yyss;
         union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
         if (! yyptr)
-          goto yyexhaustedlab;
+          YYNOMEM;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
@@ -2165,30 +2029,31 @@ yyparse (void)
           YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no yyoverflow */
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
+
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
-
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
@@ -2199,18 +2064,29 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF ((stderr, "Reading a token\n"));
       yychar = yylex ();
     }
 
   if (yychar <= YYEOF)
     {
-      yychar = yytoken = YYEOF;
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
+    }
   else
     {
       yytoken = YYTRANSLATE (yychar);
@@ -2238,15 +2114,13 @@ yybackup:
 
   /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
 
@@ -2261,7 +2135,7 @@ yydefault:
 
 
 /*-----------------------------.
-| yyreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
@@ -2281,1896 +2155,1270 @@ yyreduce:
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-        case 19:
-#line 177 "slghparse.y" /* yacc.c:1646  */
-    { slgh->resetConstructors(); }
-#line 2273 "slghparse.cc" /* yacc.c:1646  */
+  case 19: /* constructorlike: error '}'  */
+                                       { slgh->resetConstructors(); }
     break;
 
-  case 20:
-#line 179 "slghparse.y" /* yacc.c:1646  */
-    { slgh->setEndian(1); }
-#line 2279 "slghparse.cc" /* yacc.c:1646  */
+  case 20: /* endiandef: DEFINE_KEY ENDIAN_KEY '=' BIG_KEY ';'  */
+                                                 { slgh->setEndian(1); }
     break;
 
-  case 21:
-#line 180 "slghparse.y" /* yacc.c:1646  */
-    { slgh->setEndian(0); }
-#line 2285 "slghparse.cc" /* yacc.c:1646  */
+  case 21: /* endiandef: DEFINE_KEY ENDIAN_KEY '=' LITTLE_KEY ';'  */
+                                             { slgh->setEndian(0); }
     break;
 
-  case 22:
-#line 182 "slghparse.y" /* yacc.c:1646  */
-    { slgh->setAlignment(*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 2291 "slghparse.cc" /* yacc.c:1646  */
+  case 22: /* aligndef: DEFINE_KEY ALIGN_KEY '=' INTEGER ';'  */
+                                               { slgh->setAlignment(*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 23:
-#line 184 "slghparse.y" /* yacc.c:1646  */
-    {}
-#line 2297 "slghparse.cc" /* yacc.c:1646  */
+  case 23: /* tokendef: tokenprop ';'  */
+                                       {}
     break;
 
-  case 24:
-#line 186 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tokensym) = slgh->defineToken((yyvsp[-3].str),(yyvsp[-1].i),0); }
-#line 2303 "slghparse.cc" /* yacc.c:1646  */
+  case 24: /* tokenprop: DEFINE_KEY TOKEN_KEY STRING '(' INTEGER ')'  */
+                                                       { (yyval.tokensym) = slgh->defineToken((yyvsp[-3].str),(yyvsp[-1].i),0); }
     break;
 
-  case 25:
-#line 187 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tokensym) = slgh->defineToken((yyvsp[-6].str),(yyvsp[-4].i),-1); }
-#line 2309 "slghparse.cc" /* yacc.c:1646  */
+  case 25: /* tokenprop: DEFINE_KEY TOKEN_KEY STRING '(' INTEGER ')' ENDIAN_KEY '=' LITTLE_KEY  */
+                                                                          { (yyval.tokensym) = slgh->defineToken((yyvsp[-6].str),(yyvsp[-4].i),-1); }
     break;
 
-  case 26:
-#line 188 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tokensym) = slgh->defineToken((yyvsp[-6].str),(yyvsp[-4].i),1); }
-#line 2315 "slghparse.cc" /* yacc.c:1646  */
+  case 26: /* tokenprop: DEFINE_KEY TOKEN_KEY STRING '(' INTEGER ')' ENDIAN_KEY '=' BIG_KEY  */
+                                                                       { (yyval.tokensym) = slgh->defineToken((yyvsp[-6].str),(yyvsp[-4].i),1); }
     break;
 
-  case 27:
-#line 189 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tokensym) = (yyvsp[-1].tokensym); slgh->addTokenField((yyvsp[-1].tokensym),(yyvsp[0].fieldqual)); }
-#line 2321 "slghparse.cc" /* yacc.c:1646  */
+  case 27: /* tokenprop: tokenprop fielddef  */
+                                       { (yyval.tokensym) = (yyvsp[-1].tokensym); slgh->addTokenField((yyvsp[-1].tokensym),(yyvsp[0].fieldqual)); }
     break;
 
-  case 28:
-#line 190 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg=(yyvsp[0].anysym)->getName()+": redefined as a token"; yyerror(errmsg.c_str()); YYERROR; }
-#line 2327 "slghparse.cc" /* yacc.c:1646  */
+  case 28: /* tokenprop: DEFINE_KEY TOKEN_KEY anysymbol  */
+                                       { string errmsg=(yyvsp[0].anysym)->getName()+": redefined as a token"; yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 29:
-#line 192 "slghparse.y" /* yacc.c:1646  */
-    {}
-#line 2333 "slghparse.cc" /* yacc.c:1646  */
+  case 29: /* contextdef: contextprop ';'  */
+                                       {}
     break;
 
-  case 30:
-#line 194 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varsym) = (yyvsp[0].varsym); }
-#line 2339 "slghparse.cc" /* yacc.c:1646  */
+  case 30: /* contextprop: DEFINE_KEY CONTEXT_KEY VARSYM  */
+                                           { (yyval.varsym) = (yyvsp[0].varsym); }
     break;
 
-  case 31:
-#line 195 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varsym) = (yyvsp[-1].varsym); if (!slgh->addContextField( (yyvsp[-1].varsym), (yyvsp[0].fieldqual) ))
+  case 31: /* contextprop: contextprop contextfielddef  */
+                                         { (yyval.varsym) = (yyvsp[-1].varsym); if (!slgh->addContextField( (yyvsp[-1].varsym), (yyvsp[0].fieldqual) ))
                                             { yyerror("All context definitions must come before constructors"); YYERROR; } }
-#line 2346 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 32:
-#line 198 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = new FieldQuality((yyvsp[-6].str),(yyvsp[-3].i),(yyvsp[-1].i)); }
-#line 2352 "slghparse.cc" /* yacc.c:1646  */
+  case 32: /* fielddef: STRING '=' '(' INTEGER ',' INTEGER ')'  */
+                                                 { (yyval.fieldqual) = new FieldQuality((yyvsp[-6].str),(yyvsp[-3].i),(yyvsp[-1].i)); }
     break;
 
-  case 33:
-#line 199 "slghparse.y" /* yacc.c:1646  */
-    { delete (yyvsp[-3].i); delete (yyvsp[-1].i); string errmsg = (yyvsp[-6].anysym)->getName()+": redefined as field"; yyerror(errmsg.c_str()); YYERROR; }
-#line 2358 "slghparse.cc" /* yacc.c:1646  */
+  case 33: /* fielddef: anysymbol '=' '(' INTEGER ',' INTEGER ')'  */
+                                              { delete (yyvsp[-3].i); delete (yyvsp[-1].i); string errmsg = (yyvsp[-6].anysym)->getName()+": redefined as field"; yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 34:
-#line 200 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->signext = true; }
-#line 2364 "slghparse.cc" /* yacc.c:1646  */
+  case 34: /* fielddef: fielddef SIGNED_KEY  */
+                                        { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->signext = true; }
     break;
 
-  case 35:
-#line 201 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = true; }
-#line 2370 "slghparse.cc" /* yacc.c:1646  */
+  case 35: /* fielddef: fielddef HEX_KEY  */
+                                        { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = true; }
     break;
 
-  case 36:
-#line 202 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = false; }
-#line 2376 "slghparse.cc" /* yacc.c:1646  */
+  case 36: /* fielddef: fielddef DEC_KEY  */
+                                        { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = false; }
     break;
 
-  case 37:
-#line 204 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = new FieldQuality((yyvsp[-6].str),(yyvsp[-3].i),(yyvsp[-1].i)); }
-#line 2382 "slghparse.cc" /* yacc.c:1646  */
+  case 37: /* contextfielddef: STRING '=' '(' INTEGER ',' INTEGER ')'  */
+                                                        { (yyval.fieldqual) = new FieldQuality((yyvsp[-6].str),(yyvsp[-3].i),(yyvsp[-1].i)); }
     break;
 
-  case 38:
-#line 205 "slghparse.y" /* yacc.c:1646  */
-    { delete (yyvsp[-3].i); delete (yyvsp[-1].i); string errmsg = (yyvsp[-6].anysym)->getName()+": redefined as field"; yyerror(errmsg.c_str()); YYERROR; }
-#line 2388 "slghparse.cc" /* yacc.c:1646  */
+  case 38: /* contextfielddef: anysymbol '=' '(' INTEGER ',' INTEGER ')'  */
+                                              { delete (yyvsp[-3].i); delete (yyvsp[-1].i); string errmsg = (yyvsp[-6].anysym)->getName()+": redefined as field"; yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 39:
-#line 206 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->signext = true; }
-#line 2394 "slghparse.cc" /* yacc.c:1646  */
+  case 39: /* contextfielddef: contextfielddef SIGNED_KEY  */
+                                                { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->signext = true; }
     break;
 
-  case 40:
-#line 207 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->flow = false; }
-#line 2400 "slghparse.cc" /* yacc.c:1646  */
+  case 40: /* contextfielddef: contextfielddef NOFLOW_KEY  */
+                                                { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->flow = false; }
     break;
 
-  case 41:
-#line 208 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = true; }
-#line 2406 "slghparse.cc" /* yacc.c:1646  */
+  case 41: /* contextfielddef: contextfielddef HEX_KEY  */
+                                                { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = true; }
     break;
 
-  case 42:
-#line 209 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = false; }
-#line 2412 "slghparse.cc" /* yacc.c:1646  */
+  case 42: /* contextfielddef: contextfielddef DEC_KEY  */
+                                                { (yyval.fieldqual) = (yyvsp[-1].fieldqual); (yyval.fieldqual)->hex = false; }
     break;
 
-  case 43:
-#line 211 "slghparse.y" /* yacc.c:1646  */
-    { slgh->newSpace((yyvsp[-1].spacequal)); }
-#line 2418 "slghparse.cc" /* yacc.c:1646  */
+  case 43: /* spacedef: spaceprop ';'  */
+                                        { slgh->newSpace((yyvsp[-1].spacequal)); }
     break;
 
-  case 44:
-#line 213 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = new SpaceQuality(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 2424 "slghparse.cc" /* yacc.c:1646  */
+  case 44: /* spaceprop: DEFINE_KEY SPACE_KEY STRING  */
+                                        { (yyval.spacequal) = new SpaceQuality(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 45:
-#line 214 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = (yyvsp[0].anysym)->getName()+": redefined as space"; yyerror(errmsg.c_str()); YYERROR; }
-#line 2430 "slghparse.cc" /* yacc.c:1646  */
+  case 45: /* spaceprop: DEFINE_KEY SPACE_KEY anysymbol  */
+                                        { string errmsg = (yyvsp[0].anysym)->getName()+": redefined as space"; yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 46:
-#line 215 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->type = SpaceQuality::ramtype; }
-#line 2436 "slghparse.cc" /* yacc.c:1646  */
+  case 46: /* spaceprop: spaceprop TYPE_KEY '=' RAM_KEY  */
+                                        { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->type = SpaceQuality::ramtype; }
     break;
 
-  case 47:
-#line 216 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->type = SpaceQuality::registertype; }
-#line 2442 "slghparse.cc" /* yacc.c:1646  */
+  case 47: /* spaceprop: spaceprop TYPE_KEY '=' REGISTER_KEY  */
+                                        { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->type = SpaceQuality::registertype; }
     break;
 
-  case 48:
-#line 217 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->size = *(yyvsp[0].i); delete (yyvsp[0].i); }
-#line 2448 "slghparse.cc" /* yacc.c:1646  */
+  case 48: /* spaceprop: spaceprop SIZE_KEY '=' INTEGER  */
+                                        { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->size = *(yyvsp[0].i); delete (yyvsp[0].i); }
     break;
 
-  case 49:
-#line 218 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->wordsize = *(yyvsp[0].i); delete (yyvsp[0].i); }
-#line 2454 "slghparse.cc" /* yacc.c:1646  */
+  case 49: /* spaceprop: spaceprop WORDSIZE_KEY '=' INTEGER  */
+                                        { (yyval.spacequal) = (yyvsp[-3].spacequal); (yyval.spacequal)->wordsize = *(yyvsp[0].i); delete (yyvsp[0].i); }
     break;
 
-  case 50:
-#line 219 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.spacequal) = (yyvsp[-1].spacequal); (yyval.spacequal)->isdefault = true; }
-#line 2460 "slghparse.cc" /* yacc.c:1646  */
+  case 50: /* spaceprop: spaceprop DEFAULT_KEY  */
+                                        { (yyval.spacequal) = (yyvsp[-1].spacequal); (yyval.spacequal)->isdefault = true; }
     break;
 
-  case 51:
-#line 221 "slghparse.y" /* yacc.c:1646  */
-    {
+  case 51: /* varnodedef: DEFINE_KEY SPACESYM OFFSET_KEY '=' INTEGER SIZE_KEY '=' INTEGER stringlist ';'  */
+                                                                                           {
                slgh->defineVarnodes((yyvsp[-8].spacesym),(yyvsp[-5].i),(yyvsp[-2].i),(yyvsp[-1].strlist)); }
-#line 2467 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 52:
-#line 223 "slghparse.y" /* yacc.c:1646  */
-    { yyerror("Parsed integer is too big (overflow)"); YYERROR; }
-#line 2473 "slghparse.cc" /* yacc.c:1646  */
+  case 52: /* varnodedef: DEFINE_KEY SPACESYM OFFSET_KEY '=' BADINTEGER  */
+                                                  { yyerror("Parsed integer is too big (overflow)"); YYERROR; }
     break;
 
-  case 56:
-#line 230 "slghparse.y" /* yacc.c:1646  */
-    {
+  case 56: /* bitrangesingle: STRING '=' VARSYM '[' INTEGER ',' INTEGER ']'  */
+                                                              {
                slgh->defineBitrange((yyvsp[-7].str),(yyvsp[-5].varsym),(uint4)*(yyvsp[-3].i),(uint4)*(yyvsp[-1].i)); delete (yyvsp[-3].i); delete (yyvsp[-1].i); }
-#line 2480 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 57:
-#line 233 "slghparse.y" /* yacc.c:1646  */
-    { slgh->addUserOp((yyvsp[-1].strlist)); }
-#line 2486 "slghparse.cc" /* yacc.c:1646  */
+  case 57: /* pcodeopdef: DEFINE_KEY PCODEOP_KEY stringlist ';'  */
+                                                  { slgh->addUserOp((yyvsp[-1].strlist)); }
     break;
 
-  case 58:
-#line 235 "slghparse.y" /* yacc.c:1646  */
-    { slgh->attachValues((yyvsp[-2].symlist),(yyvsp[-1].biglist)); }
-#line 2492 "slghparse.cc" /* yacc.c:1646  */
+  case 58: /* valueattach: ATTACH_KEY VALUES_KEY valuelist intblist ';'  */
+                                                          { slgh->attachValues((yyvsp[-2].symlist),(yyvsp[-1].biglist)); }
     break;
 
-  case 59:
-#line 237 "slghparse.y" /* yacc.c:1646  */
-    { slgh->attachNames((yyvsp[-2].symlist),(yyvsp[-1].strlist)); }
-#line 2498 "slghparse.cc" /* yacc.c:1646  */
+  case 59: /* nameattach: ATTACH_KEY NAMES_KEY valuelist anystringlist ';'  */
+                                                             { slgh->attachNames((yyvsp[-2].symlist),(yyvsp[-1].strlist)); }
     break;
 
-  case 60:
-#line 239 "slghparse.y" /* yacc.c:1646  */
-    { slgh->attachVarnodes((yyvsp[-2].symlist),(yyvsp[-1].symlist)); }
-#line 2504 "slghparse.cc" /* yacc.c:1646  */
+  case 60: /* varattach: ATTACH_KEY VARIABLES_KEY valuelist varlist ';'  */
+                                                          { slgh->attachVarnodes((yyvsp[-2].symlist),(yyvsp[-1].symlist)); }
     break;
 
-  case 61:
-#line 241 "slghparse.y" /* yacc.c:1646  */
-    { slgh->buildMacro((yyvsp[-3].macrosym),(yyvsp[-1].sem)); }
-#line 2510 "slghparse.cc" /* yacc.c:1646  */
+  case 61: /* macrodef: macrostart '{' rtl '}'  */
+                                        { slgh->buildMacro((yyvsp[-3].macrosym),(yyvsp[-1].sem)); }
     break;
 
-  case 62:
-#line 244 "slghparse.y" /* yacc.c:1646  */
-    {  slgh->pushWith((yyvsp[-4].subtablesym),(yyvsp[-2].pateq),(yyvsp[-1].contop)); }
-#line 2516 "slghparse.cc" /* yacc.c:1646  */
+  case 62: /* withblockstart: WITH_KEY id_or_nil ':' bitpat_or_nil contextblock '{'  */
+                                                                       {  slgh->pushWith((yyvsp[-4].subtablesym),(yyvsp[-2].pateq),(yyvsp[-1].contop)); }
     break;
 
-  case 66:
-#line 250 "slghparse.y" /* yacc.c:1646  */
-    { slgh->popWith(); }
-#line 2522 "slghparse.cc" /* yacc.c:1646  */
+  case 66: /* withblock: withblockmid '}'  */
+                             { slgh->popWith(); }
     break;
 
-  case 67:
-#line 252 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.subtablesym) = (SubtableSymbol *)0; }
-#line 2528 "slghparse.cc" /* yacc.c:1646  */
+  case 67: /* id_or_nil: %empty  */
+                        { (yyval.subtablesym) = (SubtableSymbol *)0; }
     break;
 
-  case 68:
-#line 253 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.subtablesym) = (yyvsp[0].subtablesym); }
-#line 2534 "slghparse.cc" /* yacc.c:1646  */
+  case 68: /* id_or_nil: SUBTABLESYM  */
+                        { (yyval.subtablesym) = (yyvsp[0].subtablesym); }
     break;
 
-  case 69:
-#line 254 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.subtablesym) = slgh->newTable((yyvsp[0].str)); }
-#line 2540 "slghparse.cc" /* yacc.c:1646  */
+  case 69: /* id_or_nil: STRING  */
+                        { (yyval.subtablesym) = slgh->newTable((yyvsp[0].str)); }
     break;
 
-  case 70:
-#line 257 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = (PatternEquation *)0; }
-#line 2546 "slghparse.cc" /* yacc.c:1646  */
+  case 70: /* bitpat_or_nil: %empty  */
+                           { (yyval.pateq) = (PatternEquation *)0; }
     break;
 
-  case 71:
-#line 258 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = (yyvsp[0].pateq); }
-#line 2552 "slghparse.cc" /* yacc.c:1646  */
+  case 71: /* bitpat_or_nil: pequation  */
+                           { (yyval.pateq) = (yyvsp[0].pateq); }
     break;
 
-  case 72:
-#line 261 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.macrosym) = slgh->createMacro((yyvsp[-3].str),(yyvsp[-1].strlist)); }
-#line 2558 "slghparse.cc" /* yacc.c:1646  */
+  case 72: /* macrostart: MACRO_KEY STRING '(' oplist ')'  */
+                                            { (yyval.macrosym) = slgh->createMacro((yyvsp[-3].str),(yyvsp[-1].strlist)); }
     break;
 
-  case 73:
-#line 263 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = slgh->standaloneSection((yyvsp[-1].sem)); }
-#line 2564 "slghparse.cc" /* yacc.c:1646  */
+  case 73: /* rtlbody: '{' rtl '}'  */
+                     { (yyval.sectionstart) = slgh->standaloneSection((yyvsp[-1].sem)); }
     break;
 
-  case 74:
-#line 264 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = slgh->finalNamedSection((yyvsp[-2].sectionstart),(yyvsp[-1].sem)); }
-#line 2570 "slghparse.cc" /* yacc.c:1646  */
+  case 74: /* rtlbody: '{' rtlcontinue rtlmid '}'  */
+                               { (yyval.sectionstart) = slgh->finalNamedSection((yyvsp[-2].sectionstart),(yyvsp[-1].sem)); }
     break;
 
-  case 75:
-#line 265 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = (SectionVector *)0; }
-#line 2576 "slghparse.cc" /* yacc.c:1646  */
+  case 75: /* rtlbody: OP_UNIMPL  */
+                     { (yyval.sectionstart) = (SectionVector *)0; }
     break;
 
-  case 76:
-#line 267 "slghparse.y" /* yacc.c:1646  */
-    { slgh->buildConstructor((yyvsp[-4].construct),(yyvsp[-2].pateq),(yyvsp[-1].contop),(yyvsp[0].sectionstart)); }
-#line 2582 "slghparse.cc" /* yacc.c:1646  */
+  case 76: /* constructor: constructprint IS_KEY pequation contextblock rtlbody  */
+                                                                  { slgh->buildConstructor((yyvsp[-4].construct),(yyvsp[-2].pateq),(yyvsp[-1].contop),(yyvsp[0].sectionstart)); }
     break;
 
-  case 77:
-#line 268 "slghparse.y" /* yacc.c:1646  */
-    { slgh->buildConstructor((yyvsp[-4].construct),(yyvsp[-2].pateq),(yyvsp[-1].contop),(yyvsp[0].sectionstart)); }
-#line 2588 "slghparse.cc" /* yacc.c:1646  */
+  case 77: /* constructor: subtablestart IS_KEY pequation contextblock rtlbody  */
+                                                                  { slgh->buildConstructor((yyvsp[-4].construct),(yyvsp[-2].pateq),(yyvsp[-1].contop),(yyvsp[0].sectionstart)); }
     break;
 
-  case 78:
-#line 270 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 2594 "slghparse.cc" /* yacc.c:1646  */
+  case 78: /* constructprint: subtablestart STRING  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 79:
-#line 271 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 2600 "slghparse.cc" /* yacc.c:1646  */
+  case 79: /* constructprint: subtablestart charstring  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 80:
-#line 272 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); if (slgh->isInRoot((yyvsp[-1].construct))) { (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); } else slgh->newOperand((yyvsp[-1].construct),(yyvsp[0].str)); }
-#line 2606 "slghparse.cc" /* yacc.c:1646  */
+  case 80: /* constructprint: subtablestart SYMBOLSTRING  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); if (slgh->isInRoot((yyvsp[-1].construct))) { (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); } else slgh->newOperand((yyvsp[-1].construct),(yyvsp[0].str)); }
     break;
 
-  case 81:
-#line 273 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); if (!slgh->isInRoot((yyvsp[-1].construct))) { yyerror("Unexpected '^' at start of print pieces");  YYERROR; } }
-#line 2612 "slghparse.cc" /* yacc.c:1646  */
+  case 81: /* constructprint: subtablestart '^'  */
+                                                { (yyval.construct) = (yyvsp[-1].construct); if (!slgh->isInRoot((yyvsp[-1].construct))) { yyerror("Unexpected '^' at start of print pieces");  YYERROR; } }
     break;
 
-  case 82:
-#line 274 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); }
-#line 2618 "slghparse.cc" /* yacc.c:1646  */
+  case 82: /* constructprint: constructprint '^'  */
+                                                { (yyval.construct) = (yyvsp[-1].construct); }
     break;
 
-  case 83:
-#line 275 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 2624 "slghparse.cc" /* yacc.c:1646  */
+  case 83: /* constructprint: constructprint STRING  */
+                                                { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 84:
-#line 276 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 2630 "slghparse.cc" /* yacc.c:1646  */
+  case 84: /* constructprint: constructprint charstring  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 85:
-#line 277 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(string(" ")); }
-#line 2636 "slghparse.cc" /* yacc.c:1646  */
+  case 85: /* constructprint: constructprint ' '  */
+                                                { (yyval.construct) = (yyvsp[-1].construct); (yyval.construct)->addSyntax(string(" ")); }
     break;
 
-  case 86:
-#line 278 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); slgh->newOperand((yyvsp[-1].construct),(yyvsp[0].str)); }
-#line 2642 "slghparse.cc" /* yacc.c:1646  */
+  case 86: /* constructprint: constructprint SYMBOLSTRING  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); slgh->newOperand((yyvsp[-1].construct),(yyvsp[0].str)); }
     break;
 
-  case 87:
-#line 280 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = slgh->createConstructor((yyvsp[-1].subtablesym)); }
-#line 2648 "slghparse.cc" /* yacc.c:1646  */
+  case 87: /* subtablestart: SUBTABLESYM ':'  */
+                                { (yyval.construct) = slgh->createConstructor((yyvsp[-1].subtablesym)); }
     break;
 
-  case 88:
-#line 281 "slghparse.y" /* yacc.c:1646  */
-    { SubtableSymbol *sym=slgh->newTable((yyvsp[-1].str)); (yyval.construct) = slgh->createConstructor(sym); }
-#line 2654 "slghparse.cc" /* yacc.c:1646  */
+  case 88: /* subtablestart: STRING ':'  */
+                                                { SubtableSymbol *sym=slgh->newTable((yyvsp[-1].str)); (yyval.construct) = slgh->createConstructor(sym); }
     break;
 
-  case 89:
-#line 282 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = slgh->createConstructor((SubtableSymbol *)0); }
-#line 2660 "slghparse.cc" /* yacc.c:1646  */
+  case 89: /* subtablestart: ':'  */
+                                                        { (yyval.construct) = slgh->createConstructor((SubtableSymbol *)0); }
     break;
 
-  case 90:
-#line 283 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.construct) = (yyvsp[-1].construct); }
-#line 2666 "slghparse.cc" /* yacc.c:1646  */
+  case 90: /* subtablestart: subtablestart ' '  */
+                                        { (yyval.construct) = (yyvsp[-1].construct); }
     break;
 
-  case 91:
-#line 285 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new ConstantValue(*(yyvsp[0].big)); delete (yyvsp[0].big); }
-#line 2672 "slghparse.cc" /* yacc.c:1646  */
+  case 91: /* pexpression: INTB  */
+                                        { (yyval.patexp) = new ConstantValue(*(yyvsp[0].big)); delete (yyvsp[0].big); }
     break;
 
-  case 92:
-#line 287 "slghparse.y" /* yacc.c:1646  */
-    { if ((actionon==1)&&((yyvsp[0].famsym)->getType() != SleighSymbol::context_symbol))
+  case 92: /* pexpression: familysymbol  */
+                                        { if ((actionon==1)&&((yyvsp[0].famsym)->getType() != SleighSymbol::context_symbol))
                                              { string errmsg="Global symbol "+(yyvsp[0].famsym)->getName(); errmsg += " is not allowed in action expression"; yyerror(errmsg.c_str()); } (yyval.patexp) = (yyvsp[0].famsym)->getPatternValue(); }
-#line 2679 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 93:
-#line 290 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = (yyvsp[0].specsym)->getPatternExpression(); }
-#line 2685 "slghparse.cc" /* yacc.c:1646  */
+  case 93: /* pexpression: specificsymbol  */
+                                        { (yyval.patexp) = (yyvsp[0].specsym)->getPatternExpression(); }
     break;
 
-  case 94:
-#line 291 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = (yyvsp[-1].patexp); }
-#line 2691 "slghparse.cc" /* yacc.c:1646  */
+  case 94: /* pexpression: '(' pexpression ')'  */
+                                        { (yyval.patexp) = (yyvsp[-1].patexp); }
     break;
 
-  case 95:
-#line 292 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new PlusExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2697 "slghparse.cc" /* yacc.c:1646  */
+  case 95: /* pexpression: pexpression '+' pexpression  */
+                                        { (yyval.patexp) = new PlusExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 96:
-#line 293 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new SubExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2703 "slghparse.cc" /* yacc.c:1646  */
+  case 96: /* pexpression: pexpression '-' pexpression  */
+                                        { (yyval.patexp) = new SubExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 97:
-#line 294 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new MultExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2709 "slghparse.cc" /* yacc.c:1646  */
+  case 97: /* pexpression: pexpression '*' pexpression  */
+                                        { (yyval.patexp) = new MultExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 98:
-#line 295 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new LeftShiftExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2715 "slghparse.cc" /* yacc.c:1646  */
+  case 98: /* pexpression: pexpression OP_LEFT pexpression  */
+                                        { (yyval.patexp) = new LeftShiftExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 99:
-#line 296 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new RightShiftExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2721 "slghparse.cc" /* yacc.c:1646  */
+  case 99: /* pexpression: pexpression OP_RIGHT pexpression  */
+                                        { (yyval.patexp) = new RightShiftExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 100:
-#line 297 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new AndExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2727 "slghparse.cc" /* yacc.c:1646  */
+  case 100: /* pexpression: pexpression OP_AND pexpression  */
+                                        { (yyval.patexp) = new AndExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 101:
-#line 298 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new OrExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2733 "slghparse.cc" /* yacc.c:1646  */
+  case 101: /* pexpression: pexpression OP_OR pexpression  */
+                                        { (yyval.patexp) = new OrExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 102:
-#line 299 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new XorExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2739 "slghparse.cc" /* yacc.c:1646  */
+  case 102: /* pexpression: pexpression OP_XOR pexpression  */
+                                        { (yyval.patexp) = new XorExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 103:
-#line 300 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new DivExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
-#line 2745 "slghparse.cc" /* yacc.c:1646  */
+  case 103: /* pexpression: pexpression '/' pexpression  */
+                                        { (yyval.patexp) = new DivExpression((yyvsp[-2].patexp),(yyvsp[0].patexp)); }
     break;
 
-  case 104:
-#line 301 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new MinusExpression((yyvsp[0].patexp)); }
-#line 2751 "slghparse.cc" /* yacc.c:1646  */
+  case 104: /* pexpression: '-' pexpression  */
+                                        { (yyval.patexp) = new MinusExpression((yyvsp[0].patexp)); }
     break;
 
-  case 105:
-#line 302 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.patexp) = new NotExpression((yyvsp[0].patexp)); }
-#line 2757 "slghparse.cc" /* yacc.c:1646  */
+  case 105: /* pexpression: '~' pexpression  */
+                                        { (yyval.patexp) = new NotExpression((yyvsp[0].patexp)); }
     break;
 
-  case 107:
-#line 305 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EquationAnd((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
-#line 2763 "slghparse.cc" /* yacc.c:1646  */
+  case 107: /* pequation: pequation '&' pequation  */
+                                        { (yyval.pateq) = new EquationAnd((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
     break;
 
-  case 108:
-#line 306 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EquationOr((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
-#line 2769 "slghparse.cc" /* yacc.c:1646  */
+  case 108: /* pequation: pequation '|' pequation  */
+                                        { (yyval.pateq) = new EquationOr((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
     break;
 
-  case 109:
-#line 307 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EquationCat((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
-#line 2775 "slghparse.cc" /* yacc.c:1646  */
+  case 109: /* pequation: pequation ';' pequation  */
+                                        { (yyval.pateq) = new EquationCat((yyvsp[-2].pateq),(yyvsp[0].pateq)); }
     break;
 
-  case 110:
-#line 309 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EquationLeftEllipsis((yyvsp[0].pateq)); }
-#line 2781 "slghparse.cc" /* yacc.c:1646  */
+  case 110: /* elleq: ELLIPSIS_KEY ellrt  */
+                                        { (yyval.pateq) = new EquationLeftEllipsis((yyvsp[0].pateq)); }
     break;
 
-  case 112:
-#line 312 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EquationRightEllipsis((yyvsp[-1].pateq)); }
-#line 2787 "slghparse.cc" /* yacc.c:1646  */
+  case 112: /* ellrt: atomic ELLIPSIS_KEY  */
+                                        { (yyval.pateq) = new EquationRightEllipsis((yyvsp[-1].pateq)); }
     break;
 
-  case 115:
-#line 316 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = (yyvsp[-1].pateq); }
-#line 2793 "slghparse.cc" /* yacc.c:1646  */
+  case 115: /* atomic: '(' pequation ')'  */
+                                        { (yyval.pateq) = (yyvsp[-1].pateq); }
     break;
 
-  case 116:
-#line 318 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new EqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2799 "slghparse.cc" /* yacc.c:1646  */
+  case 116: /* constraint: familysymbol '=' pexpression  */
+                                         { (yyval.pateq) = new EqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 117:
-#line 319 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new NotEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2805 "slghparse.cc" /* yacc.c:1646  */
+  case 117: /* constraint: familysymbol OP_NOTEQUAL pexpression  */
+                                         { (yyval.pateq) = new NotEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 118:
-#line 320 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new LessEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2811 "slghparse.cc" /* yacc.c:1646  */
+  case 118: /* constraint: familysymbol '<' pexpression  */
+                                        { (yyval.pateq) = new LessEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 119:
-#line 321 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new LessEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2817 "slghparse.cc" /* yacc.c:1646  */
+  case 119: /* constraint: familysymbol OP_LESSEQUAL pexpression  */
+                                          { (yyval.pateq) = new LessEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 120:
-#line 322 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new GreaterEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2823 "slghparse.cc" /* yacc.c:1646  */
+  case 120: /* constraint: familysymbol '>' pexpression  */
+                                        { (yyval.pateq) = new GreaterEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 121:
-#line 323 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new GreaterEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
-#line 2829 "slghparse.cc" /* yacc.c:1646  */
+  case 121: /* constraint: familysymbol OP_GREATEQUAL pexpression  */
+                                           { (yyval.pateq) = new GreaterEqualEquation((yyvsp[-2].famsym)->getPatternValue(),(yyvsp[0].patexp)); }
     break;
 
-  case 122:
-#line 324 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = slgh->constrainOperand((yyvsp[-2].operandsym),(yyvsp[0].patexp)); 
+  case 122: /* constraint: OPERANDSYM '=' pexpression  */
+                                        { (yyval.pateq) = slgh->constrainOperand((yyvsp[-2].operandsym),(yyvsp[0].patexp));
                                           if ((yyval.pateq) == (PatternEquation *)0) 
                                             { string errmsg="Constraining currently undefined operand "+(yyvsp[-2].operandsym)->getName(); yyerror(errmsg.c_str()); } }
-#line 2837 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 123:
-#line 327 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new OperandEquation((yyvsp[0].operandsym)->getIndex()); slgh->selfDefine((yyvsp[0].operandsym)); }
-#line 2843 "slghparse.cc" /* yacc.c:1646  */
+  case 123: /* constraint: OPERANDSYM  */
+                                        { (yyval.pateq) = new OperandEquation((yyvsp[0].operandsym)->getIndex()); slgh->selfDefine((yyvsp[0].operandsym)); }
     break;
 
-  case 124:
-#line 328 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = new UnconstrainedEquation((yyvsp[0].specsym)->getPatternExpression()); }
-#line 2849 "slghparse.cc" /* yacc.c:1646  */
+  case 124: /* constraint: SPECSYM  */
+                                        { (yyval.pateq) = new UnconstrainedEquation((yyvsp[0].specsym)->getPatternExpression()); }
     break;
 
-  case 125:
-#line 329 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = slgh->defineInvisibleOperand((yyvsp[0].famsym)); }
-#line 2855 "slghparse.cc" /* yacc.c:1646  */
+  case 125: /* constraint: familysymbol  */
+                                        { (yyval.pateq) = slgh->defineInvisibleOperand((yyvsp[0].famsym)); }
     break;
 
-  case 126:
-#line 330 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.pateq) = slgh->defineInvisibleOperand((yyvsp[0].subtablesym)); }
-#line 2861 "slghparse.cc" /* yacc.c:1646  */
+  case 126: /* constraint: SUBTABLESYM  */
+                                        { (yyval.pateq) = slgh->defineInvisibleOperand((yyvsp[0].subtablesym)); }
     break;
 
-  case 127:
-#line 332 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (vector<ContextChange *> *)0; }
-#line 2867 "slghparse.cc" /* yacc.c:1646  */
+  case 127: /* contextblock: %empty  */
+                                        { (yyval.contop) = (vector<ContextChange *> *)0; }
     break;
 
-  case 128:
-#line 333 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (yyvsp[-1].contop); }
-#line 2873 "slghparse.cc" /* yacc.c:1646  */
+  case 128: /* contextblock: '[' contextlist ']'  */
+                                        { (yyval.contop) = (yyvsp[-1].contop); }
     break;
 
-  case 129:
-#line 335 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = new vector<ContextChange *>; }
-#line 2879 "slghparse.cc" /* yacc.c:1646  */
+  case 129: /* contextlist: %empty  */
+                                        { (yyval.contop) = new vector<ContextChange *>; }
     break;
 
-  case 130:
-#line 336 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (yyvsp[-4].contop); if (!slgh->contextMod((yyvsp[-4].contop),(yyvsp[-3].contextsym),(yyvsp[-1].patexp))) { string errmsg="Cannot use 'inst_next' or 'inst_next2' to set context variable: "+(yyvsp[-3].contextsym)->getName(); yyerror(errmsg.c_str()); YYERROR; } }
-#line 2885 "slghparse.cc" /* yacc.c:1646  */
+  case 130: /* contextlist: contextlist CONTEXTSYM '=' pexpression ';'  */
+                                                { (yyval.contop) = (yyvsp[-4].contop); if (!slgh->contextMod((yyvsp[-4].contop),(yyvsp[-3].contextsym),(yyvsp[-1].patexp))) { string errmsg="Cannot use 'inst_next' or 'inst_next2' to set context variable: "+(yyvsp[-3].contextsym)->getName(); yyerror(errmsg.c_str()); YYERROR; } }
     break;
 
-  case 131:
-#line 337 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (yyvsp[-7].contop); slgh->contextSet((yyvsp[-7].contop),(yyvsp[-4].famsym),(yyvsp[-2].contextsym)); }
-#line 2891 "slghparse.cc" /* yacc.c:1646  */
+  case 131: /* contextlist: contextlist GLOBALSET_KEY '(' familysymbol ',' CONTEXTSYM ')' ';'  */
+                                                                      { (yyval.contop) = (yyvsp[-7].contop); slgh->contextSet((yyvsp[-7].contop),(yyvsp[-4].famsym),(yyvsp[-2].contextsym)); }
     break;
 
-  case 132:
-#line 338 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (yyvsp[-7].contop); slgh->contextSet((yyvsp[-7].contop),(yyvsp[-4].specsym),(yyvsp[-2].contextsym)); }
-#line 2897 "slghparse.cc" /* yacc.c:1646  */
+  case 132: /* contextlist: contextlist GLOBALSET_KEY '(' specificsymbol ',' CONTEXTSYM ')' ';'  */
+                                                                        { (yyval.contop) = (yyvsp[-7].contop); slgh->contextSet((yyvsp[-7].contop),(yyvsp[-4].specsym),(yyvsp[-2].contextsym)); }
     break;
 
-  case 133:
-#line 339 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.contop) = (yyvsp[-4].contop); slgh->defineOperand((yyvsp[-3].operandsym),(yyvsp[-1].patexp)); }
-#line 2903 "slghparse.cc" /* yacc.c:1646  */
+  case 133: /* contextlist: contextlist OPERANDSYM '=' pexpression ';'  */
+                                               { (yyval.contop) = (yyvsp[-4].contop); slgh->defineOperand((yyvsp[-3].operandsym),(yyvsp[-1].patexp)); }
     break;
 
-  case 134:
-#line 340 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg="Expecting context symbol, not "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2909 "slghparse.cc" /* yacc.c:1646  */
+  case 134: /* contextlist: contextlist STRING  */
+                                        { string errmsg="Expecting context symbol, not "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 135:
-#line 342 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionsym) = slgh->newSectionSymbol( *(yyvsp[-1].str) ); delete (yyvsp[-1].str); }
-#line 2915 "slghparse.cc" /* yacc.c:1646  */
+  case 135: /* section_def: OP_LEFT STRING OP_RIGHT  */
+                                        { (yyval.sectionsym) = slgh->newSectionSymbol( *(yyvsp[-1].str) ); delete (yyvsp[-1].str); }
     break;
 
-  case 136:
-#line 343 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionsym) = (yyvsp[-1].sectionsym); }
-#line 2921 "slghparse.cc" /* yacc.c:1646  */
+  case 136: /* section_def: OP_LEFT SECTIONSYM OP_RIGHT  */
+                                        { (yyval.sectionsym) = (yyvsp[-1].sectionsym); }
     break;
 
-  case 137:
-#line 345 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = slgh->firstNamedSection((yyvsp[-1].sem),(yyvsp[0].sectionsym)); }
-#line 2927 "slghparse.cc" /* yacc.c:1646  */
+  case 137: /* rtlfirstsection: rtl section_def  */
+                                        { (yyval.sectionstart) = slgh->firstNamedSection((yyvsp[-1].sem),(yyvsp[0].sectionsym)); }
     break;
 
-  case 138:
-#line 347 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = (yyvsp[0].sectionstart); }
-#line 2933 "slghparse.cc" /* yacc.c:1646  */
+  case 138: /* rtlcontinue: rtlfirstsection  */
+                             { (yyval.sectionstart) = (yyvsp[0].sectionstart); }
     break;
 
-  case 139:
-#line 348 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sectionstart) = slgh->nextNamedSection((yyvsp[-2].sectionstart),(yyvsp[-1].sem),(yyvsp[0].sectionsym)); }
-#line 2939 "slghparse.cc" /* yacc.c:1646  */
+  case 139: /* rtlcontinue: rtlcontinue rtlmid section_def  */
+                                        { (yyval.sectionstart) = slgh->nextNamedSection((yyvsp[-2].sectionstart),(yyvsp[-1].sem),(yyvsp[0].sectionsym)); }
     break;
 
-  case 140:
-#line 350 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[0].sem); if ((yyval.sem)->getOpvec().empty() && ((yyval.sem)->getResult() == (HandleTpl *)0)) slgh->recordNop(); }
-#line 2945 "slghparse.cc" /* yacc.c:1646  */
+  case 140: /* rtl: rtlmid  */
+            { (yyval.sem) = (yyvsp[0].sem); if ((yyval.sem)->getOpvec().empty() && ((yyval.sem)->getResult() == (HandleTpl *)0)) slgh->recordNop(); }
     break;
 
-  case 141:
-#line 351 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = slgh->setResultVarnode((yyvsp[-3].sem),(yyvsp[-1].varnode)); }
-#line 2951 "slghparse.cc" /* yacc.c:1646  */
+  case 141: /* rtl: rtlmid EXPORT_KEY exportvarnode ';'  */
+                                        { (yyval.sem) = slgh->setResultVarnode((yyvsp[-3].sem),(yyvsp[-1].varnode)); }
     break;
 
-  case 142:
-#line 352 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = slgh->setResultStarVarnode((yyvsp[-4].sem),(yyvsp[-2].starqual),(yyvsp[-1].varnode)); }
-#line 2957 "slghparse.cc" /* yacc.c:1646  */
+  case 142: /* rtl: rtlmid EXPORT_KEY sizedstar lhsvarnode ';'  */
+                                               { (yyval.sem) = slgh->setResultStarVarnode((yyvsp[-4].sem),(yyvsp[-2].starqual),(yyvsp[-1].varnode)); }
     break;
 
-  case 143:
-#line 353 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg="Unknown export varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2963 "slghparse.cc" /* yacc.c:1646  */
+  case 143: /* rtl: rtlmid EXPORT_KEY STRING  */
+                                        { string errmsg="Unknown export varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 144:
-#line 354 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg="Unknown pointer varnode: "+*(yyvsp[0].str); delete (yyvsp[-1].starqual); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 2969 "slghparse.cc" /* yacc.c:1646  */
+  case 144: /* rtl: rtlmid EXPORT_KEY sizedstar STRING  */
+                                        { string errmsg="Unknown pointer varnode: "+*(yyvsp[0].str); delete (yyvsp[-1].starqual); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 145:
-#line 356 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = new ConstructTpl(); }
-#line 2975 "slghparse.cc" /* yacc.c:1646  */
+  case 145: /* rtlmid: %empty  */
+                                        { (yyval.sem) = new ConstructTpl(); }
     break;
 
-  case 146:
-#line 357 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-1].sem); if (!(yyval.sem)->addOpList(*(yyvsp[0].stmt))) { delete (yyvsp[0].stmt); yyerror("Multiple delayslot declarations"); YYERROR; } delete (yyvsp[0].stmt); }
-#line 2981 "slghparse.cc" /* yacc.c:1646  */
+  case 146: /* rtlmid: rtlmid statement  */
+                                        { (yyval.sem) = (yyvsp[-1].sem); if (!(yyval.sem)->addOpList(*(yyvsp[0].stmt))) { delete (yyvsp[0].stmt); yyerror("Multiple delayslot declarations"); YYERROR; } delete (yyvsp[0].stmt); }
     break;
 
-  case 147:
-#line 358 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-3].sem); slgh->pcode.newLocalDefinition((yyvsp[-1].str)); }
-#line 2987 "slghparse.cc" /* yacc.c:1646  */
+  case 147: /* rtlmid: rtlmid LOCAL_KEY STRING ';'  */
+                                { (yyval.sem) = (yyvsp[-3].sem); slgh->pcode.newLocalDefinition((yyvsp[-1].str)); }
     break;
 
-  case 148:
-#line 359 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.sem) = (yyvsp[-5].sem); slgh->pcode.newLocalDefinition((yyvsp[-3].str),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 2993 "slghparse.cc" /* yacc.c:1646  */
+  case 148: /* rtlmid: rtlmid LOCAL_KEY STRING ':' INTEGER ';'  */
+                                            { (yyval.sem) = (yyvsp[-5].sem); slgh->pcode.newLocalDefinition((yyvsp[-3].str),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 149:
-#line 361 "slghparse.y" /* yacc.c:1646  */
-    { (yyvsp[-1].tree)->setOutput((yyvsp[-3].varnode)); (yyval.stmt) = ExprTree::toVector((yyvsp[-1].tree)); }
-#line 2999 "slghparse.cc" /* yacc.c:1646  */
+  case 149: /* statement: lhsvarnode '=' expr ';'  */
+                                        { (yyvsp[-1].tree)->setOutput((yyvsp[-3].varnode)); (yyval.stmt) = ExprTree::toVector((yyvsp[-1].tree)); }
     break;
 
-  case 150:
-#line 362 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-3].str)); }
-#line 3005 "slghparse.cc" /* yacc.c:1646  */
+  case 150: /* statement: LOCAL_KEY STRING '=' expr ';'  */
+                                        { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-3].str)); }
     break;
 
-  case 151:
-#line 363 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.newOutput(false,(yyvsp[-1].tree),(yyvsp[-3].str)); }
-#line 3011 "slghparse.cc" /* yacc.c:1646  */
+  case 151: /* statement: STRING '=' expr ';'  */
+                                        { (yyval.stmt) = slgh->pcode.newOutput(false,(yyvsp[-1].tree),(yyvsp[-3].str)); }
     break;
 
-  case 152:
-#line 364 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
-#line 3017 "slghparse.cc" /* yacc.c:1646  */
+  case 152: /* statement: LOCAL_KEY STRING ':' INTEGER '=' expr ';'  */
+                                                { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
     break;
 
-  case 153:
-#line 365 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
-#line 3023 "slghparse.cc" /* yacc.c:1646  */
+  case 153: /* statement: STRING ':' INTEGER '=' expr ';'  */
+                                        { (yyval.stmt) = slgh->pcode.newOutput(true,(yyvsp[-1].tree),(yyvsp[-5].str),*(yyvsp[-3].i)); delete (yyvsp[-3].i); }
     break;
 
-  case 154:
-#line 366 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = (vector<OpTpl *> *)0; string errmsg = "Redefinition of symbol: "+(yyvsp[-1].specsym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
-#line 3029 "slghparse.cc" /* yacc.c:1646  */
+  case 154: /* statement: LOCAL_KEY specificsymbol '='  */
+                                 { (yyval.stmt) = (vector<OpTpl *> *)0; string errmsg = "Redefinition of symbol: "+(yyvsp[-1].specsym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 155:
-#line 367 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createStore((yyvsp[-4].starqual),(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 3035 "slghparse.cc" /* yacc.c:1646  */
+  case 155: /* statement: sizedstar expr '=' expr ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createStore((yyvsp[-4].starqual),(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 156:
-#line 368 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createUserOpNoOut((yyvsp[-4].useropsym),(yyvsp[-2].param)); }
-#line 3041 "slghparse.cc" /* yacc.c:1646  */
+  case 156: /* statement: USEROPSYM '(' paramlist ')' ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createUserOpNoOut((yyvsp[-4].useropsym),(yyvsp[-2].param)); }
     break;
 
-  case 157:
-#line 369 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.assignBitRange((yyvsp[-8].varnode),(uint4)*(yyvsp[-6].i),(uint4)*(yyvsp[-4].i),(yyvsp[-1].tree)); delete (yyvsp[-6].i), delete (yyvsp[-4].i); }
-#line 3047 "slghparse.cc" /* yacc.c:1646  */
+  case 157: /* statement: lhsvarnode '[' INTEGER ',' INTEGER ']' '=' expr ';'  */
+                                                        { (yyval.stmt) = slgh->pcode.assignBitRange((yyvsp[-8].varnode),(uint4)*(yyvsp[-6].i),(uint4)*(yyvsp[-4].i),(yyvsp[-1].tree)); delete (yyvsp[-6].i), delete (yyvsp[-4].i); }
     break;
 
-  case 158:
-#line 370 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt)=slgh->pcode.assignBitRange((yyvsp[-3].bitsym)->getParentSymbol()->getVarnode(),(yyvsp[-3].bitsym)->getBitOffset(),(yyvsp[-3].bitsym)->numBits(),(yyvsp[-1].tree)); }
-#line 3053 "slghparse.cc" /* yacc.c:1646  */
+  case 158: /* statement: BITSYM '=' expr ';'  */
+                                        { (yyval.stmt)=slgh->pcode.assignBitRange((yyvsp[-3].bitsym)->getParentSymbol()->getVarnode(),(yyvsp[-3].bitsym)->getBitOffset(),(yyvsp[-3].bitsym)->numBits(),(yyvsp[-1].tree)); }
     break;
 
-  case 159:
-#line 371 "slghparse.y" /* yacc.c:1646  */
-    { delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal truncation on left-hand side of assignment"); YYERROR; }
-#line 3059 "slghparse.cc" /* yacc.c:1646  */
+  case 159: /* statement: varnode ':' INTEGER '='  */
+                                        { delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal truncation on left-hand side of assignment"); YYERROR; }
     break;
 
-  case 160:
-#line 372 "slghparse.y" /* yacc.c:1646  */
-    { delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal subpiece on left-hand side of assignment"); YYERROR; }
-#line 3065 "slghparse.cc" /* yacc.c:1646  */
+  case 160: /* statement: varnode '(' INTEGER ')'  */
+                                        { delete (yyvsp[-3].varnode); delete (yyvsp[-1].i); yyerror("Illegal subpiece on left-hand side of assignment"); YYERROR; }
     break;
 
-  case 161:
-#line 373 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpConst(BUILD,(yyvsp[-1].operandsym)->getIndex()); }
-#line 3071 "slghparse.cc" /* yacc.c:1646  */
+  case 161: /* statement: BUILD_KEY OPERANDSYM ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpConst(BUILD,(yyvsp[-1].operandsym)->getIndex()); }
     break;
 
-  case 162:
-#line 374 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->createCrossBuild((yyvsp[-3].varnode),(yyvsp[-1].sectionsym)); }
-#line 3077 "slghparse.cc" /* yacc.c:1646  */
+  case 162: /* statement: CROSSBUILD_KEY varnode ',' SECTIONSYM ';'  */
+                                              { (yyval.stmt) = slgh->createCrossBuild((yyvsp[-3].varnode),(yyvsp[-1].sectionsym)); }
     break;
 
-  case 163:
-#line 375 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->createCrossBuild((yyvsp[-3].varnode),slgh->newSectionSymbol(*(yyvsp[-1].str))); delete (yyvsp[-1].str); }
-#line 3083 "slghparse.cc" /* yacc.c:1646  */
+  case 163: /* statement: CROSSBUILD_KEY varnode ',' STRING ';'  */
+                                            { (yyval.stmt) = slgh->createCrossBuild((yyvsp[-3].varnode),slgh->newSectionSymbol(*(yyvsp[-1].str))); delete (yyvsp[-1].str); }
     break;
 
-  case 164:
-#line 376 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpConst(DELAY_SLOT,*(yyvsp[-2].i)); delete (yyvsp[-2].i); }
-#line 3089 "slghparse.cc" /* yacc.c:1646  */
+  case 164: /* statement: DELAYSLOT_KEY '(' INTEGER ')' ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpConst(DELAY_SLOT,*(yyvsp[-2].i)); delete (yyvsp[-2].i); }
     break;
 
-  case 165:
-#line 377 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_BRANCH,new ExprTree((yyvsp[-1].varnode))); }
-#line 3095 "slghparse.cc" /* yacc.c:1646  */
+  case 165: /* statement: GOTO_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_BRANCH,new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 166:
-#line 378 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CBRANCH,new ExprTree((yyvsp[-1].varnode)),(yyvsp[-3].tree)); }
-#line 3101 "slghparse.cc" /* yacc.c:1646  */
+  case 166: /* statement: IF_KEY expr GOTO_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CBRANCH,new ExprTree((yyvsp[-1].varnode)),(yyvsp[-3].tree)); }
     break;
 
-  case 167:
-#line 379 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_BRANCHIND,(yyvsp[-2].tree)); }
-#line 3107 "slghparse.cc" /* yacc.c:1646  */
+  case 167: /* statement: GOTO_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_BRANCHIND,(yyvsp[-2].tree)); }
     break;
 
-  case 168:
-#line 380 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CALL,new ExprTree((yyvsp[-1].varnode))); }
-#line 3113 "slghparse.cc" /* yacc.c:1646  */
+  case 168: /* statement: CALL_KEY jumpdest ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CALL,new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 169:
-#line 381 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CALLIND,(yyvsp[-2].tree)); }
-#line 3119 "slghparse.cc" /* yacc.c:1646  */
+  case 169: /* statement: CALL_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_CALLIND,(yyvsp[-2].tree)); }
     break;
 
-  case 170:
-#line 382 "slghparse.y" /* yacc.c:1646  */
-    { yyerror("Must specify an indirect parameter for return"); YYERROR; }
-#line 3125 "slghparse.cc" /* yacc.c:1646  */
+  case 170: /* statement: RETURN_KEY ';'  */
+                                        { yyerror("Must specify an indirect parameter for return"); YYERROR; }
     break;
 
-  case 171:
-#line 383 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_RETURN,(yyvsp[-2].tree)); }
-#line 3131 "slghparse.cc" /* yacc.c:1646  */
+  case 171: /* statement: RETURN_KEY '[' expr ']' ';'  */
+                                        { (yyval.stmt) = slgh->pcode.createOpNoOut(CPUI_RETURN,(yyvsp[-2].tree)); }
     break;
 
-  case 172:
-#line 384 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->createMacroUse((yyvsp[-4].macrosym),(yyvsp[-2].param)); }
-#line 3137 "slghparse.cc" /* yacc.c:1646  */
+  case 172: /* statement: MACROSYM '(' paramlist ')' ';'  */
+                                        { (yyval.stmt) = slgh->createMacroUse((yyvsp[-4].macrosym),(yyvsp[-2].param)); }
     break;
 
-  case 173:
-#line 385 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.stmt) = slgh->pcode.placeLabel( (yyvsp[0].labelsym) ); }
-#line 3143 "slghparse.cc" /* yacc.c:1646  */
+  case 173: /* statement: label  */
+                                        { (yyval.stmt) = slgh->pcode.placeLabel( (yyvsp[0].labelsym) ); }
     break;
 
-  case 174:
-#line 387 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = new ExprTree((yyvsp[0].varnode)); }
-#line 3149 "slghparse.cc" /* yacc.c:1646  */
+  case 174: /* expr: varnode  */
+              { (yyval.tree) = new ExprTree((yyvsp[0].varnode)); }
     break;
 
-  case 175:
-#line 388 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createLoad((yyvsp[-1].starqual),(yyvsp[0].tree)); }
-#line 3155 "slghparse.cc" /* yacc.c:1646  */
+  case 175: /* expr: sizedstar expr  */
+                                { (yyval.tree) = slgh->pcode.createLoad((yyvsp[-1].starqual),(yyvsp[0].tree)); }
     break;
 
-  case 176:
-#line 389 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = (yyvsp[-1].tree); }
-#line 3161 "slghparse.cc" /* yacc.c:1646  */
+  case 176: /* expr: '(' expr ')'  */
+                                { (yyval.tree) = (yyvsp[-1].tree); }
     break;
 
-  case 177:
-#line 390 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3167 "slghparse.cc" /* yacc.c:1646  */
+  case 177: /* expr: expr '+' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 178:
-#line 391 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3173 "slghparse.cc" /* yacc.c:1646  */
+  case 178: /* expr: expr '-' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 179:
-#line 392 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3179 "slghparse.cc" /* yacc.c:1646  */
+  case 179: /* expr: expr OP_EQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 180:
-#line 393 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3185 "slghparse.cc" /* yacc.c:1646  */
+  case 180: /* expr: expr OP_NOTEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 181:
-#line 394 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3191 "slghparse.cc" /* yacc.c:1646  */
+  case 181: /* expr: expr '<' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 182:
-#line 395 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3197 "slghparse.cc" /* yacc.c:1646  */
+  case 182: /* expr: expr OP_GREATEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 183:
-#line 396 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3203 "slghparse.cc" /* yacc.c:1646  */
+  case 183: /* expr: expr OP_LESSEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 184:
-#line 397 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3209 "slghparse.cc" /* yacc.c:1646  */
+  case 184: /* expr: expr '>' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 185:
-#line 398 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3215 "slghparse.cc" /* yacc.c:1646  */
+  case 185: /* expr: expr OP_SLESS expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 186:
-#line 399 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3221 "slghparse.cc" /* yacc.c:1646  */
+  case 186: /* expr: expr OP_SGREATEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 187:
-#line 400 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3227 "slghparse.cc" /* yacc.c:1646  */
+  case 187: /* expr: expr OP_SLESSEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 188:
-#line 401 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3233 "slghparse.cc" /* yacc.c:1646  */
+  case 188: /* expr: expr OP_SGREAT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SLESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 189:
-#line 402 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_2COMP,(yyvsp[0].tree)); }
-#line 3239 "slghparse.cc" /* yacc.c:1646  */
+  case 189: /* expr: '-' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_2COMP,(yyvsp[0].tree)); }
     break;
 
-  case 190:
-#line 403 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_NEGATE,(yyvsp[0].tree)); }
-#line 3245 "slghparse.cc" /* yacc.c:1646  */
+  case 190: /* expr: '~' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_NEGATE,(yyvsp[0].tree)); }
     break;
 
-  case 191:
-#line 404 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3251 "slghparse.cc" /* yacc.c:1646  */
+  case 191: /* expr: expr '^' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 192:
-#line 405 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3257 "slghparse.cc" /* yacc.c:1646  */
+  case 192: /* expr: expr '&' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 193:
-#line 406 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3263 "slghparse.cc" /* yacc.c:1646  */
+  case 193: /* expr: expr '|' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 194:
-#line 407 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LEFT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3269 "slghparse.cc" /* yacc.c:1646  */
+  case 194: /* expr: expr OP_LEFT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_LEFT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 195:
-#line 408 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_RIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3275 "slghparse.cc" /* yacc.c:1646  */
+  case 195: /* expr: expr OP_RIGHT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_RIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 196:
-#line 409 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SRIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3281 "slghparse.cc" /* yacc.c:1646  */
+  case 196: /* expr: expr OP_SRIGHT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SRIGHT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 197:
-#line 410 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3287 "slghparse.cc" /* yacc.c:1646  */
+  case 197: /* expr: expr '*' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 198:
-#line 411 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3293 "slghparse.cc" /* yacc.c:1646  */
+  case 198: /* expr: expr '/' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 199:
-#line 412 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SDIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3299 "slghparse.cc" /* yacc.c:1646  */
+  case 199: /* expr: expr OP_SDIV expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SDIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 200:
-#line 413 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_REM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3305 "slghparse.cc" /* yacc.c:1646  */
+  case 200: /* expr: expr '%' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_REM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 201:
-#line 414 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SREM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3311 "slghparse.cc" /* yacc.c:1646  */
+  case 201: /* expr: expr OP_SREM expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SREM,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 202:
-#line 415 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_NEGATE,(yyvsp[0].tree)); }
-#line 3317 "slghparse.cc" /* yacc.c:1646  */
+  case 202: /* expr: '!' expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_NEGATE,(yyvsp[0].tree)); }
     break;
 
-  case 203:
-#line 416 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3323 "slghparse.cc" /* yacc.c:1646  */
+  case 203: /* expr: expr OP_BOOL_XOR expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_XOR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 204:
-#line 417 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3329 "slghparse.cc" /* yacc.c:1646  */
+  case 204: /* expr: expr OP_BOOL_AND expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_AND,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 205:
-#line 418 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3335 "slghparse.cc" /* yacc.c:1646  */
+  case 205: /* expr: expr OP_BOOL_OR expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_BOOL_OR,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 206:
-#line 419 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3341 "slghparse.cc" /* yacc.c:1646  */
+  case 206: /* expr: expr OP_FEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_EQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 207:
-#line 420 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3347 "slghparse.cc" /* yacc.c:1646  */
+  case 207: /* expr: expr OP_FNOTEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NOTEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 208:
-#line 421 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3353 "slghparse.cc" /* yacc.c:1646  */
+  case 208: /* expr: expr OP_FLESS expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESS,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 209:
-#line 422 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3359 "slghparse.cc" /* yacc.c:1646  */
+  case 209: /* expr: expr OP_FGREAT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESS,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 210:
-#line 423 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3365 "slghparse.cc" /* yacc.c:1646  */
+  case 210: /* expr: expr OP_FLESSEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 211:
-#line 424 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
-#line 3371 "slghparse.cc" /* yacc.c:1646  */
+  case 211: /* expr: expr OP_FGREATEQUAL expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_LESSEQUAL,(yyvsp[0].tree),(yyvsp[-2].tree)); }
     break;
 
-  case 212:
-#line 425 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3377 "slghparse.cc" /* yacc.c:1646  */
+  case 212: /* expr: expr OP_FADD expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ADD,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 213:
-#line 426 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3383 "slghparse.cc" /* yacc.c:1646  */
+  case 213: /* expr: expr OP_FSUB expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_SUB,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 214:
-#line 427 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3389 "slghparse.cc" /* yacc.c:1646  */
+  case 214: /* expr: expr OP_FMULT expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_MULT,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 215:
-#line 428 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
-#line 3395 "slghparse.cc" /* yacc.c:1646  */
+  case 215: /* expr: expr OP_FDIV expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_DIV,(yyvsp[-2].tree),(yyvsp[0].tree)); }
     break;
 
-  case 216:
-#line 429 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NEG,(yyvsp[0].tree)); }
-#line 3401 "slghparse.cc" /* yacc.c:1646  */
+  case 216: /* expr: OP_FSUB expr  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NEG,(yyvsp[0].tree)); }
     break;
 
-  case 217:
-#line 430 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ABS,(yyvsp[-1].tree)); }
-#line 3407 "slghparse.cc" /* yacc.c:1646  */
+  case 217: /* expr: OP_ABS '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ABS,(yyvsp[-1].tree)); }
     break;
 
-  case 218:
-#line 431 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_SQRT,(yyvsp[-1].tree)); }
-#line 3413 "slghparse.cc" /* yacc.c:1646  */
+  case 218: /* expr: OP_SQRT '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_SQRT,(yyvsp[-1].tree)); }
     break;
 
-  case 219:
-#line 432 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SEXT,(yyvsp[-1].tree)); }
-#line 3419 "slghparse.cc" /* yacc.c:1646  */
+  case 219: /* expr: OP_SEXT '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SEXT,(yyvsp[-1].tree)); }
     break;
 
-  case 220:
-#line 433 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_ZEXT,(yyvsp[-1].tree)); }
-#line 3425 "slghparse.cc" /* yacc.c:1646  */
+  case 220: /* expr: OP_ZEXT '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_ZEXT,(yyvsp[-1].tree)); }
     break;
 
-  case 221:
-#line 434 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_CARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 3431 "slghparse.cc" /* yacc.c:1646  */
+  case 221: /* expr: OP_CARRY '(' expr ',' expr ')'  */
+                                   { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_CARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 222:
-#line 435 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SCARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 3437 "slghparse.cc" /* yacc.c:1646  */
+  case 222: /* expr: OP_SCARRY '(' expr ',' expr ')'  */
+                                    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SCARRY,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 223:
-#line 436 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SBORROW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 3443 "slghparse.cc" /* yacc.c:1646  */
+  case 223: /* expr: OP_SBORROW '(' expr ',' expr ')'  */
+                                     { (yyval.tree) = slgh->pcode.createOp(CPUI_INT_SBORROW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 224:
-#line 437 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_FLOAT2FLOAT,(yyvsp[-1].tree)); }
-#line 3449 "slghparse.cc" /* yacc.c:1646  */
+  case 224: /* expr: OP_FLOAT2FLOAT '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_FLOAT2FLOAT,(yyvsp[-1].tree)); }
     break;
 
-  case 225:
-#line 438 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_INT2FLOAT,(yyvsp[-1].tree)); }
-#line 3455 "slghparse.cc" /* yacc.c:1646  */
+  case 225: /* expr: OP_INT2FLOAT '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_INT2FLOAT,(yyvsp[-1].tree)); }
     break;
 
-  case 226:
-#line 439 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NAN,(yyvsp[-1].tree)); }
-#line 3461 "slghparse.cc" /* yacc.c:1646  */
+  case 226: /* expr: OP_NAN '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_NAN,(yyvsp[-1].tree)); }
     break;
 
-  case 227:
-#line 440 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_TRUNC,(yyvsp[-1].tree)); }
-#line 3467 "slghparse.cc" /* yacc.c:1646  */
+  case 227: /* expr: OP_TRUNC '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_TRUNC,(yyvsp[-1].tree)); }
     break;
 
-  case 228:
-#line 441 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_CEIL,(yyvsp[-1].tree)); }
-#line 3473 "slghparse.cc" /* yacc.c:1646  */
+  case 228: /* expr: OP_CEIL '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_CEIL,(yyvsp[-1].tree)); }
     break;
 
-  case 229:
-#line 442 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_FLOOR,(yyvsp[-1].tree)); }
-#line 3479 "slghparse.cc" /* yacc.c:1646  */
+  case 229: /* expr: OP_FLOOR '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_FLOOR,(yyvsp[-1].tree)); }
     break;
 
-  case 230:
-#line 443 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ROUND,(yyvsp[-1].tree)); }
-#line 3485 "slghparse.cc" /* yacc.c:1646  */
+  case 230: /* expr: OP_ROUND '(' expr ')'  */
+                                { (yyval.tree) = slgh->pcode.createOp(CPUI_FLOAT_ROUND,(yyvsp[-1].tree)); }
     break;
 
-  case 231:
-#line 444 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_NEW,(yyvsp[-1].tree)); }
-#line 3491 "slghparse.cc" /* yacc.c:1646  */
+  case 231: /* expr: OP_NEW '(' expr ')'  */
+                            { (yyval.tree) = slgh->pcode.createOp(CPUI_NEW,(yyvsp[-1].tree)); }
     break;
 
-  case 232:
-#line 445 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_NEW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
-#line 3497 "slghparse.cc" /* yacc.c:1646  */
+  case 232: /* expr: OP_NEW '(' expr ',' expr ')'  */
+                                 { (yyval.tree) = slgh->pcode.createOp(CPUI_NEW,(yyvsp[-3].tree),(yyvsp[-1].tree)); }
     break;
 
-  case 233:
-#line 446 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_POPCOUNT,(yyvsp[-1].tree)); }
-#line 3503 "slghparse.cc" /* yacc.c:1646  */
+  case 233: /* expr: OP_POPCOUNT '(' expr ')'  */
+                             { (yyval.tree) = slgh->pcode.createOp(CPUI_POPCOUNT,(yyvsp[-1].tree)); }
     break;
 
-  case 234:
-#line 447 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createOp(CPUI_SUBPIECE,new ExprTree((yyvsp[-3].specsym)->getVarnode()),new ExprTree((yyvsp[-1].varnode))); }
-#line 3509 "slghparse.cc" /* yacc.c:1646  */
+  case 234: /* expr: specificsymbol '(' integervarnode ')'  */
+                                          { (yyval.tree) = slgh->pcode.createOp(CPUI_SUBPIECE,new ExprTree((yyvsp[-3].specsym)->getVarnode()),new ExprTree((yyvsp[-1].varnode))); }
     break;
 
-  case 235:
-#line 448 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createBitRange((yyvsp[-2].specsym),0,(uint4)(*(yyvsp[0].i) * 8)); delete (yyvsp[0].i); }
-#line 3515 "slghparse.cc" /* yacc.c:1646  */
+  case 235: /* expr: specificsymbol ':' INTEGER  */
+                                { (yyval.tree) = slgh->pcode.createBitRange((yyvsp[-2].specsym),0,(uint4)(*(yyvsp[0].i) * 8)); delete (yyvsp[0].i); }
     break;
 
-  case 236:
-#line 449 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createBitRange((yyvsp[-5].specsym),(uint4)*(yyvsp[-3].i),(uint4)*(yyvsp[-1].i)); delete (yyvsp[-3].i), delete (yyvsp[-1].i); }
-#line 3521 "slghparse.cc" /* yacc.c:1646  */
+  case 236: /* expr: specificsymbol '[' INTEGER ',' INTEGER ']'  */
+                                               { (yyval.tree) = slgh->pcode.createBitRange((yyvsp[-5].specsym),(uint4)*(yyvsp[-3].i),(uint4)*(yyvsp[-1].i)); delete (yyvsp[-3].i), delete (yyvsp[-1].i); }
     break;
 
-  case 237:
-#line 450 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree)=slgh->pcode.createBitRange((yyvsp[0].bitsym)->getParentSymbol(),(yyvsp[0].bitsym)->getBitOffset(),(yyvsp[0].bitsym)->numBits()); }
-#line 3527 "slghparse.cc" /* yacc.c:1646  */
+  case 237: /* expr: BITSYM  */
+                                { (yyval.tree)=slgh->pcode.createBitRange((yyvsp[0].bitsym)->getParentSymbol(),(yyvsp[0].bitsym)->getBitOffset(),(yyvsp[0].bitsym)->numBits()); }
     break;
 
-  case 238:
-#line 451 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.tree) = slgh->pcode.createUserOp((yyvsp[-3].useropsym),(yyvsp[-1].param)); }
-#line 3533 "slghparse.cc" /* yacc.c:1646  */
+  case 238: /* expr: USEROPSYM '(' paramlist ')'  */
+                                { (yyval.tree) = slgh->pcode.createUserOp((yyvsp[-3].useropsym),(yyvsp[-1].param)); }
     break;
 
-  case 239:
-#line 452 "slghparse.y" /* yacc.c:1646  */
-    { if ((*(yyvsp[-1].param)).size() < 2) { string errmsg = "Must at least two inputs to cpool"; yyerror(errmsg.c_str()); YYERROR; } (yyval.tree) = slgh->pcode.createVariadic(CPUI_CPOOLREF,(yyvsp[-1].param)); }
-#line 3539 "slghparse.cc" /* yacc.c:1646  */
+  case 239: /* expr: OP_CPOOLREF '(' paramlist ')'  */
+                                   { if ((*(yyvsp[-1].param)).size() < 2) { string errmsg = "Must at least two inputs to cpool"; yyerror(errmsg.c_str()); YYERROR; } (yyval.tree) = slgh->pcode.createVariadic(CPUI_CPOOLREF,(yyvsp[-1].param)); }
     break;
 
-  case 240:
-#line 454 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl((yyvsp[-3].spacesym)->getSpace()); }
-#line 3545 "slghparse.cc" /* yacc.c:1646  */
+  case 240: /* sizedstar: '*' '[' SPACESYM ']' ':' INTEGER  */
+                                            { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl((yyvsp[-3].spacesym)->getSpace()); }
     break;
 
-  case 241:
-#line 455 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl((yyvsp[-1].spacesym)->getSpace()); }
-#line 3551 "slghparse.cc" /* yacc.c:1646  */
+  case 241: /* sizedstar: '*' '[' SPACESYM ']'  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl((yyvsp[-1].spacesym)->getSpace()); }
     break;
 
-  case 242:
-#line 456 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl(slgh->getDefaultCodeSpace()); }
-#line 3557 "slghparse.cc" /* yacc.c:1646  */
+  case 242: /* sizedstar: '*' ':' INTEGER  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = *(yyvsp[0].i); delete (yyvsp[0].i); (yyval.starqual)->id=ConstTpl(slgh->getDefaultCodeSpace()); }
     break;
 
-  case 243:
-#line 457 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl(slgh->getDefaultCodeSpace()); }
-#line 3563 "slghparse.cc" /* yacc.c:1646  */
+  case 243: /* sizedstar: '*'  */
+                                { (yyval.starqual) = new StarQuality; (yyval.starqual)->size = 0; (yyval.starqual)->id=ConstTpl(slgh->getDefaultCodeSpace()); }
     break;
 
-  case 244:
-#line 459 "slghparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].startsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 3569 "slghparse.cc" /* yacc.c:1646  */
+  case 244: /* jumpdest: STARTSYM  */
+                                { VarnodeTpl *sym = (yyvsp[0].startsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 245:
-#line 460 "slghparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].endsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 3575 "slghparse.cc" /* yacc.c:1646  */
+  case 245: /* jumpdest: ENDSYM  */
+                                { VarnodeTpl *sym = (yyvsp[0].endsym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 246:
-#line 461 "slghparse.y" /* yacc.c:1646  */
-    { VarnodeTpl *sym = (yyvsp[0].next2sym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
-#line 3581 "slghparse.cc" /* yacc.c:1646  */
+  case 246: /* jumpdest: NEXT2SYM  */
+                                { VarnodeTpl *sym = (yyvsp[0].next2sym)->getVarnode(); (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),sym->getOffset(),ConstTpl(ConstTpl::j_curspace_size)); delete sym; }
     break;
 
-  case 247:
-#line 462 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::j_curspace_size)); delete (yyvsp[0].i); }
-#line 3587 "slghparse.cc" /* yacc.c:1646  */
+  case 247: /* jumpdest: INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::j_curspace_size)); delete (yyvsp[0].i); }
     break;
 
-  case 248:
-#line 463 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::j_curspace_size)); yyerror("Parsed integer is too big (overflow)"); }
-#line 3593 "slghparse.cc" /* yacc.c:1646  */
+  case 248: /* jumpdest: BADINTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(ConstTpl::j_curspace),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::j_curspace_size)); yyerror("Parsed integer is too big (overflow)"); }
     break;
 
-  case 249:
-#line 464 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].operandsym)->getVarnode(); (yyvsp[0].operandsym)->setCodeAddress(); }
-#line 3599 "slghparse.cc" /* yacc.c:1646  */
+  case 249: /* jumpdest: OPERANDSYM  */
+                                { (yyval.varnode) = (yyvsp[0].operandsym)->getVarnode(); (yyvsp[0].operandsym)->setCodeAddress(); }
     break;
 
-  case 250:
-#line 465 "slghparse.y" /* yacc.c:1646  */
-    { AddrSpace *spc = (yyvsp[-1].spacesym)->getSpace(); (yyval.varnode) = new VarnodeTpl(ConstTpl(spc),ConstTpl(ConstTpl::real,*(yyvsp[-3].i)),ConstTpl(ConstTpl::real,spc->getAddrSize())); delete (yyvsp[-3].i); }
-#line 3605 "slghparse.cc" /* yacc.c:1646  */
+  case 250: /* jumpdest: INTEGER '[' SPACESYM ']'  */
+                                { AddrSpace *spc = (yyvsp[-1].spacesym)->getSpace(); (yyval.varnode) = new VarnodeTpl(ConstTpl(spc),ConstTpl(ConstTpl::real,*(yyvsp[-3].i)),ConstTpl(ConstTpl::real,spc->getAddrSize())); delete (yyvsp[-3].i); }
     break;
 
-  case 251:
-#line 466 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::j_relative,(yyvsp[0].labelsym)->getIndex()),ConstTpl(ConstTpl::real,sizeof(uintm))); (yyvsp[0].labelsym)->incrementRefCount(); }
-#line 3611 "slghparse.cc" /* yacc.c:1646  */
+  case 251: /* jumpdest: label  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::j_relative,(yyvsp[0].labelsym)->getIndex()),ConstTpl(ConstTpl::real,sizeof(uintm))); (yyvsp[0].labelsym)->incrementRefCount(); }
     break;
 
-  case 252:
-#line 467 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Unknown jump destination: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 3617 "slghparse.cc" /* yacc.c:1646  */
+  case 252: /* jumpdest: STRING  */
+                                { string errmsg = "Unknown jump destination: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 253:
-#line 469 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
-#line 3623 "slghparse.cc" /* yacc.c:1646  */
+  case 253: /* varnode: specificsymbol  */
+                                { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
     break;
 
-  case 254:
-#line 470 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].varnode); }
-#line 3629 "slghparse.cc" /* yacc.c:1646  */
+  case 254: /* varnode: integervarnode  */
+                                { (yyval.varnode) = (yyvsp[0].varnode); }
     break;
 
-  case 255:
-#line 471 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Unknown varnode parameter: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 3635 "slghparse.cc" /* yacc.c:1646  */
+  case 255: /* varnode: STRING  */
+                                { string errmsg = "Unknown varnode parameter: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 256:
-#line 472 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
-#line 3641 "slghparse.cc" /* yacc.c:1646  */
+  case 256: /* varnode: SUBTABLESYM  */
+                                { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 257:
-#line 474 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::real,0)); delete (yyvsp[0].i); }
-#line 3647 "slghparse.cc" /* yacc.c:1646  */
+  case 257: /* integervarnode: INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[0].i)),ConstTpl(ConstTpl::real,0)); delete (yyvsp[0].i); }
     break;
 
-  case 258:
-#line 475 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::real,0)); yyerror("Parsed integer is too big (overflow)"); }
-#line 3653 "slghparse.cc" /* yacc.c:1646  */
+  case 258: /* integervarnode: BADINTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,0),ConstTpl(ConstTpl::real,0)); yyerror("Parsed integer is too big (overflow)"); }
     break;
 
-  case 259:
-#line 476 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
-#line 3659 "slghparse.cc" /* yacc.c:1646  */
+  case 259: /* integervarnode: INTEGER ':' INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
     break;
 
-  case 260:
-#line 477 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),0); }
-#line 3665 "slghparse.cc" /* yacc.c:1646  */
+  case 260: /* integervarnode: '&' varnode  */
+                                { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),0); }
     break;
 
-  case 261:
-#line 478 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 3671 "slghparse.cc" /* yacc.c:1646  */
+  case 261: /* integervarnode: '&' ':' INTEGER varnode  */
+                                { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 262:
-#line 480 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
-#line 3677 "slghparse.cc" /* yacc.c:1646  */
+  case 262: /* lhsvarnode: specificsymbol  */
+                                { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
     break;
 
-  case 263:
-#line 481 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Unknown assignment varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 3683 "slghparse.cc" /* yacc.c:1646  */
+  case 263: /* lhsvarnode: STRING  */
+                                { string errmsg = "Unknown assignment varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 264:
-#line 482 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
-#line 3689 "slghparse.cc" /* yacc.c:1646  */
+  case 264: /* lhsvarnode: SUBTABLESYM  */
+                                { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 265:
-#line 484 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.labelsym) = (yyvsp[-1].labelsym); }
-#line 3695 "slghparse.cc" /* yacc.c:1646  */
+  case 265: /* label: '<' LABELSYM '>'  */
+                                { (yyval.labelsym) = (yyvsp[-1].labelsym); }
     break;
 
-  case 266:
-#line 485 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.labelsym) = slgh->pcode.defineLabel( (yyvsp[-1].str) ); }
-#line 3701 "slghparse.cc" /* yacc.c:1646  */
+  case 266: /* label: '<' STRING '>'  */
+                                { (yyval.labelsym) = slgh->pcode.defineLabel( (yyvsp[-1].str) ); }
     break;
 
-  case 267:
-#line 487 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
-#line 3707 "slghparse.cc" /* yacc.c:1646  */
+  case 267: /* exportvarnode: specificsymbol  */
+                                { (yyval.varnode) = (yyvsp[0].specsym)->getVarnode(); }
     break;
 
-  case 268:
-#line 488 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),0); }
-#line 3713 "slghparse.cc" /* yacc.c:1646  */
+  case 268: /* exportvarnode: '&' varnode  */
+                                { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),0); }
     break;
 
-  case 269:
-#line 489 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
-#line 3719 "slghparse.cc" /* yacc.c:1646  */
+  case 269: /* exportvarnode: '&' ':' INTEGER varnode  */
+                                { (yyval.varnode) = slgh->pcode.addressOf((yyvsp[0].varnode),*(yyvsp[-1].i)); delete (yyvsp[-1].i); }
     break;
 
-  case 270:
-#line 490 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
-#line 3725 "slghparse.cc" /* yacc.c:1646  */
+  case 270: /* exportvarnode: INTEGER ':' INTEGER  */
+                                { (yyval.varnode) = new VarnodeTpl(ConstTpl(slgh->getConstantSpace()),ConstTpl(ConstTpl::real,*(yyvsp[-2].i)),ConstTpl(ConstTpl::real,*(yyvsp[0].i))); delete (yyvsp[-2].i); delete (yyvsp[0].i); }
     break;
 
-  case 271:
-#line 491 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg="Unknown export varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 3731 "slghparse.cc" /* yacc.c:1646  */
+  case 271: /* exportvarnode: STRING  */
+                                { string errmsg="Unknown export varnode: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 272:
-#line 492 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
-#line 3737 "slghparse.cc" /* yacc.c:1646  */
+  case 272: /* exportvarnode: SUBTABLESYM  */
+                                { string errmsg = "Subtable not attached to operand: "+(yyvsp[0].subtablesym)->getName(); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 273:
-#line 494 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.famsym) = (yyvsp[0].valuesym); }
-#line 3743 "slghparse.cc" /* yacc.c:1646  */
+  case 273: /* familysymbol: VALUESYM  */
+                                { (yyval.famsym) = (yyvsp[0].valuesym); }
     break;
 
-  case 274:
-#line 495 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.famsym) = (yyvsp[0].valuemapsym); }
-#line 3749 "slghparse.cc" /* yacc.c:1646  */
+  case 274: /* familysymbol: VALUEMAPSYM  */
+                                { (yyval.famsym) = (yyvsp[0].valuemapsym); }
     break;
 
-  case 275:
-#line 496 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.famsym) = (yyvsp[0].contextsym); }
-#line 3755 "slghparse.cc" /* yacc.c:1646  */
+  case 275: /* familysymbol: CONTEXTSYM  */
+                                { (yyval.famsym) = (yyvsp[0].contextsym); }
     break;
 
-  case 276:
-#line 497 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.famsym) = (yyvsp[0].namesym); }
-#line 3761 "slghparse.cc" /* yacc.c:1646  */
+  case 276: /* familysymbol: NAMESYM  */
+                                { (yyval.famsym) = (yyvsp[0].namesym); }
     break;
 
-  case 277:
-#line 498 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.famsym) = (yyvsp[0].varlistsym); }
-#line 3767 "slghparse.cc" /* yacc.c:1646  */
+  case 277: /* familysymbol: VARLISTSYM  */
+                                { (yyval.famsym) = (yyvsp[0].varlistsym); }
     break;
 
-  case 278:
-#line 500 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].varsym); }
-#line 3773 "slghparse.cc" /* yacc.c:1646  */
+  case 278: /* specificsymbol: VARSYM  */
+                                { (yyval.specsym) = (yyvsp[0].varsym); }
     break;
 
-  case 279:
-#line 501 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].specsym); }
-#line 3779 "slghparse.cc" /* yacc.c:1646  */
+  case 279: /* specificsymbol: SPECSYM  */
+                                { (yyval.specsym) = (yyvsp[0].specsym); }
     break;
 
-  case 280:
-#line 502 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].operandsym); }
-#line 3785 "slghparse.cc" /* yacc.c:1646  */
+  case 280: /* specificsymbol: OPERANDSYM  */
+                                { (yyval.specsym) = (yyvsp[0].operandsym); }
     break;
 
-  case 281:
-#line 503 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].startsym); }
-#line 3791 "slghparse.cc" /* yacc.c:1646  */
+  case 281: /* specificsymbol: STARTSYM  */
+                                { (yyval.specsym) = (yyvsp[0].startsym); }
     break;
 
-  case 282:
-#line 504 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].endsym); }
-#line 3797 "slghparse.cc" /* yacc.c:1646  */
+  case 282: /* specificsymbol: ENDSYM  */
+                                { (yyval.specsym) = (yyvsp[0].endsym); }
     break;
 
-  case 283:
-#line 505 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.specsym) = (yyvsp[0].next2sym); }
-#line 3803 "slghparse.cc" /* yacc.c:1646  */
+  case 283: /* specificsymbol: NEXT2SYM  */
+                                { (yyval.specsym) = (yyvsp[0].next2sym); }
     break;
 
-  case 284:
-#line 507 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.str) = new string; (*(yyval.str)) += (yyvsp[0].ch); }
-#line 3809 "slghparse.cc" /* yacc.c:1646  */
+  case 284: /* charstring: CHAR  */
+                                { (yyval.str) = new string; (*(yyval.str)) += (yyvsp[0].ch); }
     break;
 
-  case 285:
-#line 508 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); (*(yyval.str)) += (yyvsp[0].ch); }
-#line 3815 "slghparse.cc" /* yacc.c:1646  */
+  case 285: /* charstring: charstring CHAR  */
+                                { (yyval.str) = (yyvsp[-1].str); (*(yyval.str)) += (yyvsp[0].ch); }
     break;
 
-  case 286:
-#line 510 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = (yyvsp[-1].biglist); }
-#line 3821 "slghparse.cc" /* yacc.c:1646  */
+  case 286: /* intblist: '[' intbpart ']'  */
+                                { (yyval.biglist) = (yyvsp[-1].biglist); }
     break;
 
-  case 287:
-#line 511 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3827 "slghparse.cc" /* yacc.c:1646  */
+  case 287: /* intblist: INTEGER  */
+                                { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 288:
-#line 512 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3833 "slghparse.cc" /* yacc.c:1646  */
+  case 288: /* intblist: '-' INTEGER  */
+                                { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 289:
-#line 514 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3839 "slghparse.cc" /* yacc.c:1646  */
+  case 289: /* intbpart: INTEGER  */
+                                { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 290:
-#line 515 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3845 "slghparse.cc" /* yacc.c:1646  */
+  case 290: /* intbpart: '-' INTEGER  */
+                                { (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 291:
-#line 516 "slghparse.y" /* yacc.c:1646  */
-    { if (*(yyvsp[0].str)!="_") { string errmsg = "Expecting integer but saw: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
+  case 291: /* intbpart: STRING  */
+                                { if (*(yyvsp[0].str)!="_") { string errmsg = "Expecting integer but saw: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
                                   (yyval.biglist) = new vector<intb>; (yyval.biglist)->push_back((intb)0xBADBEEF); delete (yyvsp[0].str); }
-#line 3852 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 292:
-#line 518 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = (yyvsp[-1].biglist); (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3858 "slghparse.cc" /* yacc.c:1646  */
+  case 292: /* intbpart: intbpart INTEGER  */
+                                { (yyval.biglist) = (yyvsp[-1].biglist); (yyval.biglist)->push_back(intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 293:
-#line 519 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.biglist) = (yyvsp[-2].biglist); (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
-#line 3864 "slghparse.cc" /* yacc.c:1646  */
+  case 293: /* intbpart: intbpart '-' INTEGER  */
+                                { (yyval.biglist) = (yyvsp[-2].biglist); (yyval.biglist)->push_back(-intb(*(yyvsp[0].i))); delete (yyvsp[0].i); }
     break;
 
-  case 294:
-#line 520 "slghparse.y" /* yacc.c:1646  */
-    { if (*(yyvsp[0].str)!="_") { string errmsg = "Expecting integer but saw: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
+  case 294: /* intbpart: intbpart STRING  */
+                                { if (*(yyvsp[0].str)!="_") { string errmsg = "Expecting integer but saw: "+*(yyvsp[0].str); delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
                                   (yyval.biglist) = (yyvsp[-1].biglist); (yyval.biglist)->push_back((intb)0xBADBEEF); delete (yyvsp[0].str); }
-#line 3871 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 295:
-#line 523 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-1].strlist); }
-#line 3877 "slghparse.cc" /* yacc.c:1646  */
+  case 295: /* stringlist: '[' stringpart ']'  */
+                                { (yyval.strlist) = (yyvsp[-1].strlist); }
     break;
 
-  case 296:
-#line 524 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 3883 "slghparse.cc" /* yacc.c:1646  */
+  case 296: /* stringlist: STRING  */
+                                { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 297:
-#line 526 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( *(yyvsp[0].str) ); delete (yyvsp[0].str); }
-#line 3889 "slghparse.cc" /* yacc.c:1646  */
+  case 297: /* stringpart: STRING  */
+                                { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( *(yyvsp[0].str) ); delete (yyvsp[0].str); }
     break;
 
-  case 298:
-#line 527 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 3895 "slghparse.cc" /* yacc.c:1646  */
+  case 298: /* stringpart: stringpart STRING  */
+                                { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 299:
-#line 528 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = (yyvsp[0].anysym)->getName()+": redefined"; yyerror(errmsg.c_str()); YYERROR; }
-#line 3901 "slghparse.cc" /* yacc.c:1646  */
+  case 299: /* stringpart: stringpart anysymbol  */
+                                { string errmsg = (yyvsp[0].anysym)->getName()+": redefined"; yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 300:
-#line 530 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-1].strlist); }
-#line 3907 "slghparse.cc" /* yacc.c:1646  */
+  case 300: /* anystringlist: '[' anystringpart ']'  */
+                                     { (yyval.strlist) = (yyvsp[-1].strlist); }
     break;
 
-  case 301:
-#line 532 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( *(yyvsp[0].str) ); delete (yyvsp[0].str); }
-#line 3913 "slghparse.cc" /* yacc.c:1646  */
+  case 301: /* anystringpart: STRING  */
+                                { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( *(yyvsp[0].str) ); delete (yyvsp[0].str); }
     break;
 
-  case 302:
-#line 533 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( (yyvsp[0].anysym)->getName() ); }
-#line 3919 "slghparse.cc" /* yacc.c:1646  */
+  case 302: /* anystringpart: anysymbol  */
+                                { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back( (yyvsp[0].anysym)->getName() ); }
     break;
 
-  case 303:
-#line 534 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 3925 "slghparse.cc" /* yacc.c:1646  */
+  case 303: /* anystringpart: anystringpart STRING  */
+                                { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 304:
-#line 535 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back((yyvsp[0].anysym)->getName()); }
-#line 3931 "slghparse.cc" /* yacc.c:1646  */
+  case 304: /* anystringpart: anystringpart anysymbol  */
+                                { (yyval.strlist) = (yyvsp[-1].strlist); (yyval.strlist)->push_back((yyvsp[0].anysym)->getName()); }
     break;
 
-  case 305:
-#line 537 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = (yyvsp[-1].symlist); }
-#line 3937 "slghparse.cc" /* yacc.c:1646  */
+  case 305: /* valuelist: '[' valuepart ']'  */
+                                { (yyval.symlist) = (yyvsp[-1].symlist); }
     break;
 
-  case 306:
-#line 538 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].valuesym)); }
-#line 3943 "slghparse.cc" /* yacc.c:1646  */
+  case 306: /* valuelist: VALUESYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].valuesym)); }
     break;
 
-  case 307:
-#line 539 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
-#line 3949 "slghparse.cc" /* yacc.c:1646  */
+  case 307: /* valuelist: CONTEXTSYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
     break;
 
-  case 308:
-#line 541 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back( (yyvsp[0].valuesym) ); }
-#line 3955 "slghparse.cc" /* yacc.c:1646  */
+  case 308: /* valuepart: VALUESYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back( (yyvsp[0].valuesym) ); }
     break;
 
-  case 309:
-#line 542 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
-#line 3961 "slghparse.cc" /* yacc.c:1646  */
+  case 309: /* valuepart: CONTEXTSYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
     break;
 
-  case 310:
-#line 543 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].valuesym)); }
-#line 3967 "slghparse.cc" /* yacc.c:1646  */
+  case 310: /* valuepart: valuepart VALUESYM  */
+                                { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].valuesym)); }
     break;
 
-  case 311:
-#line 544 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
-#line 3973 "slghparse.cc" /* yacc.c:1646  */
+  case 311: /* valuepart: valuepart CONTEXTSYM  */
+                                { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].contextsym)); }
     break;
 
-  case 312:
-#line 545 "slghparse.y" /* yacc.c:1646  */
-    { string errmsg = *(yyvsp[0].str)+": is not a value pattern"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
-#line 3979 "slghparse.cc" /* yacc.c:1646  */
+  case 312: /* valuepart: valuepart STRING  */
+                                { string errmsg = *(yyvsp[0].str)+": is not a value pattern"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
     break;
 
-  case 313:
-#line 547 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = (yyvsp[-1].symlist); }
-#line 3985 "slghparse.cc" /* yacc.c:1646  */
+  case 313: /* varlist: '[' varpart ']'  */
+                                { (yyval.symlist) = (yyvsp[-1].symlist); }
     break;
 
-  case 314:
-#line 548 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].varsym)); }
-#line 3991 "slghparse.cc" /* yacc.c:1646  */
+  case 314: /* varlist: VARSYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].varsym)); }
     break;
 
-  case 315:
-#line 550 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].varsym)); }
-#line 3997 "slghparse.cc" /* yacc.c:1646  */
+  case 315: /* varpart: VARSYM  */
+                                { (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((yyvsp[0].varsym)); }
     break;
 
-  case 316:
-#line 551 "slghparse.y" /* yacc.c:1646  */
-    { if (*(yyvsp[0].str)!="_") { string errmsg = *(yyvsp[0].str)+": is not a varnode symbol"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
+  case 316: /* varpart: STRING  */
+                                { if (*(yyvsp[0].str)!="_") { string errmsg = *(yyvsp[0].str)+": is not a varnode symbol"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
 				  (yyval.symlist) = new vector<SleighSymbol *>; (yyval.symlist)->push_back((SleighSymbol *)0); delete (yyvsp[0].str); }
-#line 4004 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 317:
-#line 553 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].varsym)); }
-#line 4010 "slghparse.cc" /* yacc.c:1646  */
+  case 317: /* varpart: varpart VARSYM  */
+                                { (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((yyvsp[0].varsym)); }
     break;
 
-  case 318:
-#line 554 "slghparse.y" /* yacc.c:1646  */
-    { if (*(yyvsp[0].str)!="_") { string errmsg = *(yyvsp[0].str)+": is not a varnode symbol"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
+  case 318: /* varpart: varpart STRING  */
+                                { if (*(yyvsp[0].str)!="_") { string errmsg = *(yyvsp[0].str)+": is not a varnode symbol"; delete (yyvsp[0].str); yyerror(errmsg.c_str()); YYERROR; }
                                   (yyval.symlist) = (yyvsp[-1].symlist); (yyval.symlist)->push_back((SleighSymbol *)0); delete (yyvsp[0].str); }
-#line 4017 "slghparse.cc" /* yacc.c:1646  */
     break;
 
-  case 319:
-#line 557 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.param) = new vector<ExprTree *>; }
-#line 4023 "slghparse.cc" /* yacc.c:1646  */
+  case 319: /* paramlist: %empty  */
+                                { (yyval.param) = new vector<ExprTree *>; }
     break;
 
-  case 320:
-#line 558 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.param) = new vector<ExprTree *>; (yyval.param)->push_back((yyvsp[0].tree)); }
-#line 4029 "slghparse.cc" /* yacc.c:1646  */
+  case 320: /* paramlist: expr  */
+                                { (yyval.param) = new vector<ExprTree *>; (yyval.param)->push_back((yyvsp[0].tree)); }
     break;
 
-  case 321:
-#line 559 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.param) = (yyvsp[-2].param); (yyval.param)->push_back((yyvsp[0].tree)); }
-#line 4035 "slghparse.cc" /* yacc.c:1646  */
+  case 321: /* paramlist: paramlist ',' expr  */
+                                { (yyval.param) = (yyvsp[-2].param); (yyval.param)->push_back((yyvsp[0].tree)); }
     break;
 
-  case 322:
-#line 561 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; }
-#line 4041 "slghparse.cc" /* yacc.c:1646  */
+  case 322: /* oplist: %empty  */
+                                { (yyval.strlist) = new vector<string>; }
     break;
 
-  case 323:
-#line 562 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 4047 "slghparse.cc" /* yacc.c:1646  */
+  case 323: /* oplist: STRING  */
+                                { (yyval.strlist) = new vector<string>; (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 324:
-#line 563 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.strlist) = (yyvsp[-2].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 4053 "slghparse.cc" /* yacc.c:1646  */
+  case 324: /* oplist: oplist ',' STRING  */
+                                { (yyval.strlist) = (yyvsp[-2].strlist); (yyval.strlist)->push_back(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 325:
-#line 565 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].spacesym); }
-#line 4059 "slghparse.cc" /* yacc.c:1646  */
+  case 325: /* anysymbol: SPACESYM  */
+                                { (yyval.anysym) = (yyvsp[0].spacesym); }
     break;
 
-  case 326:
-#line 566 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].sectionsym); }
-#line 4065 "slghparse.cc" /* yacc.c:1646  */
+  case 326: /* anysymbol: SECTIONSYM  */
+                                { (yyval.anysym) = (yyvsp[0].sectionsym); }
     break;
 
-  case 327:
-#line 567 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].tokensym); }
-#line 4071 "slghparse.cc" /* yacc.c:1646  */
+  case 327: /* anysymbol: TOKENSYM  */
+                                { (yyval.anysym) = (yyvsp[0].tokensym); }
     break;
 
-  case 328:
-#line 568 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].useropsym); }
-#line 4077 "slghparse.cc" /* yacc.c:1646  */
+  case 328: /* anysymbol: USEROPSYM  */
+                                { (yyval.anysym) = (yyvsp[0].useropsym); }
     break;
 
-  case 329:
-#line 569 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].macrosym); }
-#line 4083 "slghparse.cc" /* yacc.c:1646  */
+  case 329: /* anysymbol: MACROSYM  */
+                                { (yyval.anysym) = (yyvsp[0].macrosym); }
     break;
 
-  case 330:
-#line 570 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].subtablesym); }
-#line 4089 "slghparse.cc" /* yacc.c:1646  */
+  case 330: /* anysymbol: SUBTABLESYM  */
+                                { (yyval.anysym) = (yyvsp[0].subtablesym); }
     break;
 
-  case 331:
-#line 571 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].valuesym); }
-#line 4095 "slghparse.cc" /* yacc.c:1646  */
+  case 331: /* anysymbol: VALUESYM  */
+                                { (yyval.anysym) = (yyvsp[0].valuesym); }
     break;
 
-  case 332:
-#line 572 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].valuemapsym); }
-#line 4101 "slghparse.cc" /* yacc.c:1646  */
+  case 332: /* anysymbol: VALUEMAPSYM  */
+                                { (yyval.anysym) = (yyvsp[0].valuemapsym); }
     break;
 
-  case 333:
-#line 573 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].contextsym); }
-#line 4107 "slghparse.cc" /* yacc.c:1646  */
+  case 333: /* anysymbol: CONTEXTSYM  */
+                                { (yyval.anysym) = (yyvsp[0].contextsym); }
     break;
 
-  case 334:
-#line 574 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].namesym); }
-#line 4113 "slghparse.cc" /* yacc.c:1646  */
+  case 334: /* anysymbol: NAMESYM  */
+                                { (yyval.anysym) = (yyvsp[0].namesym); }
     break;
 
-  case 335:
-#line 575 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].varsym); }
-#line 4119 "slghparse.cc" /* yacc.c:1646  */
+  case 335: /* anysymbol: VARSYM  */
+                                { (yyval.anysym) = (yyvsp[0].varsym); }
     break;
 
-  case 336:
-#line 576 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].varlistsym); }
-#line 4125 "slghparse.cc" /* yacc.c:1646  */
+  case 336: /* anysymbol: VARLISTSYM  */
+                                { (yyval.anysym) = (yyvsp[0].varlistsym); }
     break;
 
-  case 337:
-#line 577 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].operandsym); }
-#line 4131 "slghparse.cc" /* yacc.c:1646  */
+  case 337: /* anysymbol: OPERANDSYM  */
+                                { (yyval.anysym) = (yyvsp[0].operandsym); }
     break;
 
-  case 338:
-#line 578 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].startsym); }
-#line 4137 "slghparse.cc" /* yacc.c:1646  */
+  case 338: /* anysymbol: STARTSYM  */
+                                { (yyval.anysym) = (yyvsp[0].startsym); }
     break;
 
-  case 339:
-#line 579 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].endsym); }
-#line 4143 "slghparse.cc" /* yacc.c:1646  */
+  case 339: /* anysymbol: ENDSYM  */
+                                { (yyval.anysym) = (yyvsp[0].endsym); }
     break;
 
-  case 340:
-#line 580 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].next2sym); }
-#line 4149 "slghparse.cc" /* yacc.c:1646  */
+  case 340: /* anysymbol: NEXT2SYM  */
+                                { (yyval.anysym) = (yyvsp[0].next2sym); }
     break;
 
-  case 341:
-#line 581 "slghparse.y" /* yacc.c:1646  */
-    { (yyval.anysym) = (yyvsp[0].bitsym); }
-#line 4155 "slghparse.cc" /* yacc.c:1646  */
+  case 341: /* anysymbol: BITSYM  */
+                                { (yyval.anysym) = (yyvsp[0].bitsym); }
     break;
 
 
-#line 4159 "slghparse.cc" /* yacc.c:1646  */
+
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -4184,25 +3432,23 @@ yyreduce:
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
@@ -4213,50 +3459,14 @@ yyreduce:
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
     }
 
-
-
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -4285,12 +3495,11 @@ yyerrlab:
 | yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
 yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
 
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
@@ -4307,13 +3516,14 @@ yyerrorlab:
 yyerrlab1:
   yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
@@ -4327,7 +3537,7 @@ yyerrlab1:
 
 
       yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp);
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -4339,7 +3549,7 @@ yyerrlab1:
 
 
   /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -4350,26 +3560,30 @@ yyerrlab1:
 `-------------------------------------*/
 yyacceptlab:
   yyresult = 0;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
 /*-----------------------------------.
 | yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
 yyabortlab:
   yyresult = 1;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
 yyexhaustedlab:
   yyerror (YY_("memory exhausted"));
   yyresult = 2;
-  /* Fall through.  */
-#endif
+  goto yyreturnlab;
+
 
-yyreturn:
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
   if (yychar != YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
@@ -4385,20 +3599,17 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp);
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
+
   return yyresult;
 }
-#line 583 "slghparse.y" /* yacc.c:1906  */
+
 
 
 int yyerror(const char *s)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
index f52fe7abb..6917669ad 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
@@ -1,23 +1,9 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
 /* Bison interface for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -45,6 +31,10 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 #ifndef YY_YY_SLGHPARSE_HH_INCLUDED
 # define YY_YY_SLGHPARSE_HH_INCLUDED
 /* Debug traces.  */
@@ -55,132 +45,135 @@
 extern int yydebug;
 #endif
 
-/* Token type.  */
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
   enum yytokentype
   {
-    OP_BOOL_OR = 258,
-    OP_BOOL_AND = 259,
-    OP_BOOL_XOR = 260,
-    OP_OR = 261,
-    OP_XOR = 262,
-    OP_AND = 263,
-    OP_EQUAL = 264,
-    OP_NOTEQUAL = 265,
-    OP_FEQUAL = 266,
-    OP_FNOTEQUAL = 267,
-    OP_GREATEQUAL = 268,
-    OP_LESSEQUAL = 269,
-    OP_SLESS = 270,
-    OP_SGREATEQUAL = 271,
-    OP_SLESSEQUAL = 272,
-    OP_SGREAT = 273,
-    OP_FLESS = 274,
-    OP_FGREAT = 275,
-    OP_FLESSEQUAL = 276,
-    OP_FGREATEQUAL = 277,
-    OP_LEFT = 278,
-    OP_RIGHT = 279,
-    OP_SRIGHT = 280,
-    OP_FADD = 281,
-    OP_FSUB = 282,
-    OP_SDIV = 283,
-    OP_SREM = 284,
-    OP_FMULT = 285,
-    OP_FDIV = 286,
-    OP_ZEXT = 287,
-    OP_CARRY = 288,
-    OP_BORROW = 289,
-    OP_SEXT = 290,
-    OP_SCARRY = 291,
-    OP_SBORROW = 292,
-    OP_NAN = 293,
-    OP_ABS = 294,
-    OP_SQRT = 295,
-    OP_CEIL = 296,
-    OP_FLOOR = 297,
-    OP_ROUND = 298,
-    OP_INT2FLOAT = 299,
-    OP_FLOAT2FLOAT = 300,
-    OP_TRUNC = 301,
-    OP_CPOOLREF = 302,
-    OP_NEW = 303,
-    OP_POPCOUNT = 304,
-    BADINTEGER = 305,
-    GOTO_KEY = 306,
-    CALL_KEY = 307,
-    RETURN_KEY = 308,
-    IF_KEY = 309,
-    DEFINE_KEY = 310,
-    ATTACH_KEY = 311,
-    MACRO_KEY = 312,
-    SPACE_KEY = 313,
-    TYPE_KEY = 314,
-    RAM_KEY = 315,
-    DEFAULT_KEY = 316,
-    REGISTER_KEY = 317,
-    ENDIAN_KEY = 318,
-    WITH_KEY = 319,
-    ALIGN_KEY = 320,
-    OP_UNIMPL = 321,
-    TOKEN_KEY = 322,
-    SIGNED_KEY = 323,
-    NOFLOW_KEY = 324,
-    HEX_KEY = 325,
-    DEC_KEY = 326,
-    BIG_KEY = 327,
-    LITTLE_KEY = 328,
-    SIZE_KEY = 329,
-    WORDSIZE_KEY = 330,
-    OFFSET_KEY = 331,
-    NAMES_KEY = 332,
-    VALUES_KEY = 333,
-    VARIABLES_KEY = 334,
-    PCODEOP_KEY = 335,
-    IS_KEY = 336,
-    LOCAL_KEY = 337,
-    DELAYSLOT_KEY = 338,
-    CROSSBUILD_KEY = 339,
-    EXPORT_KEY = 340,
-    BUILD_KEY = 341,
-    CONTEXT_KEY = 342,
-    ELLIPSIS_KEY = 343,
-    GLOBALSET_KEY = 344,
-    BITRANGE_KEY = 345,
-    CHAR = 346,
-    INTEGER = 347,
-    INTB = 348,
-    STRING = 349,
-    SYMBOLSTRING = 350,
-    SPACESYM = 351,
-    SECTIONSYM = 352,
-    TOKENSYM = 353,
-    USEROPSYM = 354,
-    VALUESYM = 355,
-    VALUEMAPSYM = 356,
-    CONTEXTSYM = 357,
-    NAMESYM = 358,
-    VARSYM = 359,
-    BITSYM = 360,
-    SPECSYM = 361,
-    VARLISTSYM = 362,
-    OPERANDSYM = 363,
-    STARTSYM = 364,
-    ENDSYM = 365,
-    NEXT2SYM = 366,
-    MACROSYM = 367,
-    LABELSYM = 368,
-    SUBTABLESYM = 369
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    OP_BOOL_OR = 258,              /* OP_BOOL_OR  */
+    OP_BOOL_AND = 259,             /* OP_BOOL_AND  */
+    OP_BOOL_XOR = 260,             /* OP_BOOL_XOR  */
+    OP_OR = 261,                   /* OP_OR  */
+    OP_XOR = 262,                  /* OP_XOR  */
+    OP_AND = 263,                  /* OP_AND  */
+    OP_EQUAL = 264,                /* OP_EQUAL  */
+    OP_NOTEQUAL = 265,             /* OP_NOTEQUAL  */
+    OP_FEQUAL = 266,               /* OP_FEQUAL  */
+    OP_FNOTEQUAL = 267,            /* OP_FNOTEQUAL  */
+    OP_GREATEQUAL = 268,           /* OP_GREATEQUAL  */
+    OP_LESSEQUAL = 269,            /* OP_LESSEQUAL  */
+    OP_SLESS = 270,                /* OP_SLESS  */
+    OP_SGREATEQUAL = 271,          /* OP_SGREATEQUAL  */
+    OP_SLESSEQUAL = 272,           /* OP_SLESSEQUAL  */
+    OP_SGREAT = 273,               /* OP_SGREAT  */
+    OP_FLESS = 274,                /* OP_FLESS  */
+    OP_FGREAT = 275,               /* OP_FGREAT  */
+    OP_FLESSEQUAL = 276,           /* OP_FLESSEQUAL  */
+    OP_FGREATEQUAL = 277,          /* OP_FGREATEQUAL  */
+    OP_LEFT = 278,                 /* OP_LEFT  */
+    OP_RIGHT = 279,                /* OP_RIGHT  */
+    OP_SRIGHT = 280,               /* OP_SRIGHT  */
+    OP_FADD = 281,                 /* OP_FADD  */
+    OP_FSUB = 282,                 /* OP_FSUB  */
+    OP_SDIV = 283,                 /* OP_SDIV  */
+    OP_SREM = 284,                 /* OP_SREM  */
+    OP_FMULT = 285,                /* OP_FMULT  */
+    OP_FDIV = 286,                 /* OP_FDIV  */
+    OP_ZEXT = 287,                 /* OP_ZEXT  */
+    OP_CARRY = 288,                /* OP_CARRY  */
+    OP_BORROW = 289,               /* OP_BORROW  */
+    OP_SEXT = 290,                 /* OP_SEXT  */
+    OP_SCARRY = 291,               /* OP_SCARRY  */
+    OP_SBORROW = 292,              /* OP_SBORROW  */
+    OP_NAN = 293,                  /* OP_NAN  */
+    OP_ABS = 294,                  /* OP_ABS  */
+    OP_SQRT = 295,                 /* OP_SQRT  */
+    OP_CEIL = 296,                 /* OP_CEIL  */
+    OP_FLOOR = 297,                /* OP_FLOOR  */
+    OP_ROUND = 298,                /* OP_ROUND  */
+    OP_INT2FLOAT = 299,            /* OP_INT2FLOAT  */
+    OP_FLOAT2FLOAT = 300,          /* OP_FLOAT2FLOAT  */
+    OP_TRUNC = 301,                /* OP_TRUNC  */
+    OP_CPOOLREF = 302,             /* OP_CPOOLREF  */
+    OP_NEW = 303,                  /* OP_NEW  */
+    OP_POPCOUNT = 304,             /* OP_POPCOUNT  */
+    BADINTEGER = 305,              /* BADINTEGER  */
+    GOTO_KEY = 306,                /* GOTO_KEY  */
+    CALL_KEY = 307,                /* CALL_KEY  */
+    RETURN_KEY = 308,              /* RETURN_KEY  */
+    IF_KEY = 309,                  /* IF_KEY  */
+    DEFINE_KEY = 310,              /* DEFINE_KEY  */
+    ATTACH_KEY = 311,              /* ATTACH_KEY  */
+    MACRO_KEY = 312,               /* MACRO_KEY  */
+    SPACE_KEY = 313,               /* SPACE_KEY  */
+    TYPE_KEY = 314,                /* TYPE_KEY  */
+    RAM_KEY = 315,                 /* RAM_KEY  */
+    DEFAULT_KEY = 316,             /* DEFAULT_KEY  */
+    REGISTER_KEY = 317,            /* REGISTER_KEY  */
+    ENDIAN_KEY = 318,              /* ENDIAN_KEY  */
+    WITH_KEY = 319,                /* WITH_KEY  */
+    ALIGN_KEY = 320,               /* ALIGN_KEY  */
+    OP_UNIMPL = 321,               /* OP_UNIMPL  */
+    TOKEN_KEY = 322,               /* TOKEN_KEY  */
+    SIGNED_KEY = 323,              /* SIGNED_KEY  */
+    NOFLOW_KEY = 324,              /* NOFLOW_KEY  */
+    HEX_KEY = 325,                 /* HEX_KEY  */
+    DEC_KEY = 326,                 /* DEC_KEY  */
+    BIG_KEY = 327,                 /* BIG_KEY  */
+    LITTLE_KEY = 328,              /* LITTLE_KEY  */
+    SIZE_KEY = 329,                /* SIZE_KEY  */
+    WORDSIZE_KEY = 330,            /* WORDSIZE_KEY  */
+    OFFSET_KEY = 331,              /* OFFSET_KEY  */
+    NAMES_KEY = 332,               /* NAMES_KEY  */
+    VALUES_KEY = 333,              /* VALUES_KEY  */
+    VARIABLES_KEY = 334,           /* VARIABLES_KEY  */
+    PCODEOP_KEY = 335,             /* PCODEOP_KEY  */
+    IS_KEY = 336,                  /* IS_KEY  */
+    LOCAL_KEY = 337,               /* LOCAL_KEY  */
+    DELAYSLOT_KEY = 338,           /* DELAYSLOT_KEY  */
+    CROSSBUILD_KEY = 339,          /* CROSSBUILD_KEY  */
+    EXPORT_KEY = 340,              /* EXPORT_KEY  */
+    BUILD_KEY = 341,               /* BUILD_KEY  */
+    CONTEXT_KEY = 342,             /* CONTEXT_KEY  */
+    ELLIPSIS_KEY = 343,            /* ELLIPSIS_KEY  */
+    GLOBALSET_KEY = 344,           /* GLOBALSET_KEY  */
+    BITRANGE_KEY = 345,            /* BITRANGE_KEY  */
+    CHAR = 346,                    /* CHAR  */
+    INTEGER = 347,                 /* INTEGER  */
+    INTB = 348,                    /* INTB  */
+    STRING = 349,                  /* STRING  */
+    SYMBOLSTRING = 350,            /* SYMBOLSTRING  */
+    SPACESYM = 351,                /* SPACESYM  */
+    SECTIONSYM = 352,              /* SECTIONSYM  */
+    TOKENSYM = 353,                /* TOKENSYM  */
+    USEROPSYM = 354,               /* USEROPSYM  */
+    VALUESYM = 355,                /* VALUESYM  */
+    VALUEMAPSYM = 356,             /* VALUEMAPSYM  */
+    CONTEXTSYM = 357,              /* CONTEXTSYM  */
+    NAMESYM = 358,                 /* NAMESYM  */
+    VARSYM = 359,                  /* VARSYM  */
+    BITSYM = 360,                  /* BITSYM  */
+    SPECSYM = 361,                 /* SPECSYM  */
+    VARLISTSYM = 362,              /* VARLISTSYM  */
+    OPERANDSYM = 363,              /* OPERANDSYM  */
+    STARTSYM = 364,                /* STARTSYM  */
+    ENDSYM = 365,                  /* ENDSYM  */
+    NEXT2SYM = 366,                /* NEXT2SYM  */
+    MACROSYM = 367,                /* MACROSYM  */
+    LABELSYM = 368,                /* LABELSYM  */
+    SUBTABLESYM = 369              /* SUBTABLESYM  */
   };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 29 "slghparse.y" /* yacc.c:1909  */
 
   char ch;
   uintb *i;
@@ -225,9 +218,8 @@ union YYSTYPE
   FamilySymbol *famsym;
   SpecificSymbol *specsym;
 
-#line 214 "slghparse.hh" /* yacc.c:1909  */
-};
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
@@ -236,6 +228,8 @@ typedef union YYSTYPE YYSTYPE;
 
 extern YYSTYPE yylval;
 
+
 int yyparse (void);
 
+
 #endif /* !YY_YY_SLGHPARSE_HH_INCLUDED  */
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
index 1ac87e2cd..78865a73b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
@@ -1,21 +1,3 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#line 2 "slghscan.cc"
-
-#line 4 "slghscan.cc"
 
 #define  YY_INT_ALIGNED short int
 
@@ -23,8 +5,8 @@
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 37
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -99,65 +81,61 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
 #endif /* ! C99 */
 
 #endif /* ! FLEXINT_H */
 
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
+/* begin standard C++ headers. */
 
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
+/* TODO: this is always defined, so inline it */
 #define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
 #else
-#define yyconst
+#define yynoreturn
 #endif
 
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
  */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
 
 /* Enter a start condition.  This macro really ought to take a parameter,
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
 #define BEGIN (yy_start) = 1 + 2 *
-
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
 #define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
-
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
+#define YY_NEW_FILE yyrestart( yyin  )
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -174,7 +152,7 @@ typedef struct yy_buffer_state *YY_BUFFER_STATE;
 typedef size_t yy_size_t;
 #endif
 
-extern yy_size_t yyleng;
+extern int yyleng;
 
 extern FILE *yyin, *yyout;
 
@@ -182,7 +160,27 @@ extern FILE *yyin, *yyout;
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-    #define YY_LESS_LINENO(n)
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex.
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
+    #define YY_LINENO_REWIND_TO(dst) \
+            do {\
+                const char *p;\
+                for ( p = yy_cp-1; p >= (dst); --p)\
+                    if ( *p == '\n' )\
+                        --yylineno;\
+            }while(0)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -197,7 +195,6 @@ extern FILE *yyin, *yyout;
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
-
 #define unput(c) yyunput( c, (yytext_ptr)  )
 
 #ifndef YY_STRUCT_YY_BUFFER_STATE
@@ -212,12 +209,12 @@ struct yy_buffer_state
 	/* Size of input buffer in bytes, not including room for EOB
 	 * characters.
 	 */
-	yy_size_t yy_buf_size;
+	int yy_buf_size;
 
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
 	 */
-	yy_size_t yy_n_chars;
+	int yy_n_chars;
 
 	/* Whether we "own" the buffer - i.e., we know we created it,
 	 * and can realloc() it to grow it, and should free() it to
@@ -240,7 +237,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -268,7 +265,7 @@ struct yy_buffer_state
 /* Stack of input buffers. */
 static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
 static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
@@ -279,7 +276,6 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                           : NULL)
-
 /* Same as previous macro, but useful when we know that the buffer stack is not
  * NULL or when we need an lvalue. For internal use only.
  */
@@ -287,11 +283,11 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
-static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
-yy_size_t yyleng;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
 
 /* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
+static char *yy_c_buf_p = NULL;
 static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
@@ -300,80 +296,77 @@ static int yy_start = 0;	/* start state number */
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
 
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
 
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
 
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
 
 #define yy_new_buffer yy_create_buffer
-
 #define yy_set_interactive(is_interactive) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){ \
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
-
 #define yy_set_bol(at_bol) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){\
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
-
 #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
-typedef unsigned char YY_CHAR;
+typedef flex_uint8_t YY_CHAR;
 
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+FILE *yyin = NULL, *yyout = NULL;
 
 typedef int yy_state_type;
 
+#define YY_FLEX_LEX_COMPAT
 extern int yylineno;
-
 int yylineno = 1;
 
-extern char *yytext;
-#define yytext_ptr yytext
+extern char yytext[];
 
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
 	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
+	yyleng = (int) (yy_cp - yy_bp); \
 	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
+	if ( yyleng >= YYLMAX ) \
+		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
+	yy_flex_strncpy( yytext, (yytext_ptr), yyleng + 1 ); \
 	(yy_c_buf_p) = yy_cp;
-
 #define YY_NUM_RULES 164
 #define YY_END_OF_BUFFER 165
 /* This struct is not used in this scanner,
@@ -383,7 +376,7 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[527] =
+static const flex_int16_t yy_accept[527] =
     {   0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,  165,   14,    7,    8,    6,   14,
@@ -445,7 +438,7 @@ static yyconst flex_int16_t yy_accept[527] =
        51,  139,   51,   51,   31,    0
     } ;
 
-static yyconst flex_int32_t yy_ec[256] =
+static const YY_CHAR yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         2,    1,    2,    1,    1,    1,    1,    1,    1,    1,
@@ -477,7 +470,7 @@ static yyconst flex_int32_t yy_ec[256] =
        11,   11,   11,   11,   11
     } ;
 
-static yyconst flex_int32_t yy_meta[67] =
+static const YY_CHAR yy_meta[67] =
     {   0,
         1,    1,    2,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    4,    3,    3,    3,    3,    5,    3,    6,
@@ -488,7 +481,7 @@ static yyconst flex_int32_t yy_meta[67] =
         5,    5,    3,    3,    3,    3
     } ;
 
-static yyconst flex_int16_t yy_base[564] =
+static const flex_int16_t yy_base[564] =
     {   0,
         0,  931,   66,  930,  132,  929,  198,  928,  264,  927,
       330,  926,    0,  394,  955,  962,  396,  962,    0,  942,
@@ -554,7 +547,7 @@ static yyconst flex_int16_t yy_base[564] =
       666,  669,  672
     } ;
 
-static yyconst flex_int16_t yy_def[564] =
+static const flex_int16_t yy_def[564] =
     {   0,
       526,    1,  526,    3,  526,    5,  526,    7,  526,    9,
       526,   11,  527,  528,  526,  526,  526,  526,  529,  526,
@@ -620,7 +613,7 @@ static yyconst flex_int16_t yy_def[564] =
       526,  526,  526
     } ;
 
-static yyconst flex_int16_t yy_nxt[1029] =
+static const flex_int16_t yy_nxt[1029] =
     {   0,
        16,   17,   18,   17,   16,   16,   19,   20,   16,   16,
        16,   21,   21,   16,   16,   21,   21,   22,   16,   16,
@@ -737,7 +730,7 @@ static yyconst flex_int16_t yy_nxt[1029] =
       526,  526,  526,  526,  526,  526,  526,  526
     } ;
 
-static yyconst flex_int16_t yy_chk[1029] =
+static const flex_int16_t yy_chk[1029] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -854,6 +847,19 @@ static yyconst flex_int16_t yy_chk[1029] =
       526,  526,  526,  526,  526,  526,  526,  526
     } ;
 
+/* Table of booleans, true if rule could match eol. */
+static const flex_int32_t yy_rule_can_match_eol[165] =
+    {   0,
+1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+    0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
+    0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    1, 0, 1, 1, 0,     };
+
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
@@ -867,8 +873,12 @@ int yy_flex_debug = 0;
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "slghscan.l"
+#ifndef YYLMAX
+#define YYLMAX 8192
+#endif
+
+char yytext[YYLMAX];
+char *yytext_ptr;
 /* ###
  * IP: GHIDRA
  * NOTE: flex skeletons are NOT bound by flex's BSD license
@@ -885,7 +895,6 @@ char *yytext;
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#line 18 "slghscan.l"
 #include "slgh_compile.hh"
 #include "slghparse.hh"
 #define yywrap() 1
@@ -1125,7 +1134,7 @@ int4 preprocess(int4 cur_state,int4 blank_state)
       if (yyin == (FILE *)0)
         preproc_error("Could not open included file "+fname);
       filebuffers.back().file = yyin;
-      yy_switch_to_buffer(yy_create_buffer(yyin,YY_BUF_SIZE) );
+      yy_switch_to_buffer( yy_create_buffer(yyin, YY_BUF_SIZE) );
       check_to_endofline(s);
     }
   }
@@ -1248,7 +1257,7 @@ void preproc_macroexpand(void)
   string value;
   if (!slgh->getPreprocValue(macro,value))
     preproc_error("Unknown preprocessing macro "+macro);
-  yy_switch_to_buffer(yy_scan_string(value.c_str() ) );
+  yy_switch_to_buffer( yy_scan_string( value.c_str() ) );
   slgh->parsePreprocMacro();
 }
 
@@ -1353,14 +1362,6 @@ int4 scan_number(char *numtext,YYSTYPE *lval,bool signednum)
   return INTEGER;
 }
 
-
-
-
-
-
-
-#line 1348 "slghscan.cc"
-
 #define INITIAL 0
 #define defblock 1
 #define macroblock 2
@@ -1381,36 +1382,36 @@ int4 scan_number(char *numtext,YYSTYPE *lval,bool signednum)
 #define YY_EXTRA_TYPE void *
 #endif
 
-static int yy_init_globals (void );
+static int yy_init_globals ( void );
 
 /* Accessor methods to globals.
    These are made visible to non-reentrant scanners for convenience. */
 
-int yylex_destroy (void );
+int yylex_destroy ( void );
 
-int yyget_debug (void );
+int yyget_debug ( void );
 
-void yyset_debug (int debug_flag  );
+void yyset_debug ( int debug_flag  );
 
-YY_EXTRA_TYPE yyget_extra (void );
+YY_EXTRA_TYPE yyget_extra ( void );
 
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
 
-FILE *yyget_in (void );
+FILE *yyget_in ( void );
 
-void yyset_in  (FILE * in_str  );
+void yyset_in  ( FILE * _in_str  );
 
-FILE *yyget_out (void );
+FILE *yyget_out ( void );
 
-void yyset_out  (FILE * out_str  );
+void yyset_out  ( FILE * _out_str  );
 
-yy_size_t yyget_leng (void );
+			int yyget_leng ( void );
 
-char *yyget_text (void );
+char *yyget_text ( void );
 
-int yyget_lineno (void );
+int yyget_lineno ( void );
 
-void yyset_lineno (int line_number  );
+void yyset_lineno ( int _line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -1418,35 +1419,43 @@ void yyset_lineno (int line_number  );
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap (void );
+extern "C" int yywrap ( void );
 #else
-extern int yywrap (void );
+extern int yywrap ( void );
 #endif
 #endif
 
-    static void yyunput (int c,char *buf_ptr  );
+#ifndef YY_NO_UNPUT
     
+    static void yyunput ( int c, char *buf_ptr  );
+
+#endif
+
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
+static void yy_flex_strncpy ( char *, const char *, int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
+static int yy_flex_strlen ( const char * );
 #endif
 
 #ifndef YY_NO_INPUT
-
 #ifdef __cplusplus
-static int yyinput (void );
+static int yyinput ( void );
 #else
-static int input (void );
+static int input ( void );
 #endif
 
 #endif
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -1454,7 +1463,7 @@ static int input (void );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1465,7 +1474,7 @@ static int input (void );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		size_t n; \
+		int n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -1478,7 +1487,7 @@ static int input (void );
 	else \
 		{ \
 		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
 			{ \
 			if( errno != EINTR) \
 				{ \
@@ -1533,7 +1542,7 @@ extern int yylex (void);
 
 /* Code executed at the end of each rule. */
 #ifndef YY_BREAK
-#define YY_BREAK break;
+#define YY_BREAK /*LINTED*/break;
 #endif
 
 #define YY_RULE_SETUP \
@@ -1546,15 +1555,10 @@ extern int yylex (void);
  */
 YY_DECL
 {
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
     
-#line 493 "slghscan.l"
-
-
-#line 1542 "slghscan.cc"
-
 	if ( !(yy_init) )
 		{
 		(yy_init) = 1;
@@ -1575,13 +1579,15 @@ YY_DECL
 		if ( ! YY_CURRENT_BUFFER ) {
 			yyensure_buffer_stack ();
 			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
+				yy_create_buffer( yyin, YY_BUF_SIZE );
 		}
 
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		}
 
-	while ( 1 )		/* loops until end-of-file is reached */
+	{
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
 		yy_cp = (yy_c_buf_p);
 
@@ -1598,7 +1604,7 @@ YY_DECL
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
 				(yy_last_accepting_state) = yy_current_state;
@@ -1608,9 +1614,9 @@ yy_match:
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
 				if ( yy_current_state >= 527 )
-					yy_c = yy_meta[(unsigned int) yy_c];
+					yy_c = yy_meta[yy_c];
 				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 			++yy_cp;
 			}
 		while ( yy_base[yy_current_state] != 962 );
@@ -1626,6 +1632,16 @@ yy_find_action:
 
 		YY_DO_BEFORE_ACTION;
 
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+
+    yylineno++;
+;
+			}
+
 do_action:	/* This label is used only to access EOF actions. */
 
 		switch ( yy_act )
@@ -1640,830 +1656,667 @@ do_action:	/* This label is used only to access EOF actions. */
 case 1:
 /* rule 1 can match eol */
 YY_RULE_SETUP
-#line 495 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(INITIAL,preproc) ); }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 496 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 497 "slghscan.l"
 { yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 498 "slghscan.l"
 { BEGIN(print); slgh->calcContextLayout(); yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 499 "slghscan.l"
 { BEGIN(sem); yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 500 "slghscan.l"
 
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 501 "slghscan.l"
 
 	YY_BREAK
 case 8:
 /* rule 8 can match eol */
 YY_RULE_SETUP
-#line 502 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 503 "slghscan.l"
 { BEGIN(macroblock); return MACRO_KEY; }
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 504 "slghscan.l"
 { BEGIN(defblock); return DEFINE_KEY; }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 505 "slghscan.l"
 { BEGIN(defblock); slgh->calcContextLayout(); return ATTACH_KEY; }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 506 "slghscan.l"
 { BEGIN(pattern); withsection = 1; slgh->calcContextLayout(); return WITH_KEY; }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 507 "slghscan.l"
 {  return find_symbol();  }
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 508 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 15:
 /* rule 15 can match eol */
 YY_RULE_SETUP
-#line 510 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(macroblock,preproc) ); }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 511 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 512 "slghscan.l"
 { yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 513 "slghscan.l"
 { BEGIN(sem); return yytext[0]; }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 514 "slghscan.l"
 {  yylval.str = new string(yytext); return STRING;  }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 515 "slghscan.l"
 
 	YY_BREAK
 case 21:
 /* rule 21 can match eol */
 YY_RULE_SETUP
-#line 516 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 517 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 23:
 /* rule 23 can match eol */
 YY_RULE_SETUP
-#line 519 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(defblock,preproc) ); }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 520 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 521 "slghscan.l"
 { yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 522 "slghscan.l"
 { BEGIN(INITIAL); yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 523 "slghscan.l"
 { return SPACE_KEY; }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 524 "slghscan.l"
 { return TYPE_KEY; }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 525 "slghscan.l"
 { return RAM_KEY; }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 526 "slghscan.l"
 { return DEFAULT_KEY; }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 527 "slghscan.l"
 { return REGISTER_KEY; }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 528 "slghscan.l"
 { return TOKEN_KEY; }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 529 "slghscan.l"
 { return CONTEXT_KEY; }
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 530 "slghscan.l"
 { return BITRANGE_KEY; }
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 531 "slghscan.l"
 { return SIGNED_KEY; }
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 532 "slghscan.l"
 { return NOFLOW_KEY; }
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 533 "slghscan.l"
 { return HEX_KEY; }
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 534 "slghscan.l"
 { return DEC_KEY; }
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 535 "slghscan.l"
 { return ENDIAN_KEY; }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 536 "slghscan.l"
 { return ALIGN_KEY; }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 537 "slghscan.l"
 { return BIG_KEY; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 538 "slghscan.l"
 { return LITTLE_KEY; }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 539 "slghscan.l"
 { return SIZE_KEY; }
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 540 "slghscan.l"
 { return WORDSIZE_KEY; }
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 541 "slghscan.l"
 { return OFFSET_KEY; }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 542 "slghscan.l"
 { return NAMES_KEY; }
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 543 "slghscan.l"
 { return VALUES_KEY; }
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 544 "slghscan.l"
 { return VARIABLES_KEY; }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 545 "slghscan.l"
 { return PCODEOP_KEY; }
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 546 "slghscan.l"
 
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 547 "slghscan.l"
 {  return find_symbol();  }
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 548 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 549 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 550 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 551 "slghscan.l"
 { yylval.str = new string(yytext+1,strlen(yytext)-2); return STRING; }
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 552 "slghscan.l"
 
 	YY_BREAK
 case 57:
 /* rule 57 can match eol */
 YY_RULE_SETUP
-#line 553 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 554 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 59:
 /* rule 59 can match eol */
 YY_RULE_SETUP
-#line 557 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(print,preproc) ); }
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 558 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 559 "slghscan.l"
 { yylval.ch = yytext[0]; return CHAR; }
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 560 "slghscan.l"
 { yylval.ch = '^'; return '^'; }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 561 "slghscan.l"
 { BEGIN(pattern); actionon=0; return IS_KEY; }
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 562 "slghscan.l"
 {  yylval.str = new string(yytext); return SYMBOLSTRING;  }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 563 "slghscan.l"
 { yylval.str = new string(yytext+1,strlen(yytext)-2); return STRING; }
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 564 "slghscan.l"
 { yylval.ch = ' '; return ' '; }
 	YY_BREAK
 case 67:
 /* rule 67 can match eol */
 YY_RULE_SETUP
-#line 565 "slghscan.l"
 { slgh->nextLine(); return ' '; }
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 566 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 69:
 /* rule 69 can match eol */
 YY_RULE_SETUP
-#line 568 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(pattern,preproc) ); }
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 569 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 570 "slghscan.l"
 { BEGIN((withsection==1) ? INITIAL:sem); withsection=0; yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 571 "slghscan.l"
 { BEGIN(INITIAL); return OP_UNIMPL; }
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 572 "slghscan.l"
 { return GLOBALSET_KEY; }
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 573 "slghscan.l"
 { return OP_RIGHT; }
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 574 "slghscan.l"
 { return OP_LEFT; }
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 575 "slghscan.l"
 { return OP_NOTEQUAL; }
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 576 "slghscan.l"
 { return OP_LESSEQUAL; }
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 577 "slghscan.l"
 { return OP_GREATEQUAL; }
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 578 "slghscan.l"
 { return OP_AND; }
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 579 "slghscan.l"
 { return OP_OR; }
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 580 "slghscan.l"
 { return OP_XOR; }
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 581 "slghscan.l"
 { return ELLIPSIS_KEY; }
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 582 "slghscan.l"
 { actionon = 1; yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 583 "slghscan.l"
 { actionon = 0; yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 584 "slghscan.l"
 { yylval.ch = yytext[0];  return (actionon==0) ? yytext[0] : OP_AND; }
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 585 "slghscan.l"
 { yylval.ch = yytext[0];  return (actionon==0) ? yytext[0] : OP_OR; }
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 586 "slghscan.l"
 { return OP_XOR; }
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 587 "slghscan.l"
 { yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 588 "slghscan.l"
 
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 589 "slghscan.l"
 { return find_symbol();   }
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 590 "slghscan.l"
 { return scan_number(yytext,&yylval,true); }
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 591 "slghscan.l"
 { return scan_number(yytext,&yylval,true); }
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 592 "slghscan.l"
 { return scan_number(yytext,&yylval,true); }
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 593 "slghscan.l"
 
 	YY_BREAK
 case 95:
 /* rule 95 can match eol */
 YY_RULE_SETUP
-#line 594 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 595 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 97:
 /* rule 97 can match eol */
 YY_RULE_SETUP
-#line 597 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(sem,preproc) ); }
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 598 "slghscan.l"
 { preproc_macroexpand(); }
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 599 "slghscan.l"
 { BEGIN(INITIAL); yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 600 "slghscan.l"
 { return OP_BOOL_OR; }
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 601 "slghscan.l"
 { return OP_BOOL_AND; }
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 602 "slghscan.l"
 { return OP_BOOL_XOR; }
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 603 "slghscan.l"
 { return OP_RIGHT; }
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 604 "slghscan.l"
 { return OP_LEFT; }
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 605 "slghscan.l"
 { return OP_EQUAL; }
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 606 "slghscan.l"
 { return OP_NOTEQUAL; }
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 607 "slghscan.l"
 { return OP_LESSEQUAL; }
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 608 "slghscan.l"
 { return OP_GREATEQUAL; }
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 609 "slghscan.l"
 { return OP_SDIV; }
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 610 "slghscan.l"
 { return OP_SREM; }
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 611 "slghscan.l"
 { return OP_SRIGHT; }
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 612 "slghscan.l"
 { return OP_SLESS; }
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 613 "slghscan.l"
 { return OP_SGREAT; }
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 614 "slghscan.l"
 { return OP_SLESSEQUAL; }
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 615 "slghscan.l"
 { return OP_SGREATEQUAL; }
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 616 "slghscan.l"
 { return OP_FADD; }
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 617 "slghscan.l"
 { return OP_FSUB; }
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 618 "slghscan.l"
 { return OP_FMULT; }
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 619 "slghscan.l"
 { return OP_FDIV; }
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 620 "slghscan.l"
 { return OP_FEQUAL; }
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 621 "slghscan.l"
 { return OP_FNOTEQUAL; }
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 622 "slghscan.l"
 { return OP_FLESS; }
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 623 "slghscan.l"
 { return OP_FGREAT; }
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 624 "slghscan.l"
 { return OP_FLESSEQUAL; }
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-#line 625 "slghscan.l"
 { return OP_FGREATEQUAL; }
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 626 "slghscan.l"
 { return OP_ZEXT; }
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 627 "slghscan.l"
 { return OP_CARRY; }
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 628 "slghscan.l"
 { return OP_BORROW; }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 629 "slghscan.l"
 { return OP_SEXT; }
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 630 "slghscan.l"
 { return OP_SCARRY; }
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 631 "slghscan.l"
 { return OP_SBORROW; }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 632 "slghscan.l"
 { return OP_NAN; }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 633 "slghscan.l"
 { return OP_ABS; }
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 634 "slghscan.l"
 { return OP_SQRT; }
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 635 "slghscan.l"
 { return OP_CEIL; }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 636 "slghscan.l"
 { return OP_FLOOR; }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 637 "slghscan.l"
 { return OP_ROUND; }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 638 "slghscan.l"
 { return OP_INT2FLOAT; }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 639 "slghscan.l"
 { return OP_FLOAT2FLOAT; }
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 640 "slghscan.l"
 { return OP_TRUNC; }
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 641 "slghscan.l"
 { return OP_CPOOLREF; }
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 642 "slghscan.l"
 { return OP_NEW; }
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
-#line 643 "slghscan.l"
 { return OP_POPCOUNT; }
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 644 "slghscan.l"
 { return IF_KEY; }
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 645 "slghscan.l"
 { return GOTO_KEY; }
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 646 "slghscan.l"
 { return CALL_KEY; }
 	YY_BREAK
 case 147:
 YY_RULE_SETUP
-#line 647 "slghscan.l"
 { return RETURN_KEY; }
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 648 "slghscan.l"
 { return DELAYSLOT_KEY; }
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 649 "slghscan.l"
 { return CROSSBUILD_KEY; }
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 650 "slghscan.l"
 { return EXPORT_KEY; }
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
-#line 651 "slghscan.l"
 { return BUILD_KEY; }
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 652 "slghscan.l"
 { return LOCAL_KEY; }
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 653 "slghscan.l"
 { yylval.ch = yytext[0]; return yytext[0]; }
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 654 "slghscan.l"
 
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 655 "slghscan.l"
 { return find_symbol();   }
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
-#line 656 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 657 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 658 "slghscan.l"
 { return scan_number(yytext,&yylval,false); }
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 659 "slghscan.l"
 
 	YY_BREAK
 case 160:
 /* rule 160 can match eol */
 YY_RULE_SETUP
-#line 660 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 661 "slghscan.l"
 { return yytext[0]; }
 	YY_BREAK
 case 162:
 /* rule 162 can match eol */
 YY_RULE_SETUP
-#line 663 "slghscan.l"
 { slgh->nextLine(); BEGIN( preprocess(preproc,preproc) ); }
 	YY_BREAK
 case 163:
 /* rule 163 can match eol */
 YY_RULE_SETUP
-#line 664 "slghscan.l"
 { slgh->nextLine(); }
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
@@ -2473,11 +2326,10 @@ case YY_STATE_EOF(print):
 case YY_STATE_EOF(pattern):
 case YY_STATE_EOF(sem):
 case YY_STATE_EOF(preproc):
-#line 666 "slghscan.l"
-{ yy_delete_buffer(YY_CURRENT_BUFFER );
+{ yy_delete_buffer( YY_CURRENT_BUFFER );
           if (filebuffers.empty())
             yyterminate(); 
-          yy_switch_to_buffer(filebuffers.back().lastbuffer );
+          yy_switch_to_buffer( filebuffers.back().lastbuffer );
 	  FILE *curfile = filebuffers.back().file;
 	  if (curfile != (FILE *)0)
 	    fclose(curfile);
@@ -2487,10 +2339,8 @@ case YY_STATE_EOF(preproc):
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 676 "slghscan.l"
 ECHO;
 	YY_BREAK
-#line 2479 "slghscan.cc"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2566,7 +2416,7 @@ ECHO;
 				{
 				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap( ) )
+				if ( yywrap(  ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -2619,6 +2469,7 @@ ECHO;
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 } /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
@@ -2630,9 +2481,9 @@ ECHO;
  */
 static int yy_get_next_buffer (void)
 {
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
+	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
 	int ret_val;
 
 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
@@ -2661,7 +2512,7 @@ static int yy_get_next_buffer (void)
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
@@ -2674,7 +2525,7 @@ static int yy_get_next_buffer (void)
 
 	else
 		{
-			yy_size_t num_to_read =
+			int num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
@@ -2688,7 +2539,7 @@ static int yy_get_next_buffer (void)
 
 			if ( b->yy_is_our_buffer )
 				{
-				yy_size_t new_size = b->yy_buf_size * 2;
+				int new_size = b->yy_buf_size * 2;
 
 				if ( new_size <= 0 )
 					b->yy_buf_size += b->yy_buf_size / 8;
@@ -2697,11 +2548,12 @@ static int yy_get_next_buffer (void)
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
+				b->yy_ch_buf = NULL;
 
 			if ( ! b->yy_ch_buf )
 				YY_FATAL_ERROR(
@@ -2729,7 +2581,7 @@ static int yy_get_next_buffer (void)
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
+			yyrestart( yyin  );
 			}
 
 		else
@@ -2743,12 +2595,15 @@ static int yy_get_next_buffer (void)
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
 		/* Extend the array by 50%, plus the number we really need. */
-		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
 	}
 
 	(yy_n_chars) += number_to_move;
@@ -2764,15 +2619,15 @@ static int yy_get_next_buffer (void)
 
     static yy_state_type yy_get_previous_state (void)
 {
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
+	yy_state_type yy_current_state;
+	char *yy_cp;
     
 	yy_current_state = (yy_start);
 	yy_current_state += YY_AT_BOL();
 
 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
 			(yy_last_accepting_state) = yy_current_state;
@@ -2782,9 +2637,9 @@ static int yy_get_next_buffer (void)
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
 			if ( yy_current_state >= 527 )
-				yy_c = yy_meta[(unsigned int) yy_c];
+				yy_c = yy_meta[yy_c];
 			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 		}
 
 	return yy_current_state;
@@ -2797,10 +2652,10 @@ static int yy_get_next_buffer (void)
  */
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
 {
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
+	int yy_is_jam;
+	char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 1;
+	YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
 		(yy_last_accepting_state) = yy_current_state;
@@ -2810,17 +2665,19 @@ static int yy_get_next_buffer (void)
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
 		if ( yy_current_state >= 527 )
-			yy_c = yy_meta[(unsigned int) yy_c];
+			yy_c = yy_meta[yy_c];
 		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 	yy_is_jam = (yy_current_state == 526);
 
 		return yy_is_jam ? 0 : yy_current_state;
 }
 
-    static void yyunput (int c, register char * yy_bp )
+#ifndef YY_NO_UNPUT
+
+    static void yyunput (int c, char * yy_bp )
 {
-	register char *yy_cp;
+	char *yy_cp;
     
     yy_cp = (yy_c_buf_p);
 
@@ -2830,10 +2687,10 @@ static int yy_get_next_buffer (void)
 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register yy_size_t number_to_move = (yy_n_chars) + 2;
-		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+		int number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		register char *source =
+		char *source =
 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
@@ -2842,7 +2699,7 @@ static int yy_get_next_buffer (void)
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
@@ -2850,11 +2707,17 @@ static int yy_get_next_buffer (void)
 
 	*--yy_cp = (char) c;
 
+    if ( c == '\n' ){
+        --yylineno;
+    }
+
 	(yytext_ptr) = yy_bp;
 	(yy_hold_char) = *yy_cp;
 	(yy_c_buf_p) = yy_cp;
 }
 
+#endif
+
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
     static int yyinput (void)
@@ -2879,7 +2742,7 @@ static int yy_get_next_buffer (void)
 
 		else
 			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
 			++(yy_c_buf_p);
 
 			switch ( yy_get_next_buffer(  ) )
@@ -2896,14 +2759,14 @@ static int yy_get_next_buffer (void)
 					 */
 
 					/* Reset buffer status. */
-					yyrestart(yyin );
+					yyrestart( yyin );
 
 					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap( ) )
-						return EOF;
+					if ( yywrap(  ) )
+						return 0;
 
 					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
@@ -2926,6 +2789,10 @@ static int yy_get_next_buffer (void)
 	(yy_hold_char) = *++(yy_c_buf_p);
 
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
+
+    yylineno++;
+;
 
 	return c;
 }
@@ -2942,11 +2809,11 @@ static int yy_get_next_buffer (void)
 	if ( ! YY_CURRENT_BUFFER ){
         yyensure_buffer_stack ();
 		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
+            yy_create_buffer( yyin, YY_BUF_SIZE );
 	}
 
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
 }
 
 /** Switch to a different input buffer.
@@ -2974,7 +2841,7 @@ static int yy_get_next_buffer (void)
 		}
 
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
@@ -3002,7 +2869,7 @@ static void yy_load_buffer_state  (void)
 {
 	YY_BUFFER_STATE b;
     
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -3011,13 +2878,13 @@ static void yy_load_buffer_state  (void)
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer(b,file );
+	yy_init_buffer( b, file );
 
 	return b;
 }
@@ -3036,9 +2903,9 @@ static void yy_load_buffer_state  (void)
 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
+		yyfree( (void *) b->yy_ch_buf  );
 
-	yyfree((void *) b  );
+	yyfree( (void *) b  );
 }
 
 /* Initializes or reinitializes a buffer.
@@ -3050,7 +2917,7 @@ static void yy_load_buffer_state  (void)
 {
 	int oerrno = errno;
     
-	yy_flush_buffer(b );
+	yy_flush_buffer( b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
@@ -3093,7 +2960,7 @@ static void yy_load_buffer_state  (void)
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
 	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 }
 
 /** Pushes the new state onto the stack. The new state becomes
@@ -3124,7 +2991,7 @@ void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 
 	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
@@ -3143,7 +3010,7 @@ void yypop_buffer_state (void)
 		--(yy_buffer_stack_top);
 
 	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		(yy_did_buffer_switch_on_eof) = 1;
 	}
 }
@@ -3161,15 +3028,15 @@ static void yyensure_buffer_stack (void)
 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 		 * immediate realloc on the next call.
          */
-		num_to_alloc = 1;
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
 		if ( ! (yy_buffer_stack) )
 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
+
 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		(yy_buffer_stack_max) = num_to_alloc;
 		(yy_buffer_stack_top) = 0;
 		return;
@@ -3178,7 +3045,7 @@ static void yyensure_buffer_stack (void)
 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
 
 		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
 
 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
@@ -3198,7 +3065,7 @@ static void yyensure_buffer_stack (void)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * 
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
 {
@@ -3208,23 +3075,23 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
-		return 0;
+		return NULL;
 
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
 	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
+	b->yy_input_file = NULL;
 	b->yy_n_chars = b->yy_buf_size;
 	b->yy_is_interactive = 0;
 	b->yy_at_bol = 1;
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer(b  );
+	yy_switch_to_buffer( b  );
 
 	return b;
 }
@@ -3237,10 +3104,10 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
  * @note If you want to scan bytes that may contain NUL values, then use
  *       yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
 {
     
-	return yy_scan_bytes(yystr,strlen(yystr) );
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
@@ -3250,7 +3117,7 @@ YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
  * 
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
 {
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -3258,8 +3125,8 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len
 	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
@@ -3268,7 +3135,7 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len
 
 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer(buf,n );
+	b = yy_scan_buffer( buf, n );
 	if ( ! b )
 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
@@ -3284,9 +3151,9 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg )
+static void yynoreturn yy_fatal_error (const char* msg )
 {
-    	(void) fprintf( stderr, "%s\n", msg );
+			fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -3314,7 +3181,7 @@ static void yy_fatal_error (yyconst char* msg )
  */
 int yyget_lineno  (void)
 {
-        
+
     return yylineno;
 }
 
@@ -3337,7 +3204,7 @@ FILE *yyget_out  (void)
 /** Get the length of the current token.
  * 
  */
-yy_size_t yyget_leng  (void)
+int yyget_leng  (void)
 {
         return yyleng;
 }
@@ -3352,29 +3219,29 @@ char *yyget_text  (void)
 }
 
 /** Set the current line number.
- * @param line_number
+ * @param _line_number line number
  * 
  */
-void yyset_lineno (int  line_number )
+void yyset_lineno (int  _line_number )
 {
     
-    yylineno = line_number;
+    yylineno = _line_number;
 }
 
 /** Set the input stream. This does not discard the current
  * input buffer.
- * @param in_str A readable stream.
+ * @param _in_str A readable stream.
  * 
  * @see yy_switch_to_buffer
  */
-void yyset_in (FILE *  in_str )
+void yyset_in (FILE *  _in_str )
 {
-        yyin = in_str ;
+        yyin = _in_str ;
 }
 
-void yyset_out (FILE *  out_str )
+void yyset_out (FILE *  _out_str )
 {
-        yyout = out_str ;
+        yyout = _out_str ;
 }
 
 int yyget_debug  (void)
@@ -3382,9 +3249,9 @@ int yyget_debug  (void)
         return yy_flex_debug;
 }
 
-void yyset_debug (int  bdebug )
+void yyset_debug (int  _bdebug )
 {
-        yy_flex_debug = bdebug ;
+        yy_flex_debug = _bdebug ;
 }
 
 static int yy_init_globals (void)
@@ -3393,10 +3260,13 @@ static int yy_init_globals (void)
      * This function is called from yylex_destroy(), so don't allocate here.
      */
 
-    (yy_buffer_stack) = 0;
+    /* We do not touch yylineno unless the option is enabled. */
+    yylineno =  1;
+
+    (yy_buffer_stack) = NULL;
     (yy_buffer_stack_top) = 0;
     (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
+    (yy_c_buf_p) = NULL;
     (yy_init) = 0;
     (yy_start) = 0;
 
@@ -3405,8 +3275,8 @@ static int yy_init_globals (void)
     yyin = stdin;
     yyout = stdout;
 #else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
+    yyin = NULL;
+    yyout = NULL;
 #endif
 
     /* For future reference: Set errno on error, since we are called by
@@ -3421,7 +3291,7 @@ int yylex_destroy  (void)
     
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
 		YY_CURRENT_BUFFER_LVALUE = NULL;
 		yypop_buffer_state();
 	}
@@ -3442,18 +3312,19 @@ int yylex_destroy  (void)
  */
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
 {
-	register int i;
+
+	int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
+static int yy_flex_strlen (const char * s )
 {
-	register int n;
+	int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -3463,11 +3334,12 @@ static int yy_flex_strlen (yyconst char * s )
 
 void *yyalloc (yy_size_t  size )
 {
-	return (void *) malloc( size );
+			return malloc(size);
 }
 
 void *yyrealloc  (void * ptr, yy_size_t  size )
 {
+
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -3475,14 +3347,13 @@ void *yyrealloc  (void * ptr, yy_size_t  size )
 	 * any pointer type to void*, and deal with argument conversions
 	 * as though doing an assignment.
 	 */
-	return (void *) realloc( (char *) ptr, size );
+	return realloc(ptr, size);
 }
 
 void yyfree (void * ptr )
 {
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
 }
 
 #define YYTABLES_NAME "yytables"
 
-#line 676 "slghscan.l"
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
index fc4d1bf61..3a019d6bc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
@@ -1,23 +1,9 @@
-/* ###
- * IP: GHIDRA
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,7 +16,7 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -48,6 +34,10 @@
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
@@ -55,11 +45,11 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Identify Bison output.  */
-#define YYBISON 1
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30802
 
-/* Bison version.  */
-#define YYBISON_VERSION "3.0.4"
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -74,19 +64,19 @@
 #define YYPULL 1
 
 
+
+
+/* First part of user prologue.  */
+
 /* Substitute the variable and function names.  */
 #define yyparse         xmlparse
 #define yylex           xmllex
 #define yyerror         xmlerror
 #define yydebug         xmldebug
 #define yynerrs         xmlnerrs
-
 #define yylval          xmllval
 #define yychar          xmlchar
 
-/* Copy the first part of user declarations.  */
-#line 16 "src/decompile/cpp/xml.y" /* yacc.c:339  */
-
 #include "xml.hh"
 // CharData mode   look for '<' '&' or "]]>"
 // Name mode       look for non-name char
@@ -188,107 +178,280 @@ static XmlScan *global_scan;					///< Global reference to the scanner
 static ContentHandler *handler;					///< Global reference to the content handler
 extern int yydebug;								///< Debug mode
 
-#line 177 "src/decompile/cpp/xml.cc" /* yacc.c:339  */
 
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
 # ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
 #  else
-#   define YY_NULLPTR 0
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
 
 /* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
 #endif
 #if YYDEBUG
-extern int xmldebug;
+extern int yydebug;
 #endif
 
-/* Token type.  */
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
   enum yytokentype
   {
-    CHARDATA = 258,
-    CDATA = 259,
-    ATTVALUE = 260,
-    COMMENT = 261,
-    CHARREF = 262,
-    NAME = 263,
-    SNAME = 264,
-    ELEMBRACE = 265,
-    COMMBRACE = 266
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    CHARDATA = 258,                /* CHARDATA  */
+    CDATA = 259,                   /* CDATA  */
+    ATTVALUE = 260,                /* ATTVALUE  */
+    COMMENT = 261,                 /* COMMENT  */
+    CHARREF = 262,                 /* CHARREF  */
+    NAME = 263,                    /* NAME  */
+    SNAME = 264,                   /* SNAME  */
+    ELEMBRACE = 265,               /* ELEMBRACE  */
+    COMMBRACE = 266                /* COMMBRACE  */
   };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define CHARDATA 258
+#define CDATA 259
+#define ATTVALUE 260
+#define COMMENT 261
+#define CHARREF 262
+#define NAME 263
+#define SNAME 264
+#define ELEMBRACE 265
+#define COMMBRACE 266
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 119 "src/decompile/cpp/xml.y" /* yacc.c:355  */
 
   int4 i;
   string *str;
   Attributes *attr;
   NameValue *pair;
 
-#line 233 "src/decompile/cpp/xml.cc" /* yacc.c:355  */
-};
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
 #endif
 
 
-extern YYSTYPE xmllval;
+extern YYSTYPE yylval;
 
-int xmlparse (void);
 
+int yyparse (void);
+
+
+
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_CHARDATA = 3,                   /* CHARDATA  */
+  YYSYMBOL_CDATA = 4,                      /* CDATA  */
+  YYSYMBOL_ATTVALUE = 5,                   /* ATTVALUE  */
+  YYSYMBOL_COMMENT = 6,                    /* COMMENT  */
+  YYSYMBOL_CHARREF = 7,                    /* CHARREF  */
+  YYSYMBOL_NAME = 8,                       /* NAME  */
+  YYSYMBOL_SNAME = 9,                      /* SNAME  */
+  YYSYMBOL_ELEMBRACE = 10,                 /* ELEMBRACE  */
+  YYSYMBOL_COMMBRACE = 11,                 /* COMMBRACE  */
+  YYSYMBOL_12_ = 12,                       /* ' '  */
+  YYSYMBOL_13_n_ = 13,                     /* '\n'  */
+  YYSYMBOL_14_r_ = 14,                     /* '\r'  */
+  YYSYMBOL_15_t_ = 15,                     /* '\t'  */
+  YYSYMBOL_16_ = 16,                       /* '\''  */
+  YYSYMBOL_17_ = 17,                       /* '"'  */
+  YYSYMBOL_18_ = 18,                       /* '!'  */
+  YYSYMBOL_19_ = 19,                       /* '-'  */
+  YYSYMBOL_20_ = 20,                       /* '>'  */
+  YYSYMBOL_21_ = 21,                       /* '?'  */
+  YYSYMBOL_22_ = 22,                       /* '['  */
+  YYSYMBOL_23_C_ = 23,                     /* 'C'  */
+  YYSYMBOL_24_D_ = 24,                     /* 'D'  */
+  YYSYMBOL_25_A_ = 25,                     /* 'A'  */
+  YYSYMBOL_26_T_ = 26,                     /* 'T'  */
+  YYSYMBOL_27_ = 27,                       /* ']'  */
+  YYSYMBOL_28_O_ = 28,                     /* 'O'  */
+  YYSYMBOL_29_Y_ = 29,                     /* 'Y'  */
+  YYSYMBOL_30_P_ = 30,                     /* 'P'  */
+  YYSYMBOL_31_E_ = 31,                     /* 'E'  */
+  YYSYMBOL_32_ = 32,                       /* '='  */
+  YYSYMBOL_33_v_ = 33,                     /* 'v'  */
+  YYSYMBOL_34_e_ = 34,                     /* 'e'  */
+  YYSYMBOL_35_r_ = 35,                     /* 'r'  */
+  YYSYMBOL_36_s_ = 36,                     /* 's'  */
+  YYSYMBOL_37_i_ = 37,                     /* 'i'  */
+  YYSYMBOL_38_o_ = 38,                     /* 'o'  */
+  YYSYMBOL_39_n_ = 39,                     /* 'n'  */
+  YYSYMBOL_40_c_ = 40,                     /* 'c'  */
+  YYSYMBOL_41_d_ = 41,                     /* 'd'  */
+  YYSYMBOL_42_g_ = 42,                     /* 'g'  */
+  YYSYMBOL_43_x_ = 43,                     /* 'x'  */
+  YYSYMBOL_44_m_ = 44,                     /* 'm'  */
+  YYSYMBOL_45_l_ = 45,                     /* 'l'  */
+  YYSYMBOL_46_ = 46,                       /* '/'  */
+  YYSYMBOL_47_ = 47,                       /* '&'  */
+  YYSYMBOL_48_ = 48,                       /* '#'  */
+  YYSYMBOL_49_ = 49,                       /* ';'  */
+  YYSYMBOL_YYACCEPT = 50,                  /* $accept  */
+  YYSYMBOL_document = 51,                  /* document  */
+  YYSYMBOL_whitespace = 52,                /* whitespace  */
+  YYSYMBOL_S = 53,                         /* S  */
+  YYSYMBOL_attsinglemid = 54,              /* attsinglemid  */
+  YYSYMBOL_attdoublemid = 55,              /* attdoublemid  */
+  YYSYMBOL_AttValue = 56,                  /* AttValue  */
+  YYSYMBOL_elemstart = 57,                 /* elemstart  */
+  YYSYMBOL_commentstart = 58,              /* commentstart  */
+  YYSYMBOL_Comment = 59,                   /* Comment  */
+  YYSYMBOL_PI = 60,                        /* PI  */
+  YYSYMBOL_CDSect = 61,                    /* CDSect  */
+  YYSYMBOL_CDStart = 62,                   /* CDStart  */
+  YYSYMBOL_CDEnd = 63,                     /* CDEnd  */
+  YYSYMBOL_doctypepro = 64,                /* doctypepro  */
+  YYSYMBOL_prologpre = 65,                 /* prologpre  */
+  YYSYMBOL_prolog = 66,                    /* prolog  */
+  YYSYMBOL_doctypedecl = 67,               /* doctypedecl  */
+  YYSYMBOL_Eq = 68,                        /* Eq  */
+  YYSYMBOL_Misc = 69,                      /* Misc  */
+  YYSYMBOL_VersionInfo = 70,               /* VersionInfo  */
+  YYSYMBOL_EncodingDecl = 71,              /* EncodingDecl  */
+  YYSYMBOL_xmldeclstart = 72,              /* xmldeclstart  */
+  YYSYMBOL_XMLDecl = 73,                   /* XMLDecl  */
+  YYSYMBOL_element = 74,                   /* element  */
+  YYSYMBOL_STag = 75,                      /* STag  */
+  YYSYMBOL_EmptyElemTag = 76,              /* EmptyElemTag  */
+  YYSYMBOL_stagstart = 77,                 /* stagstart  */
+  YYSYMBOL_SAttribute = 78,                /* SAttribute  */
+  YYSYMBOL_etagbrace = 79,                 /* etagbrace  */
+  YYSYMBOL_ETag = 80,                      /* ETag  */
+  YYSYMBOL_content = 81,                   /* content  */
+  YYSYMBOL_Reference = 82,                 /* Reference  */
+  YYSYMBOL_refstart = 83,                  /* refstart  */
+  YYSYMBOL_charrefstart = 84,              /* charrefstart  */
+  YYSYMBOL_CharRef = 85,                   /* CharRef  */
+  YYSYMBOL_EntityRef = 86                  /* EntityRef  */
+};
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
 
-/* Copy the second part of user declarations.  */
 
-#line 250 "src/decompile/cpp/xml.cc" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
 #endif
 
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
 #else
 typedef signed char yytype_int8;
 #endif
 
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
+#else
+typedef short yytype_int16;
+#endif
+
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
+#endif
+
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
 #else
-typedef unsigned short int yytype_uint16;
+typedef short yytype_uint8;
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
 #else
-typedef short int yytype_int16;
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
 #endif
 
 #ifndef YYSIZE_T
@@ -296,15 +459,28 @@ typedef short int yytype_int16;
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
-#  define YYSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_uint8 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
 #ifndef YY_
 # if defined YYENABLE_NLS && YYENABLE_NLS
@@ -318,47 +494,43 @@ typedef short int yytype_int16;
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
 
 #ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
 #endif
 
 #ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
+# define YY_USE(E) ((void) (E))
 #else
-# define YYUSE(E) /* empty */
+# define YY_USE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
 /* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
 # define YY_INITIAL_VALUE(Value) Value
@@ -371,8 +543,22 @@ typedef short int yytype_int16;
 # define YY_INITIAL_VALUE(Value) /* Nothing. */
 #endif
 
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
 
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -437,8 +623,7 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
@@ -447,17 +632,17 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
+  yy_state_t yyss_alloc;
   YYSTYPE yyvs_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 # define YYCOPY_NEEDED 1
@@ -470,11 +655,11 @@ union yyalloc
 # define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
+        YYPTRDIFF_T yynewbytes;                                         \
         YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
         Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
@@ -486,12 +671,12 @@ union yyalloc
 # ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
 #   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          YYSIZE_T yyi;                         \
+          YYPTRDIFF_T yyi;                      \
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
@@ -514,17 +699,20 @@ union yyalloc
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  151
 
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
-#define YYUNDEFTOK  2
+/* YYMAXUTOK -- Last valid token kind.  */
 #define YYMAXUTOK   266
 
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
-static const yytype_uint8 yytranslate[] =
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,    15,
       13,     2,     2,    14,     2,     2,     2,     2,     2,     2,
@@ -556,66 +744,66 @@ static const yytype_uint8 yytranslate[] =
 };
 
 #if YYDEBUG
-  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint8 yyrline[] =
 {
-       0,   135,   135,   136,   137,   138,   139,   140,   141,   142,
-     144,   145,   146,   147,   148,   149,   150,   151,   152,   153,
-     154,   155,   156,   157,   158,   160,   161,   162,   163,   164,
-     165,   166,   168,   169,   170,   171,   172,   173,   174,   176,
-     177,   178,   179,   180,   181,   182,   184,   185,   187,   188,
-     189,   190,   192,   193,   194,   195,   196,   197,   199,   200,
-     201,   202,   203,   204,   205,   207,   208,   210,   211,   212,
-     213
+       0,   144,   144,   145,   146,   147,   148,   149,   150,   151,
+     153,   154,   155,   156,   157,   158,   159,   160,   161,   162,
+     163,   164,   165,   166,   167,   169,   170,   171,   172,   173,
+     174,   175,   177,   178,   179,   180,   181,   182,   183,   185,
+     186,   187,   188,   189,   190,   191,   193,   194,   196,   197,
+     198,   199,   201,   202,   203,   204,   205,   206,   208,   209,
+     210,   211,   212,   213,   214,   216,   217,   219,   220,   221,
+     222
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 0
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "CHARDATA", "CDATA", "ATTVALUE",
-  "COMMENT", "CHARREF", "NAME", "SNAME", "ELEMBRACE", "COMMBRACE", "' '",
-  "'\\n'", "'\\r'", "'\\t'", "'\\''", "'\"'", "'!'", "'-'", "'>'", "'?'",
-  "'['", "'C'", "'D'", "'A'", "'T'", "']'", "'O'", "'Y'", "'P'", "'E'",
-  "'='", "'v'", "'e'", "'r'", "'s'", "'i'", "'o'", "'n'", "'c'", "'d'",
-  "'g'", "'x'", "'m'", "'l'", "'/'", "'&'", "'#'", "';'", "$accept",
-  "document", "whitespace", "S", "attsinglemid", "attdoublemid",
-  "AttValue", "elemstart", "commentstart", "Comment", "PI", "CDSect",
-  "CDStart", "CDEnd", "doctypepro", "prologpre", "prolog", "doctypedecl",
-  "Eq", "Misc", "VersionInfo", "EncodingDecl", "xmldeclstart", "XMLDecl",
-  "element", "STag", "EmptyElemTag", "stagstart", "SAttribute",
-  "etagbrace", "ETag", "content", "Reference", "refstart", "charrefstart",
-  "CharRef", "EntityRef", YY_NULLPTR
+  "\"end of file\"", "error", "\"invalid token\"", "CHARDATA", "CDATA",
+  "ATTVALUE", "COMMENT", "CHARREF", "NAME", "SNAME", "ELEMBRACE",
+  "COMMBRACE", "' '", "'\\n'", "'\\r'", "'\\t'", "'\\''", "'\"'", "'!'",
+  "'-'", "'>'", "'?'", "'['", "'C'", "'D'", "'A'", "'T'", "']'", "'O'",
+  "'Y'", "'P'", "'E'", "'='", "'v'", "'e'", "'r'", "'s'", "'i'", "'o'",
+  "'n'", "'c'", "'d'", "'g'", "'x'", "'m'", "'l'", "'/'", "'&'", "'#'",
+  "';'", "$accept", "document", "whitespace", "S", "attsinglemid",
+  "attdoublemid", "AttValue", "elemstart", "commentstart", "Comment", "PI",
+  "CDSect", "CDStart", "CDEnd", "doctypepro", "prologpre", "prolog",
+  "doctypedecl", "Eq", "Misc", "VersionInfo", "EncodingDecl",
+  "xmldeclstart", "XMLDecl", "element", "STag", "EmptyElemTag",
+  "stagstart", "SAttribute", "etagbrace", "ETag", "content", "Reference",
+  "refstart", "charrefstart", "CharRef", "EntityRef", YY_NULLPTR
 };
-#endif
 
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
 {
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,    32,    10,    13,     9,    39,    34,    33,    45,
-      62,    63,    91,    67,    68,    65,    84,    93,    79,    89,
-      80,    69,    61,   118,   101,   114,   115,   105,   111,   110,
-      99,   100,   103,   120,   109,   108,    47,    38,    35,    59
-};
-# endif
+  return yytname[yysymbol];
+}
+#endif
 
-#define YYPACT_NINF -136
+#define YYPACT_NINF (-136)
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-136)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define YYTABLE_NINF -1
+#define YYTABLE_NINF (-1)
 
-#define yytable_value_is_error(Yytable_value) \
+#define yytable_value_is_error(Yyn) \
   0
 
-  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-     STATE-NUM.  */
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
      132,  -136,    42,  -136,  -136,  -136,  -136,    22,  -136,   125,
@@ -636,10 +824,10 @@ static const yytype_int16 yypact[] =
     -136
 };
 
-  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when YYTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const yytype_uint8 yydefact[] =
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_int8 yydefact[] =
 {
        0,    18,     0,     4,     5,     6,     7,     0,     8,    38,
        0,     0,    36,    37,    31,     0,    28,     0,    27,     0,
@@ -659,7 +847,7 @@ static const yytype_uint8 yydefact[] =
       39
 };
 
-  /* YYPGOTO[NTERM-NUM].  */
+/* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
     -136,  -136,    -8,   -17,  -136,  -136,  -133,  -136,  -136,   165,
@@ -668,18 +856,18 @@ static const yytype_int16 yypgoto[] =
     -136,  -136,   -64,  -136,  -136,  -136,  -136
 };
 
-  /* YYDEFGOTO[NTERM-NUM].  */
+/* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int8 yydefgoto[] =
 {
-      -1,     7,     8,     9,    97,    98,    99,    10,    11,    12,
+       0,     7,     8,     9,    97,    98,    99,    10,    11,    12,
       13,    62,    63,   108,    30,    14,    15,    31,    74,    16,
      120,    36,    17,    18,    19,    20,    21,    22,    44,    65,
       66,    39,    67,    68,    69,    70,    71
 };
 
-  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_uint8 yytable[] =
 {
       35,    26,    57,   113,    90,    43,   144,    45,   116,     1,
@@ -730,9 +918,9 @@ static const yytype_int16 yycheck[] =
       -1,    38,    -1,    39,    39,    39
 };
 
-  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
+static const yytype_int8 yystos[] =
 {
        0,    10,    11,    12,    13,    14,    15,    51,    52,    53,
       57,    58,    59,    60,    65,    66,    69,    72,    73,    74,
@@ -752,8 +940,8 @@ static const yytype_uint8 yystos[] =
       56
 };
 
-  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr1[] =
 {
        0,    50,    51,    51,    52,    52,    52,    52,    53,    53,
       54,    54,    54,    55,    55,    55,    56,    56,    57,    58,
@@ -765,8 +953,8 @@ static const yytype_uint8 yyr1[] =
       86
 };
 
-  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
 {
        0,     2,     2,     3,     1,     1,     1,     1,     1,     2,
        1,     2,     2,     1,     2,     2,     2,     2,     1,     4,
@@ -779,39 +967,39 @@ static const yytype_uint8 yyr2[] =
 };
 
 
+enum { YYENOMEM = -2 };
+
 #define yyerrok         (yyerrstatus = 0)
 #define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
 
 #define YYACCEPT        goto yyacceptlab
 #define YYABORT         goto yyabortlab
 #define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
 
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
 
 
 /* Enable debugging if requested.  */
@@ -828,55 +1016,52 @@ do {                                            \
     YYFPRINTF Args;                             \
 } while (0)
 
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
 
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
   if (yydebug)                                                            \
     {                                                                     \
       YYFPRINTF (stderr, "%s ", Title);                                   \
       yy_symbol_print (stderr,                                            \
-                  Type, Value); \
+                  Kind, Value); \
       YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
   if (!yyvaluep)
     return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  YYFPRINTF (yyoutput, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
+  yy_symbol_value_print (yyo, yykind, yyvaluep);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
@@ -885,7 +1070,7 @@ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
 `------------------------------------------------------------------*/
 
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -908,21 +1093,21 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule)
 {
-  unsigned long int yylno = yyrline[yyrule];
+  int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
              yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
-                                              );
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)]);
       YYFPRINTF (stderr, "\n");
     }
 }
@@ -937,8 +1122,8 @@ do {                                    \
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -961,249 +1146,30 @@ int yydebug;
 #endif
 
 
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-yystrlen (const char *yystr)
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
 
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
 
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
 
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
 {
-  YYUSE (yyvaluep);
+  YY_USE (yyvaluep);
   if (!yymsg)
     yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
+  YY_USE (yykind);
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-
-
-/* The lookahead symbol.  */
+/* Lookahead token kind.  */
 int yychar;
 
 /* The semantic value of the lookahead symbol.  */
@@ -1212,6 +1178,8 @@ YYSTYPE yylval;
 int yynerrs;
 
 
+
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1219,43 +1187,36 @@ int yynerrs;
 int
 yyparse (void)
 {
-    int yystate;
+    yy_state_fast_t yystate = 0;
     /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
+    int yyerrstatus = 0;
 
-       Refer to the stacks through separate pointers, to allow yyoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-    YYSIZE_T yystacksize;
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
   int yyn;
+  /* The return value of yyparse.  */
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
@@ -1263,71 +1224,75 @@ yyparse (void)
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
+
   goto yysetstate;
 
+
 /*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- yynewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
- yysetstate:
-  *yyssp = yystate;
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
 
   if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef yyoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
+        yy_state_t *yyss1 = yyss;
         YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
 
         /* Each stack pointer address is followed by the size of the
            data in use in that stack, in bytes.  This used to be a
            conditional around just the two extra args, but that might
            be undefined if yyoverflow is a macro.  */
         yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                     &yystacksize);
-
         yyss = yyss1;
         yyvs = yyvs1;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
+        YYNOMEM;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
 
       {
-        yytype_int16 *yyss1 = yyss;
+        yy_state_t *yyss1 = yyss;
         union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
         if (! yyptr)
-          goto yyexhaustedlab;
+          YYNOMEM;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
@@ -1335,30 +1300,31 @@ yyparse (void)
           YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no yyoverflow */
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
+
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
-
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
@@ -1369,18 +1335,29 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF ((stderr, "Reading a token\n"));
       yychar = yylex ();
     }
 
   if (yychar <= YYEOF)
     {
-      yychar = yytoken = YYEOF;
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
+    }
   else
     {
       yytoken = YYTRANSLATE (yychar);
@@ -1408,15 +1385,13 @@ yybackup:
 
   /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
 
@@ -1431,7 +1406,7 @@ yydefault:
 
 
 /*-----------------------------.
-| yyreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
@@ -1451,260 +1426,176 @@ yyreduce:
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-        case 10:
-#line 144 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = new string; global_scan->setmode(XmlScan::AttValueSingleMode); }
-#line 1443 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 10: /* attsinglemid: '\''  */
+                   { (yyval.str) = new string; global_scan->setmode(XmlScan::AttValueSingleMode); }
     break;
 
-  case 11:
-#line 145 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += *(yyvsp[0].str); delete (yyvsp[0].str); global_scan->setmode(XmlScan::AttValueSingleMode); }
-#line 1449 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 11: /* attsinglemid: attsinglemid ATTVALUE  */
+                                      { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += *(yyvsp[0].str); delete (yyvsp[0].str); global_scan->setmode(XmlScan::AttValueSingleMode); }
     break;
 
-  case 12:
-#line 146 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += (yyvsp[0].i); global_scan->setmode(XmlScan::AttValueSingleMode); }
-#line 1455 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 12: /* attsinglemid: attsinglemid Reference  */
+                                       { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += (yyvsp[0].i); global_scan->setmode(XmlScan::AttValueSingleMode); }
     break;
 
-  case 13:
-#line 147 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = new string; global_scan->setmode(XmlScan::AttValueDoubleMode); }
-#line 1461 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 13: /* attdoublemid: '"'  */
+                  { (yyval.str) = new string; global_scan->setmode(XmlScan::AttValueDoubleMode); }
     break;
 
-  case 14:
-#line 148 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += *(yyvsp[0].str); delete (yyvsp[0].str); global_scan->setmode(XmlScan::AttValueDoubleMode); }
-#line 1467 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 14: /* attdoublemid: attdoublemid ATTVALUE  */
+                                      { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += *(yyvsp[0].str); delete (yyvsp[0].str); global_scan->setmode(XmlScan::AttValueDoubleMode); }
     break;
 
-  case 15:
-#line 149 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += (yyvsp[0].i); global_scan->setmode(XmlScan::AttValueDoubleMode); }
-#line 1473 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 15: /* attdoublemid: attdoublemid Reference  */
+                                       { (yyval.str) = (yyvsp[-1].str); *(yyval.str) += (yyvsp[0].i); global_scan->setmode(XmlScan::AttValueDoubleMode); }
     break;
 
-  case 16:
-#line 150 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1479 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 16: /* AttValue: attsinglemid '\''  */
+                            { (yyval.str) = (yyvsp[-1].str); }
     break;
 
-  case 17:
-#line 151 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1485 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 17: /* AttValue: attdoublemid '"'  */
+                             { (yyval.str) = (yyvsp[-1].str); }
     break;
 
-  case 18:
-#line 152 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::NameMode); delete (yyvsp[0].str); }
-#line 1491 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 18: /* elemstart: ELEMBRACE  */
+                     { global_scan->setmode(XmlScan::NameMode); delete (yyvsp[0].str); }
     break;
 
-  case 19:
-#line 153 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CommentMode); delete (yyvsp[-3].str); }
-#line 1497 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 19: /* commentstart: COMMBRACE '!' '-' '-'  */
+                                    { global_scan->setmode(XmlScan::CommentMode); delete (yyvsp[-3].str); }
     break;
 
-  case 20:
-#line 154 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { delete (yyvsp[-3].str); }
-#line 1503 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 20: /* Comment: commentstart COMMENT '-' '-' '>'  */
+                                          { delete (yyvsp[-3].str); }
     break;
 
-  case 21:
-#line 155 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { delete (yyvsp[-1].str); yyerror("Processing instructions are not supported"); YYERROR; }
-#line 1509 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 21: /* PI: COMMBRACE '?'  */
+                  { delete (yyvsp[-1].str); yyerror("Processing instructions are not supported"); YYERROR; }
     break;
 
-  case 22:
-#line 156 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1515 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 22: /* CDSect: CDStart CDATA CDEnd  */
+                            { (yyval.str) = (yyvsp[-1].str); }
     break;
 
-  case 23:
-#line 157 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CDataMode); delete (yyvsp[-8].str); }
-#line 1521 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 23: /* CDStart: COMMBRACE '!' '[' 'C' 'D' 'A' 'T' 'A' '['  */
+                                                   { global_scan->setmode(XmlScan::CDataMode); delete (yyvsp[-8].str); }
     break;
 
-  case 32:
-#line 168 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { delete (yyvsp[-8].str); yyerror("DTD's not supported"); YYERROR; }
-#line 1527 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 32: /* doctypedecl: COMMBRACE '!' 'D' 'O' 'C' 'T' 'Y' 'P' 'E'  */
+                                                       { delete (yyvsp[-8].str); yyerror("DTD's not supported"); YYERROR; }
     break;
 
-  case 39:
-#line 176 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->setVersion(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 1533 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 39: /* VersionInfo: S 'v' 'e' 'r' 's' 'i' 'o' 'n' Eq AttValue  */
+                                                       { handler->setVersion(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 40:
-#line 177 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->setEncoding(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 1539 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 40: /* EncodingDecl: S 'e' 'n' 'c' 'o' 'd' 'i' 'n' 'g' Eq AttValue  */
+                                                            { handler->setEncoding(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 46:
-#line 184 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->endElement((yyvsp[0].attr)->getelemURI(),(yyvsp[0].attr)->getelemName(),(yyvsp[0].attr)->getelemName()); delete (yyvsp[0].attr); }
-#line 1545 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 46: /* element: EmptyElemTag  */
+                      { handler->endElement((yyvsp[0].attr)->getelemURI(),(yyvsp[0].attr)->getelemName(),(yyvsp[0].attr)->getelemName()); delete (yyvsp[0].attr); }
     break;
 
-  case 47:
-#line 185 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->endElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName()); delete (yyvsp[-2].attr); delete (yyvsp[0].str); }
-#line 1551 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 47: /* element: STag content ETag  */
+                             { handler->endElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName()); delete (yyvsp[-2].attr); delete (yyvsp[0].str); }
     break;
 
-  case 48:
-#line 187 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->startElement((yyvsp[-1].attr)->getelemURI(),(yyvsp[-1].attr)->getelemName(),(yyvsp[-1].attr)->getelemName(),*(yyvsp[-1].attr)); (yyval.attr) = (yyvsp[-1].attr); }
-#line 1557 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 48: /* STag: stagstart '>'  */
+                    { handler->startElement((yyvsp[-1].attr)->getelemURI(),(yyvsp[-1].attr)->getelemName(),(yyvsp[-1].attr)->getelemName(),*(yyvsp[-1].attr)); (yyval.attr) = (yyvsp[-1].attr); }
     break;
 
-  case 49:
-#line 188 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->startElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName(),*(yyvsp[-2].attr)); (yyval.attr) = (yyvsp[-2].attr); }
-#line 1563 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 49: /* STag: stagstart S '>'  */
+                        { handler->startElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName(),*(yyvsp[-2].attr)); (yyval.attr) = (yyvsp[-2].attr); }
     break;
 
-  case 50:
-#line 189 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->startElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName(),*(yyvsp[-2].attr)); (yyval.attr) = (yyvsp[-2].attr); }
-#line 1569 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 50: /* EmptyElemTag: stagstart '/' '>'  */
+                                { handler->startElement((yyvsp[-2].attr)->getelemURI(),(yyvsp[-2].attr)->getelemName(),(yyvsp[-2].attr)->getelemName(),*(yyvsp[-2].attr)); (yyval.attr) = (yyvsp[-2].attr); }
     break;
 
-  case 51:
-#line 190 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { handler->startElement((yyvsp[-3].attr)->getelemURI(),(yyvsp[-3].attr)->getelemName(),(yyvsp[-3].attr)->getelemName(),*(yyvsp[-3].attr)); (yyval.attr) = (yyvsp[-3].attr); }
-#line 1575 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 51: /* EmptyElemTag: stagstart S '/' '>'  */
+                                    { handler->startElement((yyvsp[-3].attr)->getelemURI(),(yyvsp[-3].attr)->getelemName(),(yyvsp[-3].attr)->getelemName(),*(yyvsp[-3].attr)); (yyval.attr) = (yyvsp[-3].attr); }
     break;
 
-  case 52:
-#line 192 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.attr) = new Attributes((yyvsp[0].str)); global_scan->setmode(XmlScan::SNameMode); }
-#line 1581 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 52: /* stagstart: elemstart NAME  */
+                          { (yyval.attr) = new Attributes((yyvsp[0].str)); global_scan->setmode(XmlScan::SNameMode); }
     break;
 
-  case 53:
-#line 193 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.attr) = (yyvsp[-1].attr); (yyval.attr)->add_attribute( (yyvsp[0].pair)->name, (yyvsp[0].pair)->value); delete (yyvsp[0].pair); global_scan->setmode(XmlScan::SNameMode); }
-#line 1587 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 53: /* stagstart: stagstart SAttribute  */
+                                  { (yyval.attr) = (yyvsp[-1].attr); (yyval.attr)->add_attribute( (yyvsp[0].pair)->name, (yyvsp[0].pair)->value); delete (yyvsp[0].pair); global_scan->setmode(XmlScan::SNameMode); }
     break;
 
-  case 54:
-#line 194 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.pair) = new NameValue; (yyval.pair)->name = (yyvsp[-2].str); (yyval.pair)->value = (yyvsp[0].str); }
-#line 1593 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 54: /* SAttribute: SNAME Eq AttValue  */
+                              { (yyval.pair) = new NameValue; (yyval.pair)->name = (yyvsp[-2].str); (yyval.pair)->value = (yyvsp[0].str); }
     break;
 
-  case 55:
-#line 195 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::NameMode); delete (yyvsp[-1].str); }
-#line 1599 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 55: /* etagbrace: COMMBRACE '/'  */
+                         { global_scan->setmode(XmlScan::NameMode); delete (yyvsp[-1].str); }
     break;
 
-  case 56:
-#line 196 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1605 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 56: /* ETag: etagbrace NAME '>'  */
+                         { (yyval.str) = (yyvsp[-1].str); }
     break;
 
-  case 57:
-#line 197 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-2].str); }
-#line 1611 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 57: /* ETag: etagbrace NAME S '>'  */
+                             { (yyval.str) = (yyvsp[-2].str); }
     break;
 
-  case 58:
-#line 199 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CharDataMode); }
-#line 1617 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 58: /* content: %empty  */
+         { global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 59:
-#line 200 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { print_content( *(yyvsp[0].str) ); delete (yyvsp[0].str); global_scan->setmode(XmlScan::CharDataMode); }
-#line 1623 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 59: /* content: content CHARDATA  */
+                            { print_content( *(yyvsp[0].str) ); delete (yyvsp[0].str); global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 60:
-#line 201 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CharDataMode); }
-#line 1629 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 60: /* content: content element  */
+                           { global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 61:
-#line 202 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { string *tmp=new string(); *tmp += (yyvsp[0].i); print_content(*tmp); delete tmp; global_scan->setmode(XmlScan::CharDataMode); }
-#line 1635 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 61: /* content: content Reference  */
+                             { string *tmp=new string(); *tmp += (yyvsp[0].i); print_content(*tmp); delete tmp; global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 62:
-#line 203 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { print_content( *(yyvsp[0].str) ); delete (yyvsp[0].str); global_scan->setmode(XmlScan::CharDataMode); }
-#line 1641 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 62: /* content: content CDSect  */
+                          { print_content( *(yyvsp[0].str) ); delete (yyvsp[0].str); global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 63:
-#line 204 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CharDataMode); }
-#line 1647 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 63: /* content: content PI  */
+                      { global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 64:
-#line 205 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CharDataMode); }
-#line 1653 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 64: /* content: content Comment  */
+                           { global_scan->setmode(XmlScan::CharDataMode); }
     break;
 
-  case 65:
-#line 207 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.i) = convertEntityRef(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 1659 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 65: /* Reference: EntityRef  */
+                     { (yyval.i) = convertEntityRef(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 66:
-#line 208 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.i) = convertCharRef(*(yyvsp[0].str)); delete (yyvsp[0].str); }
-#line 1665 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 66: /* Reference: CharRef  */
+                     { (yyval.i) = convertCharRef(*(yyvsp[0].str)); delete (yyvsp[0].str); }
     break;
 
-  case 67:
-#line 210 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::NameMode); }
-#line 1671 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 67: /* refstart: '&'  */
+              { global_scan->setmode(XmlScan::NameMode); }
     break;
 
-  case 68:
-#line 211 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { global_scan->setmode(XmlScan::CharRefMode); }
-#line 1677 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 68: /* charrefstart: refstart '#'  */
+                           { global_scan->setmode(XmlScan::CharRefMode); }
     break;
 
-  case 69:
-#line 212 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1683 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 69: /* CharRef: charrefstart CHARREF ';'  */
+                                  { (yyval.str) = (yyvsp[-1].str); }
     break;
 
-  case 70:
-#line 213 "src/decompile/cpp/xml.y" /* yacc.c:1646  */
-    { (yyval.str) = (yyvsp[-1].str); }
-#line 1689 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+  case 70: /* EntityRef: refstart NAME ';'  */
+                             { (yyval.str) = (yyvsp[-1].str); }
     break;
 
 
-#line 1693 "src/decompile/cpp/xml.cc" /* yacc.c:1646  */
+
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -1718,25 +1609,23 @@ yyreduce:
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
@@ -1747,50 +1636,14 @@ yyreduce:
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
     }
 
-
-
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -1819,12 +1672,11 @@ yyerrlab:
 | yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
 yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
 
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
@@ -1841,13 +1693,14 @@ yyerrorlab:
 yyerrlab1:
   yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
@@ -1861,7 +1714,7 @@ yyerrlab1:
 
 
       yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp);
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -1873,7 +1726,7 @@ yyerrlab1:
 
 
   /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -1884,26 +1737,30 @@ yyerrlab1:
 `-------------------------------------*/
 yyacceptlab:
   yyresult = 0;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
 /*-----------------------------------.
 | yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
 yyabortlab:
   yyresult = 1;
-  goto yyreturn;
+  goto yyreturnlab;
+
 
-#if !defined yyoverflow || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
 yyexhaustedlab:
   yyerror (YY_("memory exhausted"));
   yyresult = 2;
-  /* Fall through.  */
-#endif
+  goto yyreturnlab;
+
 
-yyreturn:
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
   if (yychar != YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
@@ -1919,20 +1776,17 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp);
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
+
   return yyresult;
 }
-#line 214 "src/decompile/cpp/xml.y" /* yacc.c:1906  */
+
 
 
 XmlScan::XmlScan(istream &t) : s(t)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
index 8f5386237..5722caf2e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
@@ -14,6 +14,15 @@
  * limitations under the License.
  */
 %{
+/* Substitute the variable and function names.  */
+#define yyparse         xmlparse
+#define yylex           xmllex
+#define yyerror         xmlerror
+#define yydebug         xmldebug
+#define yynerrs         xmlnerrs
+#define yylval          xmllval
+#define yychar          xmlchar
+
 #include "xml.hh"
 // CharData mode   look for '<' '&' or "]]>"
 // Name mode       look for non-name char
-- 
2.39.0

