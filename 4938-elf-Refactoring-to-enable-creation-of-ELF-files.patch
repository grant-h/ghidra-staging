From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jean-Baptiste Boric <jblbeurope@gmail.com>
Date: Fri, 16 Dec 2022 18:22:29 +0100
Subject: [PATCH] 4938: elf: Refactoring to enable creation of ELF files from
 scratch

clean up endianess detection inside ElfHeader
read prelink address when parsing ElfHeader
refactor ElfFileSection interface
decouple ELF table classes from ElfFileSection
add byte reader and byte provider to ElfFileSection
make ElfFileSection::getEntrySize() return 0 by default
make ElfProgramHeader implement ElfFileSection
set ElfSectionHeader fields visibility to package
make ElfSectionHeader implement ElfFileSection
use ElfFileSection inside ElfDynamicTable
use ElfFileSection inside ElfStringTable
use ElfFileSection inside ElfSymbolTable
use ElfFileSection inside ElfRelocationTable
remove ElfHeader::parse() method
remove BinaryReader and ByteProvider from ElfHeader
implement ElfStringTable::add()
implement ElfRelocation::addRelocation()
implement additional helpers for creating ElfSymbol
implement ByteArrayMutableByteProvider
implement adding sections to ElfHeader
fix ElfHeader table getters
fix ElfHeader::write()
fix ElfSymbol::toBytes()
fix ElfRelocation::toBytes()
---
 .../cmd/formats/ElfBinaryAnalysisCommand.java |  35 +-
 .../bin/ByteArrayMutableByteProvider.java     | 111 ++++
 .../format/elf/ElfDefaultGotPltMarkup.java    |   2 +-
 .../util/bin/format/elf/ElfDynamicTable.java  |  40 +-
 .../util/bin/format/elf/ElfFileSection.java   |  64 +-
 .../bin/format/elf/ElfFileSectionWrapper.java |  74 +++
 .../app/util/bin/format/elf/ElfHeader.java    | 546 ++++++++----------
 .../util/bin/format/elf/ElfProgramHeader.java |  31 +-
 .../util/bin/format/elf/ElfRelocation.java    |  10 +-
 .../bin/format/elf/ElfRelocationTable.java    |  88 +--
 .../util/bin/format/elf/ElfSectionHeader.java |  72 ++-
 .../util/bin/format/elf/ElfStringTable.java   |  77 ++-
 .../app/util/bin/format/elf/ElfSymbol.java    |  78 ++-
 .../util/bin/format/elf/ElfSymbolTable.java   |  70 +--
 .../bin/format/elf/extend/ElfLoadAdapter.java |   4 +-
 .../ghidra/app/util/opinion/ElfDataType.java  |   1 -
 .../ghidra/app/util/opinion/ElfLoader.java    |   3 +-
 .../util/opinion/ElfLoaderOptionsFactory.java |   5 +-
 .../app/util/opinion/ElfProgramBuilder.java   | 113 ++--
 .../formats/android/oat/OatFileSystem.java    |   6 +-
 .../format/elf/extend/ARM_ElfExtension.java   |  15 +-
 .../elf/extend/HCS12X_ElfExtension.java       |   2 +-
 .../format/elf/extend/PIC30_ElfExtension.java |   2 +-
 .../relocation/eBPF_ElfRelocationHandler.java |   2 +-
 24 files changed, 818 insertions(+), 633 deletions(-)
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/ByteArrayMutableByteProvider.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSectionWrapper.java

diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/formats/ElfBinaryAnalysisCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/formats/ElfBinaryAnalysisCommand.java
index e6fe53afc..a112dc75d 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/formats/ElfBinaryAnalysisCommand.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/formats/ElfBinaryAnalysisCommand.java
@@ -83,7 +83,6 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 			MemoryByteProvider.createDefaultAddressSpaceByteProvider(program, false);
 		try {
 			ElfHeader elf = new ElfHeader(provider, msg -> messages.appendMsg(msg));
-			elf.parse();
 
 			processElfHeader(elf, listing);
 			processProgramHeaders(elf, listing);
@@ -143,8 +142,8 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 		for (ElfSectionHeader stringSection : stringSections) {
 			monitor.checkCanceled();
 			try {
-				Address addr = addr(stringSection.getOffset());
-				Address maxAddr = addr.addNoWrap(stringSection.getSize() - 1);
+				Address addr = addr(stringSection.getFileOffset());
+				Address maxAddr = addr.addNoWrap(stringSection.getMemorySize() - 1);
 
 				MemoryBlock block = memory.getBlock(addr);
 				if (block == null) {
@@ -188,15 +187,15 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 
 			CodeUnit cu = listing.getCodeUnitAt(addr(offset));
 			cu.setComment(CodeUnit.PLATE_COMMENT,
-				"#" + i + ") " + name + " at 0x" + Long.toHexString(sections[i].getAddress()));
+				"#" + i + ") " + name + " at 0x" + Long.toHexString(sections[i].getVirtualAddress()));
 
 			if (sections[i].getType() == ElfSectionHeaderConstants.SHT_NOBITS ||
-				sections[i].getSize() == 0 || sections[i].isInvalidOffset()) {
+				sections[i].getMemorySize() == 0 || sections[i].isInvalidOffset()) {
 				continue;
 			}
 
-			Address dataStart = addr(sections[i].getOffset());
-			createFragment(name + "_DATA", dataStart, sections[i].getSize());
+			Address dataStart = addr(sections[i].getFileOffset());
+			createFragment(name + "_DATA", dataStart, sections[i].getMemorySize());
 
 			try {
 				createLabel(dataStart, name, true, SourceType.ANALYSIS);
@@ -207,7 +206,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 
 			cu = listing.getCodeUnitAt(dataStart);
 			cu.setComment(CodeUnit.PRE_COMMENT, sections[i].getNameAsString() + " Size: 0x" +
-				Long.toHexString(sections[i].getSize()));
+				Long.toHexString(sections[i].getMemorySize()));
 		}
 	}
 
@@ -233,7 +232,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 			Data d = array.getComponent(i);
 			d.setComment(CodeUnit.EOL_COMMENT, programHeaders[i].getComment());
 
-			Address addr = addr(programHeaders[i].getOffset());
+			Address addr = addr(programHeaders[i].getFileOffset());
 
 			createLabel(addr, programHeaders[i].getTypeAsString(), true, SourceType.ANALYSIS);
 		}
@@ -244,7 +243,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 		for (ElfProgramHeader programHeader : elf.getProgramHeaders(
 			ElfProgramHeaderConstants.PT_INTERP)) {
 			monitor.checkCanceled();
-			long offset = programHeader.getOffset();
+			long offset = programHeader.getFileOffset();
 			if (offset == 0) {
 				Msg.warn(this, " Dynamic table appears to have been stripped from binary");
 				return;
@@ -270,7 +269,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 		}
 
 		try {
-			Address addr = addr(dynamicTable.getFileOffset());
+			Address addr = addr(dynamicTable.getFileSection().getFileOffset());
 
 			program.getSymbolTable().createLabel(addr, "_DYNAMIC", SourceType.ANALYSIS);
 
@@ -324,7 +323,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 			BinaryReader reader, Program program) {
 		ElfStringTable dynamicStringTable = elf.getDynamicStringTable();
 		if (dynamicStringTable != null) {
-			String str = dynamicStringTable.readString(reader, dynamic.getValue());
+			String str = dynamicStringTable.readString(dynamic.getValue());
 			if (str != null && str.length() != 0) {
 				data.setComment(CodeUnit.EOL_COMMENT, str);
 			}
@@ -362,7 +361,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 		for (ElfSymbolTable symbolTable2 : symbolTables) {
 			monitor.checkCanceled();
 
-			Address symbolTableAddr = addr(symbolTable2.getFileOffset());
+			Address symbolTableAddr = addr(symbolTable2.getFileSection().getFileOffset());
 
 			try {
 				DataType symbolTableDT = symbolTable2.toDataType();
@@ -386,7 +385,7 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 				}
 
 				try {
-					Address currAddr = symbolTableAddr.add(j * symbolTable2.getEntrySize());
+					Address currAddr = symbolTableAddr.add(j * symbolTable2.getFileSection().getEntrySize());
 					listing.setComment(currAddr, CodeUnit.EOL_COMMENT,
 						name + " at 0x" + Long.toHexString(symbols[j].getValue()));
 				}
@@ -407,14 +406,14 @@ public class ElfBinaryAnalysisCommand extends FlatProgramAPI
 		ElfRelocationTable[] relocationTables = elf.getRelocationTables();
 		for (ElfRelocationTable relocationTable : relocationTables) {
 			monitor.checkCanceled();
-			ElfSectionHeader relocationSection = relocationTable.getTableSectionHeader();
+			ElfFileSection relocationSection = relocationTable.getFileSection();
 			String relocSectionName = "<section-not-found>";
-			if (relocationSection != null) {
-				relocSectionName = relocationSection.getNameAsString();
+			if (relocationSection instanceof ElfSectionHeader) {
+				relocSectionName = ((ElfSectionHeader) relocationSection).getNameAsString();
 			}
 
 			//		elf.getSection(relocationTable.getFileOffset()); // may be null
-			Address relocationTableAddress = addr(relocationTable.getFileOffset());
+			Address relocationTableAddress = addr(relocationSection.getFileOffset());
 			try {
 				DataType dataType = relocationTable.toDataType();
 				if (dataType != null) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/ByteArrayMutableByteProvider.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/ByteArrayMutableByteProvider.java
new file mode 100644
index 000000000..a9fb4cea2
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/ByteArrayMutableByteProvider.java
@@ -0,0 +1,111 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * An implementation of ByteProvider where the underlying bytes are held in-
+ * memory with a byte buffer. The buffer grows automatically as needed to fit
+ * written data.
+ */
+public class ByteArrayMutableByteProvider implements MutableByteProvider {
+    private byte[] data;
+
+    private void ensureCapacity(int newCapacity) {
+        if (data.length < newCapacity) {
+            data = Arrays.copyOf(data, newCapacity);
+        }
+    }
+
+    /**
+     * Create an empty ByteArrayMutableByteProvider.
+     */
+    public ByteArrayMutableByteProvider() {
+        data = new byte[0];
+    }
+
+    /**
+     * Create a ByteArrayMutableByteProvider initialized with the given array
+     * @param bytes Initial content of the ByteArrayMutableByteProvider.
+     */
+    public ByteArrayMutableByteProvider(byte[] bytes) {
+        data = Arrays.copyOf(bytes, bytes.length);
+    }
+
+    @Override
+    public File getFile() {
+        return null;
+    }
+
+    @Override
+    public String getName() {
+        return null;
+    }
+
+    @Override
+    public String getAbsolutePath() {
+        return null;
+    }
+
+    @Override
+    public long length() throws IOException {
+        return data.length;
+    }
+
+    @Override
+    public boolean isValidIndex(long index) {
+        return index < data.length;
+    }
+
+    @Override
+    public void close() throws IOException {
+    }
+
+    @Override
+    public byte readByte(long index) throws IOException {
+        try {
+            return data[(int) index];
+        }
+        catch (IndexOutOfBoundsException e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public byte[] readBytes(long index, long length) throws IOException {
+        try {
+            return Arrays.copyOfRange(data, (int) index, (int) (index + length));
+        }
+        catch (IndexOutOfBoundsException e) {
+            throw new IOException(e);
+        }
+    }
+
+    @Override
+    public void writeByte(long index, byte value) throws IOException {
+        ensureCapacity((int) (index + 1));
+        data[(int) index] = value;
+    }
+
+    @Override
+    public void writeBytes(long index, byte[] values) throws IOException {
+        ensureCapacity((int) (index + values.length));
+        System.arraycopy(values, 0, data, (int) index, values.length);
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDefaultGotPltMarkup.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDefaultGotPltMarkup.java
index 4c6764e39..5b938ceed 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDefaultGotPltMarkup.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDefaultGotPltMarkup.java
@@ -375,7 +375,7 @@ public class ElfDefaultGotPltMarkup {
 			long imageBaseAdj = elfLoadHelper.getImageBaseWordAdjustmentOffset();
 			if (dynamicTable != null && imageBaseAdj != 0) {
 				long entry1Value = elfLoadHelper.getOriginalValue(gotStart, false);
-				if (entry1Value == dynamicTable.getAddressOffset()) {
+				if (entry1Value == dynamicTable.getFileSection().getVirtualAddress()) {
 					// TODO: record artificial relative relocation for reversion/export concerns
 					entry1Value += imageBaseAdj; // adjust first entry value
 					if (elf.is64Bit()) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicTable.java
index 6a9912180..562d76eb5 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfDynamicTable.java
@@ -19,6 +19,7 @@ import java.io.IOException;
 import java.util.*;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
 import ghidra.program.model.data.*;
 import ghidra.util.DataConverter;
 import ghidra.util.exception.DuplicateNameException;
@@ -34,25 +35,18 @@ import ghidra.util.exception.NotFoundException;
  * using {@link ElfHeader#adjustAddressForPrelink(long)}.  If a pre-link adjustment is not applicable, 
  * this adjustment will have no affect.
  */
-public class ElfDynamicTable implements ElfFileSection {
+public class ElfDynamicTable implements StructConverter {
 
 	private List<ElfDynamic> dynamics = new ArrayList<ElfDynamic>();
 
 	private ElfHeader header;
-	private long fileOffset;
-	private long addrOffset;
-
-	public ElfDynamicTable(BinaryReader reader, ElfHeader header,
-			long fileOffset, long addrOffset) throws IOException {
-
-		long oldptr = reader.getPointerIndex();
+	private ElfFileSection fileSection;
 
+	public ElfDynamicTable(ElfHeader header, ElfFileSection fileSection) throws IOException {
 		this.header = header;
-		this.fileOffset = fileOffset;
-		this.addrOffset = addrOffset;
-
-		reader.setPointerIndex(fileOffset);
+		this.fileSection = fileSection;
 
+		BinaryReader reader = fileSection.getReader();
 		// Collect set of all _DYNAMIC array tags specified in .dynamic section
 		while (true) {
 			ElfDynamic dyn = new ElfDynamic(reader, header);
@@ -61,8 +55,6 @@ public class ElfDynamicTable implements ElfFileSection {
 				break;
 			}
 		}
-
-		reader.setPointerIndex(oldptr);
 	}
 
 	/**
@@ -184,14 +176,8 @@ public class ElfDynamicTable implements ElfFileSection {
 		return getDynamicValue(type.value);
 	}
 
-	@Override
-	public long getFileOffset() {
-		return fileOffset;
-	}
-
-	@Override
-	public long getAddressOffset() {
-		return addrOffset;
+	public ElfFileSection getFileSection() {
+		return fileSection;
 	}
 
 	@Override
@@ -239,13 +225,11 @@ public class ElfDynamicTable implements ElfFileSection {
 		return dynamicTagEnum;
 	}
 
-	@Override
-	public long getLength() {
+	public long getFileSize() {
 		return dynamics.size() * getEntrySize();
 	}
 
-	@Override
-	public int getEntrySize() {
+	public long getEntrySize() {
 		return header.is32Bit() ? 8 : 16;
 	}
 
@@ -256,8 +240,8 @@ public class ElfDynamicTable implements ElfFileSection {
 	 */
 	public byte[] toBytes(DataConverter dc)
 			throws ArrayIndexOutOfBoundsException {
-		byte[] data = new byte[(int) getLength()];
-		int entrySize = getEntrySize();
+		byte[] data = new byte[(int) getFileSize()];
+		int entrySize = (int) getEntrySize();
 		for (int i = 0; i < dynamics.size(); i++) {
 			ElfDynamic dyn = dynamics.get(i);
 			dyn.write(data, i * entrySize, dc);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSection.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSection.java
index 649089e3e..5c7ab7ce8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSection.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSection.java
@@ -15,9 +15,11 @@
  */
 package ghidra.app.util.bin.format.elf;
 
-import ghidra.app.util.bin.StructConverter;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.format.MemoryLoadable;
 
-public interface ElfFileSection extends StructConverter {
+public interface ElfFileSection extends MemoryLoadable {
 	
 	/**
 	 * Preferred memory address offset where data should be loaded.
@@ -25,7 +27,7 @@ public interface ElfFileSection extends StructConverter {
 	 * applied, although will not reflect any change in the image base.
 	 * @return default memory address offset where data should be loaded
 	 */
-	public long getAddressOffset();
+	public long getVirtualAddress();
 
 	/**
 	 * Offset within file where section bytes are specified
@@ -37,12 +39,60 @@ public interface ElfFileSection extends StructConverter {
 	 * Length of file section in bytes
 	 * @return length of file section in bytes
 	 */
-	public long getLength();
-	
+	public long getFileSize();
+
+	/**
+	 * Length of memory section in bytes
+	 * @return length of memory section in bytes
+	 */
+	default public long getMemorySize() {
+		return getFileSize();
+	}
+
 	/**
 	 * Size of each structured entry in bytes
-	 * @return entry size or -1 if variable
+	 * @return entry size or 0 if variable
+	 */
+	default public long getEntrySize() {
+		return 0;
+	}
+
+	/**
+	 * Binary reader for this file section
+	 * @return Binary reader
+	 */
+	public BinaryReader getReader();
+
+	/**
+	 * Byte provider for this file section
+	 * @return Byte provider
+	 */
+	default public ByteProvider getByteProvider() {
+		return getReader().getByteProvider();
+	}
+
+	/**
+	 * Create a subsection from this file section
+	 * @param offset Offset of subsection from beginning of this file section
+	 * @param size Length of subsection
+	 * @return file subsection
+	 */
+	default public ElfFileSection subSection(long offset, long size) {
+		return subSection(offset, size, getEntrySize());
+	}
+
+	/**
+	 * Create a subsection from this file section
+	 * @param offset Offset of subsection from beginning of this file section
+	 * @param size Length of subsection
+	 * @param entrySize Entry size for this subsection
+	 * @return file subsection
 	 */
-	public int getEntrySize();
+	default public ElfFileSection subSection(long offset, long size, long entrySize) {
+		if (offset == 0 && size == getMemorySize() && entrySize == getEntrySize()) {
+			return this;
+		}
 
+		return new ElfFileSectionWrapper(this, offset, size, entrySize);
+	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSectionWrapper.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSectionWrapper.java
new file mode 100644
index 000000000..7257c6967
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfFileSectionWrapper.java
@@ -0,0 +1,74 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.elf;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.UnlimitedByteProviderWrapper;
+
+public class ElfFileSectionWrapper implements ElfFileSection {
+    private ElfFileSection section;
+    private long subOffset;
+    private long subLength;
+    private long entrySize;
+    private BinaryReader reader;
+
+    public ElfFileSectionWrapper(ElfFileSection section, long subOffset, long subLength) {
+        this(section, subOffset, subLength, section.getEntrySize());
+    }
+
+    public ElfFileSectionWrapper(ElfFileSection section, long subOffset, long subLength,
+            long entrySize) {
+        this.section = section;
+        this.subOffset = subOffset;
+        this.subLength = subLength;
+        this.entrySize = entrySize;
+
+        ByteProvider provider =
+            new UnlimitedByteProviderWrapper(section.getByteProvider(), subOffset, subLength);
+        this.reader = new BinaryReader(provider, section.getReader().isLittleEndian());
+    }
+
+    @Override
+    public long getVirtualAddress() {
+        return section.getVirtualAddress() + subOffset;
+    }
+
+    @Override
+    public long getFileOffset() {
+        return section.getFileOffset() + subOffset;
+    }
+
+    @Override
+    public long getFileSize() {
+        return Math.min(Math.max(section.getFileSize() - subOffset, 0), subLength);
+    }
+
+    @Override
+    public long getMemorySize() {
+        return subLength;
+    }
+
+    @Override
+    public long getEntrySize() {
+        return entrySize;
+    }
+
+    @Override
+    public BinaryReader getReader() {
+        return reader.clone(0);
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java
index 346bc685d..4645eb8c2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfHeader.java
@@ -47,8 +47,6 @@ public class ElfHeader implements StructConverter, Writeable {
 	private HashMap<Integer, ElfSectionHeaderType> sectionHeaderTypeMap;
 	private HashMap<Integer, ElfDynamicType> dynamicTypeMap;
 
-	private ByteProvider provider; // original byte provider
-	private BinaryReader reader; // unlimited reader
 	private ElfLoadAdapter elfLoadAdapter = new ElfLoadAdapter();
 
 	private byte e_ident_magic_num; //magic number
@@ -75,9 +73,7 @@ public class ElfHeader implements StructConverter, Writeable {
 
 	private Structure headerStructure;
 
-	private boolean parsed = false;
-	private boolean parsedSectionHeaders = false;
-
+	private Long preLinkImageBase = null;
 	private ElfSectionHeader section0 = null;
 	private ElfSectionHeader[] sectionHeaders = new ElfSectionHeader[0];
 	private ElfProgramHeader[] programHeaders = new ElfProgramHeader[0];
@@ -103,43 +99,49 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @param provider byte provider
 	 * @param errorConsumer error consumer
 	 * @throws ElfException if header parse failed
+	 * @throws IOException if file IO error occurs
 	 */
-	public ElfHeader(ByteProvider provider, Consumer<String> errorConsumer) throws ElfException {
-		this.provider = provider;
+	public ElfHeader(ByteProvider provider, Consumer<String> errorConsumer) throws ElfException, IOException {
 		this.errorConsumer = errorConsumer != null ? errorConsumer : msg -> {
 			/* no logging if errorConsumer was null */
 		};
-		initElfHeader();
-	}
 
-	/**
-	 * Returns the unconstrained binary reader (i.e., reads beyond EOF
-	 * will return 0-bytes).
-	 * @return the binary reader
-	 */
-	public BinaryReader getReader() {
-		return reader;
-	}
+		BinaryReader reader = initElfHeader(provider);
 
-	/**
-	 * Returns the byte provider
-	 * @return the byte provider
-	 */
-	public ByteProvider getByteProvider() {
-		return provider;
+		initElfLoadAdapter();
+
+		parsePreLinkImageBase(reader);
+
+		parseProgramHeaders(reader);
+
+		parseSectionHeaders(reader);
+
+		parseDynamicTable();
+
+		parseStringTables();
+		parseDynamicLibraryNames();
+		parseSymbolTables(reader);
+		parseRelocationTables();
+
+		parseGNU_d();
+		parseGNU_r();
 	}
 
 	void logError(String msg) {
 		errorConsumer.accept(msg);
 	}
 
-	protected void initElfHeader() throws ElfException {
+	protected BinaryReader initElfHeader(ByteProvider provider) throws ElfException {
 		try {
+			if (provider.length() < INITIAL_READ_LEN) {
+				throw new ElfException("Not enough bytes to be a valid ELF executable.");
+			}
+			byte[] initialBytes = provider.readBytes(0, INITIAL_READ_LEN);
 
-			determineHeaderEndianess();
+			determineHeaderEndianess(initialBytes);
 
 			// reader uses unbounded provider wrapper to allow handling of missing/truncated headers
-			reader = new BinaryReader(new UnlimitedByteProviderWrapper(provider),
+			BinaryReader reader = new BinaryReader(new UnlimitedByteProviderWrapper(provider),
 				hasLittleEndianHeaders);
 
 			e_ident_magic_num = reader.readNextByte();
@@ -191,28 +193,30 @@ public class ElfHeader implements StructConverter, Writeable {
 
 			if (e_shnum == 0 ||
 				e_shnum >= Short.toUnsignedInt(ElfSectionHeaderConstants.SHN_LORESERVE)) {
-				e_shnum = readExtendedSectionHeaderCount(); // use extended stored section header count
+				e_shnum = readExtendedSectionHeaderCount(reader); // use extended stored section header count
 			}
 
 			if (e_phnum == Short.toUnsignedInt(ElfConstants.PN_XNUM)) {
-				e_phnum = readExtendedProgramHeaderCount(); // use extended stored program header count
+				e_phnum = readExtendedProgramHeaderCount(reader); // use extended stored program header count
 			}
 
 			if (e_shnum == 0) {
 				e_shstrndx = 0;
 			}
 			else if (e_shstrndx == Short.toUnsignedInt(ElfSectionHeaderConstants.SHN_XINDEX)) {
-				e_shstrndx = readExtendedSectionHeaderStringTableIndex();
+				e_shstrndx = readExtendedSectionHeaderStringTableIndex(reader);
 			}
+
+			return reader;
 		}
 		catch (IOException e) {
 			throw new ElfException(e);
 		}
 	}
 
-	private ElfSectionHeader getSection0() throws IOException {
+	private ElfSectionHeader getSection0(BinaryReader reader) throws IOException {
 		if (section0 == null && e_shoff != 0) {
-			if (!providerContainsRegion(e_shoff, e_shentsize)) {
+			if (!providerContainsRegion(reader, e_shoff, e_shentsize)) {
 				return null;
 			}
 			reader.setPointerIndex(e_shoff);
@@ -228,10 +232,10 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return extended program header count or 0 if not found or out of range
 	 * @throws IOException if file IO error occurs
 	 */
-	private int readExtendedProgramHeaderCount() throws IOException {
-		ElfSectionHeader s = getSection0();
+	private int readExtendedProgramHeaderCount(BinaryReader reader) throws IOException {
+		ElfSectionHeader s = getSection0(reader);
 		if (s != null && s.getType() == ElfSectionHeaderConstants.SHT_NULL) {
-			int val = s.getInfo();
+			int val = s.sh_info;
 			return val < 0 ? 0 : val;
 		}
 		return 0;
@@ -244,10 +248,10 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return extended section header count or 0 if not found or out of range
 	 * @throws IOException if file IO error occurs
 	 */
-	private int readExtendedSectionHeaderCount() throws IOException {
-		ElfSectionHeader s = getSection0();
+	private int readExtendedSectionHeaderCount(BinaryReader reader) throws IOException {
+		ElfSectionHeader s = getSection0(reader);
 		if (s != null && s.getType() == ElfSectionHeaderConstants.SHT_NULL) {
-			long val = s.getSize();
+			long val = s.sh_size;
 			return (val < 0 || val > Integer.MAX_VALUE) ? 0 : (int) val;
 		}
 		return 0;
@@ -260,10 +264,10 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return extended section header count or 0 if not found or out of range
 	 * @throws IOException if file IO error occurs
 	 */
-	private int readExtendedSectionHeaderStringTableIndex() throws IOException {
-		ElfSectionHeader s = getSection0();
+	private int readExtendedSectionHeaderStringTableIndex(BinaryReader reader) throws IOException {
+		ElfSectionHeader s = getSection0(reader);
 		if (s != null && s.getType() == ElfSectionHeaderConstants.SHT_NULL) {
-			int val = s.getLink();
+			int val = s.sh_link;
 			return val < 0 ? 0 : val;
 		}
 		return 0;
@@ -289,38 +293,6 @@ public class ElfHeader implements StructConverter, Writeable {
 		}
 	}
 
-	/**
-	 * Perform parse of all supported headers.
-	 * @throws IOException if file IO error occurs
-	 */
-	public void parse() throws IOException {
-
-		if (reader == null) {
-			throw new IOException("ELF binary reader is null!");
-		}
-		if (parsed) {
-			return;
-		}
-
-		initElfLoadAdapter();
-
-		parsed = true;
-
-		parseProgramHeaders();
-
-		parseSectionHeaders();
-
-		parseDynamicTable();
-
-		parseStringTables();
-		parseDynamicLibraryNames();
-		parseSymbolTables();
-		parseRelocationTables();
-
-		parseGNU_d();
-		parseGNU_r();
-	}
-
 	/**
 	 * Get the installed extension provider.  If the parse method has not yet been 
 	 * invoked, the default adapter will be returned.
@@ -343,12 +315,7 @@ public class ElfHeader implements StructConverter, Writeable {
 		// addresses in the default space?  Should loads into
 		// data space have the same adjustment?
 
-		long base = getPreLinkImageBase();
-		if (base == -1) {
-			base = 0;
-		}
-
-		return base + address;
+		return address + (preLinkImageBase != null ? preLinkImageBase : 0L);
 	}
 
 	/**
@@ -364,12 +331,7 @@ public class ElfHeader implements StructConverter, Writeable {
 		// addresses in the default space?  Should loads into
 		// data space have the same adjustment?
 
-		long base = getPreLinkImageBase();
-		if (base == -1) {
-			base = 0;
-		}
-
-		return address - base;
+		return address - (preLinkImageBase != null ? preLinkImageBase : 0L);
 	}
 
 	protected HashMap<Integer, ElfProgramHeaderType> getProgramHeaderTypeMap() {
@@ -494,7 +456,7 @@ public class ElfHeader implements StructConverter, Writeable {
 				sectionHeaderType == ElfSectionHeaderConstants.SHT_ANDROID_RELR) {
 
 				for (ElfRelocationTable relocTable : relocationTableList) {
-					if (relocTable.getFileOffset() == section.getOffset()) {
+					if (relocTable.getFileSection().getFileOffset() == section.getFileOffset()) {
 						return; // skip reloc table previously parsed as dynamic entry
 					}
 				}
@@ -547,10 +509,8 @@ public class ElfHeader implements StructConverter, Writeable {
 					format = TableFormat.RELR;
 				}
 
-				ElfRelocationTable relocTable = new ElfRelocationTable(reader,
-					this, section, section.getOffset(), section.getAddress(), section.getSize(),
-					section.getEntrySize(), addendTypeReloc, symbolTable, sectionToBeRelocated,
-					format);
+				ElfRelocationTable relocTable = new ElfRelocationTable(this, section,
+					addendTypeReloc, symbolTable, sectionToBeRelocated, format);
 
 				relocationTableList.add(relocTable);
 			}
@@ -621,7 +581,7 @@ public class ElfHeader implements StructConverter, Writeable {
 
 			long relocTableOffset = relocTableLoadHeader.getOffset(relocTableAddr);
 			for (ElfRelocationTable relocTable : relocationTableList) {
-				if (relocTable.getFileOffset() == relocTableOffset) {
+				if (relocTable.getFileSection().getFileOffset() == relocTableOffset) {
 					return; // skip reloc table previously parsed
 				}
 			}
@@ -639,8 +599,8 @@ public class ElfHeader implements StructConverter, Writeable {
 				format = TableFormat.RELR;
 			}
 
-			ElfRelocationTable relocTable = new ElfRelocationTable(reader,
-				this, null, relocTableOffset, relocTableAddr, tableSize, tableEntrySize,
+			ElfFileSection fileSection = relocTableLoadHeader.subSection(relocTableAddr - relocTableLoadHeader.getVirtualAddress(), tableSize, tableEntrySize);
+			ElfRelocationTable relocTable = new ElfRelocationTable(this, fileSection,
 				addendTypeReloc, dynamicSymbolTable, null, format);
 			relocationTableList.add(relocTable);
 		}
@@ -685,7 +645,7 @@ public class ElfHeader implements StructConverter, Writeable {
 			if (dynamicStringTable != null) {
 				try {
 					dynamicLibraryNames[i] =
-						dynamicStringTable.readString(reader, needed[i].getValue());
+						dynamicStringTable.readString(needed[i].getValue());
 				}
 				catch (Exception e) {
 					// ignore
@@ -704,17 +664,16 @@ public class ElfHeader implements StructConverter, Writeable {
 			// The p_offset may not refer to the start of the DYNAMIC table so we must use
 			// p_vaddr to find it relative to a PT_LOAD segment
 			long vaddr = dynamicHeaders[0].getVirtualAddress();
-			if (vaddr == 0 || dynamicHeaders[0].getFileSize() == 0) {
+			long size = dynamicHeaders[0].getFileSize();
+			if (vaddr == 0 || size == 0) {
 				Msg.warn(this, "ELF Dynamic table appears to have been stripped from binary");
 				return;
 			}
 
 			ElfProgramHeader loadHeader = getProgramLoadHeaderContaining(vaddr);
 			if (loadHeader != null) {
-				long dynamicTableOffset = loadHeader.getOffset() +
-					(dynamicHeaders[0].getVirtualAddress() - loadHeader.getVirtualAddress());
-				dynamicTable = new ElfDynamicTable(reader, this, dynamicTableOffset,
-					dynamicHeaders[0].getVirtualAddress());
+				ElfFileSection section = loadHeader.subSection(vaddr - loadHeader.getVirtualAddress(), size);
+				dynamicTable = new ElfDynamicTable(this, section);
 				return;
 			}
 		}
@@ -725,15 +684,7 @@ public class ElfHeader implements StructConverter, Writeable {
 		ElfSectionHeader[] dynamicSections = getSections(ElfSectionHeaderConstants.SHT_DYNAMIC);
 		if (dynamicSections.length == 1) {
 
-			ElfProgramHeader loadHeader =
-				getProgramLoadHeaderContaining(dynamicSections[0].getAddress());
-			if (loadHeader != null) {
-				long dynamicTableOffset = loadHeader.getOffset() +
-					(dynamicSections[0].getAddress() - loadHeader.getVirtualAddress());
-				dynamicTable = new ElfDynamicTable(reader, this, dynamicTableOffset,
-					dynamicSections[0].getAddress());
-				return;
-			}
+			dynamicTable = new ElfDynamicTable(this, dynamicSections[0]);
 		}
 
 	}
@@ -755,11 +706,9 @@ public class ElfHeader implements StructConverter, Writeable {
 		ArrayList<ElfStringTable> stringTableList = new ArrayList<>();
 		for (ElfSectionHeader stringTableSectionHeader : sectionHeaders) {
 			if (stringTableSectionHeader.getType() == ElfSectionHeaderConstants.SHT_STRTAB) {
-				ElfStringTable stringTable = new ElfStringTable(this, stringTableSectionHeader,
-					stringTableSectionHeader.getOffset(), stringTableSectionHeader.getAddress(),
-					stringTableSectionHeader.getSize());
+				ElfStringTable stringTable = new ElfStringTable(this, stringTableSectionHeader);
 				stringTableList.add(stringTable);
-				if (stringTable.getAddressOffset() == dynamicStringTableAddr) {
+				if (stringTableSectionHeader.getVirtualAddress() == dynamicStringTableAddr) {
 					dynamicStringTable = stringTable;
 				}
 			}
@@ -800,9 +749,8 @@ public class ElfHeader implements StructConverter, Writeable {
 				return null;
 			}
 
-			return new ElfStringTable(this, null,
-				stringTableLoadHeader.getOffset(dynamicStringTableAddr), dynamicStringTableAddr,
-				stringTableSize);
+			ElfFileSection fileSection = stringTableLoadHeader.subSection(dynamicStringTableAddr - stringTableLoadHeader.getVirtualAddress(), stringTableSize);
+			return new ElfStringTable(this, fileSection);
 		}
 		catch (NotFoundException e) {
 			throw new AssertException(e);
@@ -835,29 +783,25 @@ public class ElfHeader implements StructConverter, Writeable {
 		}
 
 		// determine number of 32-bit index elements for int[]
-		int count = (int) (symbolSectionIndexHeader.getSize() / 4);
+		int count = (int) (symbolSectionIndexHeader.getFileSize() / 4);
 		int[] indexTable = new int[count];
 
-		long ptr = reader.getPointerIndex();
 		try {
-			reader.setPointerIndex(symbolSectionIndexHeader.getOffset());
+			BinaryReader reader = symbolSectionIndexHeader.getReader();
 			for (int i = 0; i < count; i++) {
 				indexTable[i] = reader.readNextInt();
 			}
 		}
 		catch (IOException e) {
 			errorConsumer.accept("Failed to read symbol section index table at 0x" +
-				Long.toHexString(symbolSectionIndexHeader.getOffset()) + ": " +
+				Long.toHexString(symbolSectionIndexHeader.getFileOffset()) + ": " +
 				symbolSectionIndexHeader.getNameAsString());
 		}
-		finally {
-			reader.setPointerIndex(ptr); // restore reader position
-		}
 
 		return indexTable;
 	}
 
-	private void parseSymbolTables() throws IOException {
+	private void parseSymbolTables(BinaryReader reader) throws IOException {
 
 		// identify dynamic symbol table address
 		long dynamicSymbolTableAddr = -1;
@@ -897,20 +841,17 @@ public class ElfHeader implements StructConverter, Writeable {
 				int[] symbolSectionIndexTable =
 					getExtendedSymbolSectionIndexTable(symbolTableSectionHeader);
 
-				ElfSymbolTable symbolTable = new ElfSymbolTable(reader, this,
-					symbolTableSectionHeader, symbolTableSectionHeader.getOffset(),
-					symbolTableSectionHeader.getAddress(), symbolTableSectionHeader.getSize(),
-					symbolTableSectionHeader.getEntrySize(), stringTable, symbolSectionIndexTable,
-					isDyanmic);
+				ElfSymbolTable symbolTable = new ElfSymbolTable(this, symbolTableSectionHeader,
+					stringTable, symbolSectionIndexTable, isDyanmic);
 				symbolTableList.add(symbolTable);
-				if (symbolTable.getAddressOffset() == dynamicSymbolTableAddr) {
+				if (symbolTableSectionHeader.getVirtualAddress() == dynamicSymbolTableAddr) {
 					dynamicSymbolTable = symbolTable; // remember dynamic symbol table
 				}
 			}
 		}
 
 		if (dynamicSymbolTable == null && dynamicSymbolTableAddr != -1) {
-			dynamicSymbolTable = parseDynamicSymbolTable();
+			dynamicSymbolTable = parseDynamicSymbolTable(reader);
 			if (dynamicSymbolTable != null) {
 				symbolTableList.add(dynamicSymbolTable);
 			}
@@ -933,7 +874,7 @@ public class ElfHeader implements StructConverter, Writeable {
 		return null;
 	}
 
-	private ElfSymbolTable parseDynamicSymbolTable() throws IOException {
+	private ElfSymbolTable parseDynamicSymbolTable(BinaryReader reader) throws IOException {
 
 		ElfDynamicType dynamicHashType = getDynamicHashTableType();
 
@@ -984,17 +925,14 @@ public class ElfHeader implements StructConverter, Writeable {
 				return null;
 			}
 
-			// Create dynamic symbol table if not defined as a section
-			long symbolTableOffset = symbolTableLoadHeader.getOffset(tableAddr);
-
 			// determine symbol count from dynamic symbol hash table
 			int symCount;
 			long symbolHashTableOffset = hashTableLoadHeader.getOffset(hashTableAddr);
 			if (dynamicHashType == ElfDynamicType.DT_GNU_HASH) {
-				symCount = deriveGnuHashDynamicSymbolCount(symbolHashTableOffset);
+				symCount = deriveGnuHashDynamicSymbolCount(reader, symbolHashTableOffset);
 			}
 			else if (dynamicHashType == ElfDynamicType.DT_GNU_XHASH) {
-				symCount = deriveGnuXHashDynamicSymbolCount(symbolHashTableOffset);
+				symCount = deriveGnuXHashDynamicSymbolCount(reader, symbolHashTableOffset);
 			}
 			else {
 				// DT_HASH table, nchain corresponds is same as symbol count
@@ -1004,9 +942,8 @@ public class ElfHeader implements StructConverter, Writeable {
 			// NOTE: When parsed from dynamic table and not found via section header parse
 			// it is assumed that the extended symbol section table is not used.
 
-			return new ElfSymbolTable(reader, this, null, symbolTableOffset,
-				tableAddr, tableEntrySize * symCount, tableEntrySize, dynamicStringTable, null,
-				true);
+			ElfFileSection fileSection = symbolTableLoadHeader.subSection(tableAddr - symbolTableLoadHeader.getVirtualAddress(), tableEntrySize * symCount, tableEntrySize);
+			return new ElfSymbolTable(this, fileSection, dynamicStringTable, null, true);
 		}
 		catch (NotFoundException e) {
 			throw new AssertException(e);
@@ -1019,7 +956,7 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return dynamic symbol count
 	 * @throws IOException file read error
 	 */
-	private int deriveGnuHashDynamicSymbolCount(long gnuHashTableOffset) throws IOException {
+	private int deriveGnuHashDynamicSymbolCount(BinaryReader reader, long gnuHashTableOffset) throws IOException {
 		int numBuckets = reader.readInt(gnuHashTableOffset);
 		int symbolBase = reader.readInt(gnuHashTableOffset + 4);
 		int bloomSize = reader.readInt(gnuHashTableOffset + 8);
@@ -1058,7 +995,7 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return dynamic symbol count
 	 * @throws IOException file read error
 	 */
-	private int deriveGnuXHashDynamicSymbolCount(long gnuHashTableOffset) throws IOException {
+	private int deriveGnuXHashDynamicSymbolCount(BinaryReader reader, long gnuHashTableOffset) throws IOException {
 		// Elf32_Word  ngnusyms;  // number of entries in chains (and xlat); dynsymcount=symndx+ngnusyms
 		// Elf32_Word  nbuckets;  // number of hash table buckets
 		// Elf32_Word  symndx;  // number of initial .dynsym entires skipped in chains[] (and xlat[])
@@ -1069,37 +1006,42 @@ public class ElfHeader implements StructConverter, Writeable {
 	}
 
 	/**
-	 * Perform offset region check against byte provider.
-	 * This is done against the byte provider since the
-	 * reader is unbounded.
+	 * Perform offset region check against binary provider.
 	 * @param offset starting offset
 	 * @param length length of range
 	 * @return true if provider contains specified byte offset range
 	 */
-	private boolean providerContainsRegion(long offset, int length) {
+	private static boolean providerContainsRegion(BinaryReader reader, long offset, int length) {
 		try {
-			return offset >= 0 && (offset + length) <= provider.length();
+			return offset >= 0 && (offset + length) <= reader.length();
 		}
 		catch (IOException e) {
 			return false;
 		}
 	}
 
-	protected void parseSectionHeaders()
-			throws IOException {
-		if (reader == null) {
-			throw new IOException("ELF binary reader is null!");
-		}
-		if (parsedSectionHeaders) {
-			return;
+	/**
+	 * Some elfs can get pre-linked to an OS. At the very end a "PRE " string is
+	 * appended with the image base load address set.
+	 */
+	protected void parsePreLinkImageBase(BinaryReader reader) throws IOException {
+		long fileLength = reader.getByteProvider().length();
+
+		int preLinkImageBaseInt = reader.readInt(fileLength - 8);
+		String preLinkMagicString = reader.readAsciiString(fileLength - 4, 4).trim();
+
+		if (preLinkMagicString.equals("PRE")) {
+			preLinkImageBase = Integer.toUnsignedLong(preLinkImageBaseInt);
 		}
+	}
 
-		parsedSectionHeaders = true;
+	protected void parseSectionHeaders(BinaryReader reader)
+			throws IOException {
 		boolean missing = false;
 		sectionHeaders = new ElfSectionHeader[e_shnum];
 		for (int i = 0; i < e_shnum; ++i) {
 			long index = e_shoff + (i * e_shentsize);
-			if (!missing && !providerContainsRegion(index, e_shentsize)) {
+			if (!missing && !providerContainsRegion(reader, index, e_shentsize)) {
 				int unreadCnt = e_shnum - i;
 				errorConsumer.accept(
 					unreadCnt + " of " + e_shnum +
@@ -1126,13 +1068,13 @@ public class ElfHeader implements StructConverter, Writeable {
 		}
 	}
 
-	private void parseProgramHeaders()
+	private void parseProgramHeaders(BinaryReader reader)
 			throws IOException {
 		boolean missing = false;
 		programHeaders = new ElfProgramHeader[e_phnum];
 		for (int i = 0; i < e_phnum; ++i) {
 			long index = e_phoff + (i * e_phentsize);
-			if (!missing && !providerContainsRegion(index, e_phentsize)) {
+			if (!missing && !providerContainsRegion(reader, index, e_phentsize)) {
 				int unreadCnt = e_phnum - i;
 				errorConsumer.accept(
 					unreadCnt + " of " + e_phnum +
@@ -1201,43 +1143,6 @@ public class ElfHeader implements StructConverter, Writeable {
 		return minBase;
 	}
 
-	/**
-	 * Inspect the Elf image and determine the default image base prior 
-	 * to any parse method being invoked (i.e., only the main Elf
-	 * header structure has been parsed during initialization.
-	 * The image base is the virtual address of the PT_LOAD program header
-	 * with the smallest address or 0 if no program headers exist.  By default,
-	 * the image base address should be treated as a addressable unit offset.
-	 * @return preferred image base 
-	 */
-	public long findImageBase() {
-
-		// FIXME! This needs to be consistent with the getImageBase() method
-		// which currently considers prelink. 
-
-		long minBase = -1;
-
-		int n = Math.min(e_phnum, MAX_HEADERS_TO_CHECK_FOR_IMAGEBASE);
-		for (int i = 0; i < n; ++i) {
-			long index = e_phoff + (i * e_phentsize);
-			if (!providerContainsRegion(index, e_phentsize)) {
-				break;
-			}
-			reader.setPointerIndex(index);
-			try {
-				int headerType = reader.peekNextInt();
-				if (headerType == ElfProgramHeaderConstants.PT_LOAD) {
-					ElfProgramHeader header = new ElfProgramHeader(reader, this);
-					minBase = getMinBase(header.getVirtualAddress(), minBase);
-				}
-			}
-			catch (IOException e) {
-				// skip
-			}
-		}
-		return minBase == -1 ? 0 : minBase;
-	}
-
 	private Long elfImageBase;
 
 	/**
@@ -1254,9 +1159,8 @@ public class ElfHeader implements StructConverter, Writeable {
 
 		elfImageBase = 0L;
 
-		long base = getPreLinkImageBase();
-		if (base != -1) {
-			elfImageBase = base;
+		if (preLinkImageBase != null) {
+			elfImageBase = preLinkImageBase;
 		}
 		else {
 			int n = Math.min(programHeaders.length, MAX_HEADERS_TO_CHECK_FOR_IMAGEBASE);
@@ -1280,7 +1184,7 @@ public class ElfHeader implements StructConverter, Writeable {
 	 * @return true if image has been pre-linked
 	 */
 	public boolean isPreLinked() {
-		if (getPreLinkImageBase() != -1L) {
+		if (preLinkImageBase != null) {
 			return true;
 		}
 		if (dynamicTable != null) {
@@ -1291,48 +1195,15 @@ public class ElfHeader implements StructConverter, Writeable {
 		return false;
 	}
 
-	private Long preLinkImageBase = null;
-
-	/**
-	 *  Some elfs can get pre-linked to an OS.
-	 *     At the very end a "PRE " string is appended with the image base load address
-	 *     set.  Try there if none of the images told us where to load.
-	 * @return -1 - if the imagebase is not a pre-link image base.
-	 */
-	private long getPreLinkImageBase() {
-		if (preLinkImageBase != null) {
-			return preLinkImageBase;
-		}
-		preLinkImageBase = -1L;
-		try {
-			long fileLength = reader.getByteProvider().length();
-
-			// not enough bytes
-			if (fileLength < 8) {
-				return -1;
-			}
-			int preLinkImageBaseInt = reader.readInt(fileLength - 8);
-			String preLinkMagicString = reader.readAsciiString(fileLength - 4, 4).trim();
-
-			if (preLinkMagicString.equals("PRE")) {
-				preLinkImageBase = Integer.toUnsignedLong(preLinkImageBaseInt);
-			}
-		}
-		catch (IOException e) {
-			Msg.error(this, "Elf prelink read failure", e);
-		}
-		return preLinkImageBase;
-	}
-
 	public boolean isSectionLoaded(ElfSectionHeader section) {
 		if (section.getType() == ElfSectionHeaderConstants.SHT_NULL) {
 			return false;
 		}
-		long sectionStart = section.getAddress();
+		long sectionStart = section.getVirtualAddress();
 		if (sectionStart == 0) {
 			return false;
 		}
-		long sectionEnd = section.getSize() - 1 + sectionStart;
+		long sectionEnd = section.getFileSize() - 1 + sectionStart;
 		for (ElfProgramHeader segment : programHeaders) {
 			if (segment.getType() != ElfProgramHeaderConstants.PT_LOAD) {
 				continue;
@@ -1346,21 +1217,55 @@ public class ElfHeader implements StructConverter, Writeable {
 		return false;
 	}
 
-	private void determineHeaderEndianess() throws ElfException, IOException {
-
-		if (provider.length() < INITIAL_READ_LEN) {
-			throw new ElfException("Not enough bytes to be a valid ELF executable.");
-		}
-
+	public ElfHeader(byte e_ident_class, byte e_ident_data, byte e_ident_version,
+			byte e_ident_osabi, byte e_ident_abiversion, short e_type, short e_machine,
+			int e_version, long e_entry, int e_flags) throws ElfException {
+		this.e_ident_magic_num = ElfConstants.MAGIC_NUM;
+		this.e_ident_magic_str = ElfConstants.MAGIC_STR;
+		this.e_ident_class = e_ident_class;
+		this.e_ident_data = e_ident_data;
+		this.e_ident_version = e_ident_version;
+		this.e_ident_osabi = e_ident_osabi;
+		this.e_ident_abiversion = e_ident_abiversion;
+		this.e_ident_pad = new byte[PAD_LENGTH];
+
+		determineHeaderEndianess(e_ident_data);
+		if (!is32Bit() && !is64Bit()) {
+			throw new ElfException(
+				"Only 32-bit and 64-bit ELF headers are supported (EI_CLASS=0x" +
+					Integer.toHexString(e_ident_class) + ")");
+		}
+
+		this.e_type = e_type;
+		this.e_machine = e_machine;
+		this.e_version = e_version;
+		this.e_entry = e_entry;
+		this.e_phoff = 0;
+		this.e_shoff = 0;
+		this.e_flags = e_flags;
+		this.e_ehsize = (short) (is32Bit() ? 52 : 64);
+		this.e_phentsize = (short) (is32Bit() ? 32 : 56);
+		this.e_phnum = 0;
+		this.e_shentsize = (short) (is32Bit() ? 40 : 64);
+		this.e_shnum = 0;
+		this.e_shstrndx = 0;
+	}
+
+	private void determineHeaderEndianess(byte ident_data) throws ElfException {
 		hasLittleEndianHeaders = true;
-		byte[] bytes = provider.readBytes(0, INITIAL_READ_LEN);
-		if (bytes[ElfConstants.EI_DATA] == ElfConstants.ELF_DATA_BE) {
+
+		if (ident_data == ElfConstants.ELF_DATA_BE) {
 			hasLittleEndianHeaders = false;
 		}
-		else if (bytes[ElfConstants.EI_DATA] != ElfConstants.ELF_DATA_LE) {
+		else if (ident_data != ElfConstants.ELF_DATA_LE) {
 			errorConsumer.accept("Invalid EI_DATA, assuming little-endian headers (EI_DATA=0x" +
-				Integer.toHexString(bytes[ElfConstants.EI_DATA]) + ")");
+				Integer.toHexString(ident_data) + ")");
 		}
+	}
+
+	private void determineHeaderEndianess(byte[] bytes) throws ElfException {
+		determineHeaderEndianess(bytes[ElfConstants.EI_DATA]);
+
 		if (!hasLittleEndianHeaders && bytes[ElfConstants.EI_NIDENT] != 0) {
 			// Header endianess sanity check
 			// Some toolchains always use little endian Elf Headers
@@ -1610,7 +1515,7 @@ public class ElfHeader implements StructConverter, Writeable {
 			if (!sectionHeader.isAlloc()) {
 				continue;
 			}
-			if (sectionHeader.getAddress() == address) {
+			if (sectionHeader.getVirtualAddress() == address) {
 				return sectionHeader;
 			}
 		}
@@ -1629,8 +1534,8 @@ public class ElfHeader implements StructConverter, Writeable {
 			if (!sectionHeader.isAlloc()) {
 				continue;
 			}
-			long start = sectionHeader.getAddress();
-			long end = start + sectionHeader.getSize();
+			long start = sectionHeader.getVirtualAddress();
+			long end = start + sectionHeader.getFileSize();
 			if (start <= address && address <= end) {
 				return sectionHeader;
 			}
@@ -1652,11 +1557,11 @@ public class ElfHeader implements StructConverter, Writeable {
 				section.isInvalidOffset()) {
 				continue;
 			}
-			long size = section.getSize();
+			long size = section.getFileSize();
 			if (size == 0) {
 				continue;
 			}
-			long start = section.getOffset();
+			long start = section.getFileOffset();
 			long end = start + size - 1;
 			if (fileOffset >= start && maxOffset <= end) {
 				return section;
@@ -1780,7 +1685,7 @@ public class ElfHeader implements StructConverter, Writeable {
 				programHeader.isInvalidOffset()) {
 				continue;
 			}
-			long start = programHeader.getOffset();
+			long start = programHeader.getFileOffset();
 			long end = start + (programHeader.getFileSize() - 1);
 			if (offset >= start && offset <= end) {
 				return programHeader;
@@ -1821,7 +1726,7 @@ public class ElfHeader implements StructConverter, Writeable {
 	 */
 	public ElfStringTable getStringTable(ElfSectionHeader section) {
 		for (ElfStringTable stringTable : stringTables) {
-			if (stringTable.getFileOffset() == section.getOffset()) {
+			if (stringTable.getFileSection() == section) {
 				return stringTable;
 			}
 		}
@@ -1847,15 +1752,15 @@ public class ElfHeader implements StructConverter, Writeable {
 	/**
 	 * Returns the symbol table associated to the specified section header.
 	 * Or, null if one does not exist.
-	 * @param symbolTableSection symbol table section header
+	 * @param section symbol table section header
 	 * @return the symbol table associated to the specified section header
 	 */
-	public ElfSymbolTable getSymbolTable(ElfSectionHeader symbolTableSection) {
-		if (symbolTableSection == null) {
+	public ElfSymbolTable getSymbolTable(ElfSectionHeader section) {
+		if (section == null) {
 			return null;
 		}
 		for (ElfSymbolTable symbolTable : symbolTables) {
-			if (symbolTable.getFileOffset() == symbolTableSection.getOffset()) {
+			if (symbolTable.getFileSection() == section) {
 				return symbolTable;
 			}
 		}
@@ -1873,11 +1778,19 @@ public class ElfHeader implements StructConverter, Writeable {
 	/**
 	 * Returns the relocation table associated to the specified section header,
 	 * or null if one does not exist.
-	 * @param relocSection section header corresponding to relocation table
+	 * @param section section header corresponding to relocation table
 	 * @return the relocation table associated to the specified section header
 	 */
-	public ElfRelocationTable getRelocationTable(ElfSectionHeader relocSection) {
-		return getRelocationTableAtOffset(relocSection.getOffset());
+	public ElfRelocationTable getRelocationTable(ElfSectionHeader section) {
+		if (section == null) {
+			return null;
+		}
+		for (ElfRelocationTable relocationTable : relocationTables) {
+			if (relocationTable.getFileSection() == section) {
+				return relocationTable;
+			}
+		}
+		return null;
 	}
 
 	/**
@@ -1888,7 +1801,7 @@ public class ElfHeader implements StructConverter, Writeable {
 	 */
 	public ElfRelocationTable getRelocationTableAtOffset(long fileOffset) {
 		for (ElfRelocationTable relocationTable : relocationTables) {
-			if (relocationTable.getFileOffset() == fileOffset) {
+			if (relocationTable.getFileSection().getFileOffset() == fileOffset) {
 				return relocationTable;
 			}
 		}
@@ -1997,44 +1910,87 @@ public class ElfHeader implements StructConverter, Writeable {
 	}
 
 	/**
-	 * Adds a new section using the specified memory block.
-	 * The memory block is used to setting the address and size.
-	 * As well as, setting the data.
-	 * @param block the memory block
-	 * @param sh_name the byte index into the string table where the name begins
-	 * @return the newly created section
-	 * @throws MemoryAccessException if any of the requested memory block bytes are uninitialized.
-	 */
-	public ElfSectionHeader addSection(MemoryBlock block, int sh_name)
-			throws MemoryAccessException {
-		ElfSectionHeader newSection = new ElfSectionHeader(this, block, sh_name, getImageBase());
-		addSection(newSection);
-		return newSection;
-	}
+	 * Create a new section header, create the associated table class (if applicable) and add them to this ElfHeader.
+	 * @param name Name of the section
+	 * @param type Type of this section
+	 * @param flags Flags for this section
+	 * @param link Linked section header, or null
+	 * @param info Information field for this section
+	 * @param addressAlignment Address alignment for this section
+	 * @param entrySize Entry size for this section
+	 * @param data Initial data for this section
+	 * @return newly created section
+	 * @throws IOException
+	 */
+	public ElfSectionHeader createSectionHeader(String name, int type, long flags,
+			ElfSectionHeader link, int info, long addressAlignment, long entrySize,
+			ByteProvider data) throws IOException {
+		int linkNum = link != null ? Arrays.asList(sectionHeaders).indexOf(link) : 0;
+
+		ElfSectionHeader section = new ElfSectionHeader(this, name, type, flags,
+			linkNum, info, addressAlignment, entrySize, data);
+
+		addSection(section);
+		if (type == ElfSectionHeaderConstants.SHT_STRTAB) {
+			List<ElfStringTable> stringTableList = new ArrayList<>(Arrays.asList(stringTables));
+			stringTableList.add(new ElfStringTable(this, section));
+			stringTables = stringTableList.toArray(new ElfStringTable[0]);
+		}
+		else if (type == ElfSectionHeaderConstants.SHT_SYMTAB) {
+			ElfStringTable stringTable = getStringTable(link);
+			List<ElfSymbolTable> symbolTableList = new ArrayList<>(Arrays.asList(symbolTables));
+			symbolTableList.add(new ElfSymbolTable(this, section, stringTable, null, false));
+			symbolTables = symbolTableList.toArray(new ElfSymbolTable[0]);
+		}
+		else if (type == ElfSectionHeaderConstants.SHT_REL ||
+			type == ElfSectionHeaderConstants.SHT_RELA ||
+			type == ElfSectionHeaderConstants.SHT_RELR ||
+			type == ElfSectionHeaderConstants.SHT_ANDROID_REL ||
+			type == ElfSectionHeaderConstants.SHT_ANDROID_RELA ||
+			type == ElfSectionHeaderConstants.SHT_ANDROID_RELR) {
+			ElfSectionHeader relocatedSection = sectionHeaders[info];
+			boolean addendTypeReloc = (type == ElfSectionHeaderConstants.SHT_RELA ||
+				type == ElfSectionHeaderConstants.SHT_ANDROID_RELA);
 
-	/**
-	 * Adds a new section the specifed name and name index.
-	 * The type of the section will be SHT_PROGBITS.
-	 * @param name the actual name of the new section
-	 * @param sh_name the byte index into the string table where the name begins
-	 * @return the newly created section
-	 */
-	public ElfSectionHeader addSection(String name, int sh_name) {
-		return addSection(name, sh_name, ElfSectionHeaderConstants.SHT_PROGBITS);
+			ElfRelocationTable.TableFormat format = TableFormat.DEFAULT;
+			if (type == ElfSectionHeaderConstants.SHT_ANDROID_REL ||
+				type == ElfSectionHeaderConstants.SHT_ANDROID_RELA) {
+				format = TableFormat.ANDROID;
+			}
+			else if (type == ElfSectionHeaderConstants.SHT_RELR ||
+				type == ElfSectionHeaderConstants.SHT_ANDROID_RELR) {
+				format = TableFormat.RELR;
+			}
+
+			ElfSymbolTable symbolTable = getSymbolTable(link);
+			List<ElfRelocationTable> relocationTableList =
+				new ArrayList<>(Arrays.asList(relocationTables));
+			relocationTableList.add(
+				new ElfRelocationTable(this, section, addendTypeReloc, symbolTable,
+					relocatedSection, format));
+			relocationTables = relocationTableList.toArray(new ElfRelocationTable[0]);
+		}
+
+		return section;
 	}
 
-	/**
-	 * Adds a new section the specifed name and name index.
-	 * The type of the section will be SHT_PROGBITS.
-	 * @param name the actual name of the new section
-	 * @param sh_name the byte index into the string table where the name begins
-	 * @param type the type of the new section
-	 * @return the newly created section
-	 */
-	public ElfSectionHeader addSection(String name, int sh_name, int type) {
-		ElfSectionHeader newSection = new ElfSectionHeader(this, name, sh_name, type);
-		addSection(newSection);
-		return newSection;
+	public void createSectionNameStringTable(String name) throws IOException {
+		if (e_shstrndx != 0) {
+			throw new RuntimeException("Section name string table already created");
+		}
+
+		e_shstrndx = e_shnum;
+		MutableByteProvider shstrtabProvider = new ByteArrayMutableByteProvider();
+		ElfSectionHeader shstrtab = createSectionHeader(name, ElfSectionHeaderConstants.SHT_STRTAB,
+			0, null, 0, 1, 0, shstrtabProvider);
+		ElfStringTable shStringTable = getStringTable(shstrtab);
+
+		for (ElfSectionHeader section : sectionHeaders) {
+			String sectionName = section.getNameAsString();
+			int strIndex = shStringTable.add(sectionName);
+
+			section.sh_name = strIndex;
+		}
 	}
 
 	/**
@@ -2114,14 +2070,14 @@ public class ElfHeader implements StructConverter, Writeable {
 			throw new IOException(
 				"Unsupported program header count serialization: " + e_phnum);
 		}
-		raf.write(dc.getBytes(e_phnum));
+		raf.write(dc.getBytes((short) e_phnum));
 		raf.write(dc.getBytes(e_shentsize));
 		if (e_shnum >= Short.toUnsignedInt(ElfSectionHeaderConstants.SHN_LORESERVE)) {
 			throw new IOException(
 				"Unsupported section header count serialization: " + e_shnum);
 		}
-		raf.write(dc.getBytes(e_shnum));
-		raf.write(dc.getBytes(e_shstrndx));
+		raf.write(dc.getBytes((short) e_shnum));
+		raf.write(dc.getBytes((short) e_shstrndx));
 	}
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfProgramHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfProgramHeader.java
index 58060255a..3759238be 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfProgramHeader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfProgramHeader.java
@@ -21,8 +21,10 @@ import java.io.IOException;
 import java.io.RandomAccessFile;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.ByteProviderWrapper;
 import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.MemoryLoadable;
+import ghidra.app.util.bin.UnlimitedByteProviderWrapper;
 import ghidra.app.util.bin.format.Writeable;
 import ghidra.program.model.data.*;
 import ghidra.util.DataConverter;
@@ -66,7 +68,7 @@ import ghidra.util.StringUtilities;
  * </pre>
  */
 public class ElfProgramHeader
-		implements StructConverter, Comparable<ElfProgramHeader>, Writeable, MemoryLoadable {
+		implements ElfFileSection, StructConverter, Comparable<ElfProgramHeader>, Writeable {
 
 	protected ElfHeader header;
 
@@ -84,7 +86,6 @@ public class ElfProgramHeader
 	public ElfProgramHeader(BinaryReader reader, ElfHeader header)
 			throws IOException {
 		this.header = header;
-		this.reader = reader;
 
 		if (header.is32Bit()) {
 			p_type = reader.readNextInt();
@@ -107,14 +108,22 @@ public class ElfProgramHeader
 			p_align = reader.readNextLong();
 		}
 
-		if (p_memsz > p_filesz) {
-			//This case occurs when the data segment has both
-			//initialized and uninitialized sections.
-			//For example, the data program header may be comprised
-			//of ".data", ".dynamic", ".ctors", ".dtors", ".jcr", 
-			//and ".bss".
-			//TODO Err.warn(this, "Program Header: extra bytes");
+		ByteProvider provider;
+		if (p_type == ElfProgramHeaderConstants.PT_NULL) {
+			provider = ByteProvider.EMPTY_BYTEPROVIDER;
 		}
+		else {
+			provider = new UnlimitedByteProviderWrapper(reader.getByteProvider(), p_offset, p_filesz);
+			if (p_memsz > p_filesz) {
+				//This case occurs when the data segment has both
+				//initialized and uninitialized sections.
+				//For example, the data program header may be comprised
+				//of ".data", ".dynamic", ".ctors", ".dtors", ".jcr",
+				//and ".bss".
+				provider = new UnlimitedByteProviderWrapper(provider, 0, p_memsz);
+			}
+		}
+		this.reader = new BinaryReader(provider, reader.isLittleEndian());
 	}
 
 	/**
@@ -312,7 +321,7 @@ public class ElfProgramHeader
 	 * the first byte of the segment resides.
 	 * @return the offset from the beginning of the file
 	 */
-	public long getOffset() {
+	public long getFileOffset() {
 		return p_offset;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocation.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocation.java
index ec9c6d1a9..7d5b03f0a 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocation.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocation.java
@@ -98,7 +98,7 @@ public class ElfRelocation implements ByteArrayConverter, StructConverter {
 	 * @return ELF relocation object
 	 * @throws IOException if an IO or parse error occurs
 	 */
-	static ElfRelocation createElfRelocation(BinaryReader reader,
+	public static ElfRelocation createElfRelocation(BinaryReader reader,
 			ElfHeader elfHeader, int relocationIndex, boolean withAddend) throws IOException {
 		Class<? extends ElfRelocation> elfRelocationClazz = getElfRelocationClass(elfHeader);
 		ElfRelocation elfRelocation = getInstance(elfRelocationClazz);
@@ -118,7 +118,7 @@ public class ElfRelocation implements ByteArrayConverter, StructConverter {
 	 * @return ELF relocation object
 	 * @throws IOException if an IO or parse error occurs
 	 */
-	static ElfRelocation createElfRelocation(ElfHeader elfHeader,
+	public static ElfRelocation createElfRelocation(ElfHeader elfHeader,
 			int relocationIndex, boolean withAddend, long r_offset, long r_info, long r_addend)
 			throws IOException {
 		Class<? extends ElfRelocation> elfRelocationClazz = getElfRelocationClass(elfHeader);
@@ -376,10 +376,16 @@ public class ElfRelocation implements ByteArrayConverter, StructConverter {
 		if (is32bit) {
 			dc.putInt(bytes, 0, (int) r_offset);
 			dc.putInt(bytes, 4, (int) r_info);
+			if (hasAddend) {
+				dc.putInt(bytes, 8, (int) r_addend);
+			}
 		}
 		else {
 			dc.putLong(bytes, 0, r_offset);
 			dc.putLong(bytes, 8, r_info);
+			if (hasAddend) {
+				dc.putLong(bytes, 16, r_addend);
+			}
 		}
 		return bytes;
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocationTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocationTable.java
index c218cc628..8cd022038 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocationTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfRelocationTable.java
@@ -21,6 +21,7 @@ import java.util.List;
 
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.ByteArrayConverter;
+import ghidra.app.util.bin.StructConverter;
 import ghidra.app.util.bin.format.dwarf4.LEB128;
 import ghidra.program.model.data.ArrayDataType;
 import ghidra.program.model.data.DataType;
@@ -30,7 +31,7 @@ import ghidra.util.Msg;
 /**
  * A container class to hold ELF relocations.
  */
-public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
+public class ElfRelocationTable implements ByteArrayConverter, StructConverter {
 
 	public enum TableFormat {
 		DEFAULT, ANDROID, RELR;
@@ -42,11 +43,7 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 
 	private ElfSymbolTable symbolTable;
 
-	private ElfSectionHeader relocTableSection; // may be null
-	private long fileOffset;
-	private long addrOffset;
-	private long length;
-	private long entrySize;
+	private ElfFileSection fileSection;
 
 	private boolean addendTypeReloc;
 
@@ -56,29 +53,19 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 
 	/**
 	 * Construct an Elf Relocation Table
-	 * @param reader byte provider reader
 	 * @param header elf header
-	 * @param relocTableSection relocation table section header or null if associated with a dynamic table entry
-	 * @param fileOffset relocation table file offset
-	 * @param addrOffset memory address of relocation table (should already be adjusted for prelink)
-	 * @param length length of relocation table in bytes
-	 * @param entrySize size of each relocation entry in bytes
+	 * @param fileSection relocation table section header or null if associated with a dynamic table entry
 	 * @param addendTypeReloc true if addend type relocation table
 	 * @param symbolTable associated symbol table (may be null if not applicable)
 	 * @param sectionToBeRelocated or null for dynamic relocation table
 	 * @param format table format
 	 * @throws IOException if an IO or parse error occurs
 	 */
-	public ElfRelocationTable(BinaryReader reader, ElfHeader header,
-			ElfSectionHeader relocTableSection, long fileOffset, long addrOffset, long length,
-			long entrySize, boolean addendTypeReloc, ElfSymbolTable symbolTable,
+	public ElfRelocationTable(ElfHeader header, ElfFileSection fileSection,
+			boolean addendTypeReloc, ElfSymbolTable symbolTable,
 			ElfSectionHeader sectionToBeRelocated, TableFormat format) throws IOException {
 
-		this.relocTableSection = relocTableSection;
-		this.fileOffset = fileOffset;
-		this.addrOffset = addrOffset;
-		this.length = length;
-		this.entrySize = entrySize;
+		this.fileSection = fileSection;
 		this.addendTypeReloc = addendTypeReloc;
 		this.elfHeader = header;
 		this.format = format;
@@ -86,8 +73,7 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 		this.sectionToBeRelocated = sectionToBeRelocated;
 		this.symbolTable = symbolTable;
 
-		long ptr = reader.getPointerIndex();
-		reader.setPointerIndex(fileOffset);
+		BinaryReader reader = fileSection.getReader();
 
 		List<ElfRelocation> relocList;
 		if (format == TableFormat.RELR) {
@@ -100,8 +86,6 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 			relocList = parseStandardRelocations(reader);
 		}
 
-		reader.setPointerIndex(ptr);
-
 		relocs = new ElfRelocation[relocList.size()];
 		relocList.toArray(relocs);
 	}
@@ -112,23 +96,24 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 	 */
 	public boolean isMissingRequiredSymbolTable() {
 		if (symbolTable == null) {
-			// relocTableSection is may only be null for dynamic relocation table which must
+			// fileSection is may only be null for dynamic relocation table which must
 			// have a symbol table.  All other section-based relocation tables require a symbol
 			// table if link != 0.  NOTE: There is the possibility that a symbol table is required
 			// when link==0 which may result in relocation processing errors if it is missing.
-			return relocTableSection == null || relocTableSection.getLink() != 0;
+			return !(fileSection instanceof ElfSectionHeader) || ((ElfSectionHeader) fileSection).getLink() != 0;
 		}
 		return false;
 	}
 
 	private List<ElfRelocation> parseStandardRelocations(BinaryReader reader)
 			throws IOException {
+		long entrySize = fileSection.getEntrySize();
 
 		List<ElfRelocation> relocations = new ArrayList<>();
 		if (entrySize <= 0) {
 			entrySize = ElfRelocation.getStandardRelocationEntrySize(elfHeader.is64Bit(), addendTypeReloc);
 		}
-		int nRelocs = (int) (length / entrySize);
+		int nRelocs = (int) (fileSection.getMemorySize() / entrySize);
 		for (int relocationIndex = 0; relocationIndex < nRelocs; ++relocationIndex) {
 			relocations.add(ElfRelocation.createElfRelocation(reader, elfHeader, relocationIndex,
 				addendTypeReloc));
@@ -137,17 +122,18 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 	}
 
 	private long readNextRelrEntry(BinaryReader reader) throws IOException {
-		return entrySize == 8 ? reader.readNextLong() : reader.readNextUnsignedInt();
+		return fileSection.getEntrySize() == 8 ? reader.readNextLong() : reader.readNextUnsignedInt();
 	}
 
 	private long addRelrEntry(long offset, List<ElfRelocation> relocList) throws IOException {
 		relocList.add(ElfRelocation.createElfRelocation(elfHeader, relocList.size(),
 			addendTypeReloc, offset, 0, 0));
-		return offset + entrySize;
+		return offset + fileSection.getEntrySize();
 	}
 
 	private long addRelrEntries(long baseOffset, long entry, List<ElfRelocation> relocList)
 			throws IOException {
+		long entrySize = fileSection.getEntrySize();
 		long offset = baseOffset;
 		while (entry != 0) {
 			entry >>>= 1;
@@ -163,12 +149,13 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 
 	private List<ElfRelocation> parseRelrRelocations(BinaryReader reader)
 			throws IOException {
+		long entrySize = fileSection.getEntrySize();
 
 		// NOTE: Current implementation supports an entrySize of 8 or 4.  This could be 
 		// made more flexable if needed (applies to ElfRelrRelocationTableDataType as well)
 
 		List<ElfRelocation> relocList = new ArrayList<>();
-		long remaining = length; // limit to number of bytes specified for RELR table
+		long remaining = fileSection.getMemorySize(); // limit to number of bytes specified for RELR table
 
 		long offset = readNextRelrEntry(reader);
 		offset = addRelrEntry(offset, relocList);
@@ -266,6 +253,13 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 		return relocations;
 	}
 
+	public void addRelocation(ElfRelocation relocation) {
+		ElfRelocation[] tmp = new ElfRelocation[relocs.length + 1];
+		System.arraycopy(relocs, 0, tmp, 0, relocs.length);
+		tmp[tmp.length - 1] = relocation;
+		relocs = tmp;
+	}
+
 	/**
 	 * @return true if has addend relocations, otherwise addend extraction from
 	 * relocation target may be required
@@ -323,43 +317,25 @@ public class ElfRelocationTable implements ElfFileSection, ByteArrayConverter {
 		return bytes;
 	}
 
-	@Override
-	public long getLength() {
-		return length;
-	}
-
-	@Override
-	public long getAddressOffset() {
-		return addrOffset;
-	}
-
 	/**
-	 * Get section header which corresponds to this table, or null
-	 * if only associated with a dynamic table entry
-	 * @return relocation table section header or null
+	 * Get file section which corresponds to this table
+	 * @return relocation table file section
 	 */
-	public ElfSectionHeader getTableSectionHeader() {
-		return relocTableSection;
+	public ElfFileSection getFileSection() {
+		return fileSection;
 	}
 
 	public boolean isRelrTable() {
 		return format == TableFormat.RELR;
 	}
 
-	@Override
-	public long getFileOffset() {
-		return fileOffset;
-	}
-
-	@Override
-	public int getEntrySize() {
-		return (int) entrySize;
-	}
-
 	@Override
 	public DataType toDataType() throws IOException {
+		long length = fileSection.getMemorySize();
+		long entrySize = fileSection.getEntrySize();
+
 		if (format == TableFormat.RELR) {
-			String relrStructureName = "Elf_RelrRelocationTable_" + Long.toHexString(addrOffset);
+			String relrStructureName = "Elf_RelrRelocationTable_" + Long.toHexString(fileSection.getVirtualAddress());
 			return new ElfRelrRelocationTableDataType(relrStructureName, (int) length,
 				(int) entrySize);
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeader.java
index 1c92949ca..df3b2da90 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSectionHeader.java
@@ -20,8 +20,11 @@ import java.util.HashMap;
 import java.io.*;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteArrayProvider;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.ByteProviderWrapper;
 import ghidra.app.util.bin.StructConverter;
-import ghidra.app.util.bin.format.MemoryLoadable;
+import ghidra.app.util.bin.UnlimitedByteProviderWrapper;
 import ghidra.app.util.bin.format.Writeable;
 import ghidra.program.model.data.*;
 import ghidra.program.model.mem.MemoryAccessException;
@@ -70,18 +73,18 @@ import ghidra.util.StringUtilities;
  * </pre>
  */
 
-public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoadable {
+public class ElfSectionHeader implements ElfFileSection, StructConverter, Writeable {
 
-	private int sh_name;
-	private int sh_type;
-	private long sh_flags;
-	private long sh_addr;
-	private long sh_offset;
-	private long sh_size;
-	private int sh_link;
-	private int sh_info;
-	private long sh_addralign;
-	private long sh_entsize;
+	int sh_name;
+	int sh_type;
+	long sh_flags;
+	long sh_addr;
+	long sh_offset;
+	long sh_size;
+	int sh_link;
+	int sh_info;
+	long sh_addralign;
+	long sh_entsize;
 
 	private BinaryReader reader;
 
@@ -93,7 +96,6 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 
 	public ElfSectionHeader(BinaryReader reader, ElfHeader header)
 			throws IOException {
-		this.reader = reader;
 		this.header = header;
 
 		sh_name = reader.readNextInt();
@@ -124,6 +126,18 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 			sh_entsize = reader.readNextLong();
 		}
 		//checkSize();
+
+		ByteProvider provider;
+		if (sh_type == ElfSectionHeaderConstants.SHT_NULL) {
+			provider = ByteProvider.EMPTY_BYTEPROVIDER;
+		}
+		else if (sh_type == ElfSectionHeaderConstants.SHT_NOBITS || isInvalidOffset()) {
+			provider = new ByteArrayProvider(new byte[(int) sh_size]);
+		}
+		else {
+			provider = new UnlimitedByteProviderWrapper(reader.getByteProvider(), sh_offset, sh_size);
+		}
+		this.reader = new BinaryReader(provider, reader.isLittleEndian());
 	}
 
 	ElfSectionHeader(ElfHeader header, MemoryBlock block, int sh_name, long imageBase)
@@ -176,6 +190,20 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 		sh_offset = -1;
 	}
 
+	ElfSectionHeader(ElfHeader header, String name, int type, long flags, int link, int info,
+			long addressAlignment, long entrySize, ByteProvider data) {
+		this.sh_type = type;
+		this.sh_flags = flags;
+		this.sh_link = link;
+		this.sh_info = info;
+		this.sh_addralign = addressAlignment;
+		this.sh_entsize = entrySize;
+
+		this.header = header;
+		this.name = name;
+		this.reader = new BinaryReader(data, header.isLittleEndian());
+	}
+
 	/**
 	 * Return ElfHeader associated with this section
 	 * @return ElfHeader
@@ -224,7 +252,7 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 	 * should reside. Otherwise, the member contains 0.
 	 * @return the address of the section in memory
 	 */
-	public long getAddress() {
+	public long getVirtualAddress() {
 		return header.adjustAddressForPrelink(sh_addr);
 	}
 
@@ -246,6 +274,7 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 	 * section does not hold a table of fixed-size entries.
 	 * @return the section entry size
 	 */
+	@Override
 	public long getEntrySize() {
 		return sh_entsize;
 	}
@@ -329,10 +358,6 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 	}
 
 	void updateName() {
-		if (reader == null) {
-			throw new UnsupportedOperationException("This ElfSectionHeader does not have a reader");
-		}
-
 		ElfSectionHeader[] sections = header.getSections();
 		int e_shstrndx = header.e_shstrndx();
 		name = null;
@@ -340,10 +365,9 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 			if (sh_name >= 0 && e_shstrndx > 0 && e_shstrndx < sections.length) {
 				// read section name from string table
 				if (!sections[e_shstrndx].isInvalidOffset()) {
-					long stringTableOffset = sections[e_shstrndx].getOffset();
-					long offset = stringTableOffset + sh_name;
-					if (offset < reader.length()) {
-						name = reader.readAsciiString(stringTableOffset + sh_name);
+					BinaryReader reader = sections[e_shstrndx].getReader();
+					if (sh_name < reader.length()) {
+						name = reader.readAsciiString(sh_name);
 						if ("".equals(name)) {
 							name = null;
 						}
@@ -393,7 +417,7 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 	 * file.
 	 * @return byte offset from the beginning of the file to the first byte in the section
 	 */
-	public long getOffset() {
+	public long getFileOffset() {
 		return sh_offset;
 	}
 
@@ -422,7 +446,7 @@ public class ElfSectionHeader implements StructConverter, Writeable, MemoryLoada
 	 * SHT_NOBITS may have a non-zero size, but it occupies no space in the file.
 	 * @return the section's size in bytes
 	 */
-	public long getSize() {
+	public long getFileSize() {
 		return sh_size;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfStringTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfStringTable.java
index 5607f822e..bcf238703 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfStringTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfStringTable.java
@@ -16,88 +16,77 @@
 package ghidra.app.util.bin.format.elf;
 
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 
 import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.MutableByteProvider;
+import ghidra.app.util.bin.StructConverter;
 import ghidra.program.model.data.DataType;
 import ghidra.util.exception.DuplicateNameException;
 
-public class ElfStringTable implements ElfFileSection {
+public class ElfStringTable implements StructConverter {
 
 	private ElfHeader header;
 
-	private ElfSectionHeader stringTableSection; // may be null
-	private long fileOffset;
-	private long addrOffset;
-	private long length;
+	private ElfFileSection fileSection;
+	private BinaryReader reader;
 
 	/**
 	 * Construct and parse an Elf string table
 	 * @param header elf header
-	 * @param stringTableSection string table section header or null if associated with a dynamic table entry
-	 * @param fileOffset symbol table file offset
-	 * @param addrOffset memory address of symbol table (should already be adjusted for prelink)
-	 * @param length length of symbol table in bytes of -1 if unknown
+	 * @param fileSection string table file section
 	 */
-	public ElfStringTable(ElfHeader header, ElfSectionHeader stringTableSection, long fileOffset,
-			long addrOffset, long length) {
+	public ElfStringTable(ElfHeader header, ElfFileSection fileSection) {
 		this.header = header;
-		this.stringTableSection = stringTableSection;
-		this.fileOffset = fileOffset;
-		this.addrOffset = addrOffset;
-		this.length = length;
+		this.fileSection = fileSection;
+		this.reader = fileSection.getReader();
 	}
 
 	/**
 	 * Read string from table at specified relative table offset
-	 * @param reader byte reader
 	 * @param stringOffset table relative string offset
 	 * @return string or null on error
 	 */
-	public String readString(BinaryReader reader, long stringOffset) {
-		if (fileOffset < 0) {
-			return null;
-		}
+	public String readString(long stringOffset) {
 		try {
-			if (stringOffset >= length) {
+			if (stringOffset >= fileSection.getMemorySize()) {
 				throw new IOException("String read beyond table bounds");
 			}
-			return reader.readUtf8String(fileOffset + stringOffset).trim();
+			return reader.readUtf8String(stringOffset).trim();
 		}
 		catch (IOException e) {
 			header.logError(
 				"Failed to read Elf String at offset 0x" + Long.toHexString(stringOffset) +
-					" within String Table at offset 0x" + Long.toHexString(fileOffset));
+					" within String Table at offset 0x" + Long.toHexString(fileSection.getFileOffset()));
 		}
 		return null;
 	}
 
-	@Override
-	public long getAddressOffset() {
-		return header.adjustAddressForPrelink(addrOffset);
-	}
-
 	/**
-	 * Get section header which corresponds to this table, or null
-	 * if only associated with a dynamic table entry
-	 * @return string table section header or null
+	 * Append a string at the end of the string table
+	 * @param str String to append
+	 * @return index of string
 	 */
-	public ElfSectionHeader getTableSectionHeader() {
-		return stringTableSection;
-	}
+	public int add(String str) throws IOException {
+		ByteProvider byteProvider = reader.getByteProvider();
+		if (!(byteProvider instanceof MutableByteProvider)) {
+			throw new IOException("Backing byte provider isn't mutable");
+		}
 
-	@Override
-	public long getFileOffset() {
-		return fileOffset;
-	}
+		MutableByteProvider mutableByteProvider = (MutableByteProvider) byteProvider;
+		int strIndex = (int) mutableByteProvider.length();
+		mutableByteProvider.writeBytes(strIndex, StandardCharsets.UTF_8.encode(str + '\0').array());
 
-	@Override
-	public long getLength() {
-		return length;
+		return strIndex;
 	}
 
-	@Override
-	public int getEntrySize() {
-		return -1;
+	/**
+	 * Get file section which corresponds to this table
+	 * @return string table section section
+	 */
+	public ElfFileSection getFileSection() {
+		return fileSection;
 	}
 
 	@Override
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java
index c24165670..fa6703eb8 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbol.java
@@ -148,6 +148,48 @@ public class ElfSymbol implements ByteArrayConverter {
 		return new ElfSymbol(header, "", 0, 0, 0, (byte) 0, (byte) 0, (short) 0, 0, null);
 	}
 
+	/**
+	 * Creates a new defined symbol, related to a section.
+	 * @param header the corresponding ELF header
+	 * @param symbolTable the symbol table
+	 * @param nameAsString name of the symbol
+	 * @param name index of the symbol's name in the string table
+	 * @param value value of this symbol
+	 * @param size size of this symbol
+	 * @param type type of this symbol
+	 * @param binding binding for this symbol
+	 * @param visibility visibility for this symbol
+	 * @param sectionHeaderIndex index of the section header that contains this symbol
+	 * @param symbolIndex index of this symbol in the symbol table
+	 * @return created symbol
+	 */
+	public static ElfSymbol createDefinedSymbol(ElfHeader header, ElfSymbolTable symbolTable,
+			String nameAsString, int name, long value, long size, byte type, byte binding,
+			byte visibility, short sectionHeaderIndex, int symbolIndex) {
+		byte info = (byte) (type | (binding << 4));
+		byte other = visibility;
+
+		return new ElfSymbol(header, nameAsString, name, value, size, info, other,
+			sectionHeaderIndex, symbolIndex, symbolTable);
+	}
+
+	/**
+	 * Creates a new undefined symbol
+	 * @param header the corresponding ELF header
+	 * @param symbolTable the symbol table
+	 * @param nameAsString name of the symbol
+	 * @param name index of the symbol's name in the string table
+	 * @param symbolIndex index of this symbol in the symbol table
+	 * @return created symbol
+	 */
+	public static ElfSymbol createUndefinedSymbol(ElfHeader header, ElfSymbolTable symbolTable,
+			String nameAsString, int name, int symbolIndex) {
+		byte info = (byte) (STT_NOTYPE | (STB_GLOBAL << 4));
+
+		return new ElfSymbol(header, nameAsString, name, 0, 0, info, STV_DEFAULT, (short) 0,
+			symbolIndex, symbolTable);
+	}
+
 	private ElfSymbol(ElfHeader header, String nameAsString, int name, long value, long size,
 			byte info, byte other, short sectionHeaderIndex, int symbolIndex,
 			ElfSymbolTable symbolTable) {
@@ -232,7 +274,7 @@ public class ElfSymbol implements ByteArrayConverter {
 	 */
 	public void initSymbolName(BinaryReader reader, ElfStringTable stringTable) {
 		if (nameAsString == null && stringTable != null) {
-			nameAsString = stringTable.readString(reader, st_name);
+			nameAsString = stringTable.readString(st_name);
 		}
 	}
 
@@ -557,36 +599,46 @@ public class ElfSymbol implements ByteArrayConverter {
 	 */
 	@Override
 	public byte[] toBytes(DataConverter dc) {
-		// FIXME! BUG!! Symbols can exist without a dynamic table !!
-		ElfDynamicTable dynamic = header.getDynamicTable();
-		int syment = 0;
+		int syment = header.is32Bit() ? 16 : 24;
 		try {
-			syment = (int) dynamic.getDynamicValue(ElfDynamicType.DT_SYMENT);
+			ElfDynamicTable dynamic = header.getDynamicTable();
+			if (dynamic != null) {
+				syment = (int) dynamic.getDynamicValue(ElfDynamicType.DT_SYMENT);
+			}
 		}
-		catch (NotFoundException e) {
+		catch (Exception e) {
 			throw new RuntimeException(e);//should never happen!
 		}
 		byte[] bytes = new byte[syment];
 		int index = 0;
-		dc.putInt(bytes, 0, st_name);
-		index += 4;
 		if (header.is32Bit()) {
+			dc.putInt(bytes, 0, st_name);
+			index += 4;
 			dc.putInt(bytes, index, (int) st_value);
 			index += 4;
 			dc.putInt(bytes, index, (int) st_size);
 			index += 4;
+			bytes[index] = st_info;
+			index += 1;
+			bytes[index] = st_other;
+			index += 1;
+			dc.putShort(bytes, index, st_shndx);
+			index += 2;
 		}
 		else {
+			dc.putInt(bytes, 0, st_name);
+			index += 4;
+			bytes[index] = st_info;
+			index += 1;
+			bytes[index] = st_other;
+			index += 1;
+			dc.putShort(bytes, index, st_shndx);
+			index += 2;
 			dc.putLong(bytes, index, st_value);
 			index += 8;
 			dc.putLong(bytes, index, st_size);
 			index += 8;
 		}
-		bytes[index] = st_info;
-		index += 1;
-		bytes[index] = st_other;
-		index += 1;
-		dc.putShort(bytes, index, st_shndx);
 		return bytes;
 	}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbolTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbolTable.java
index 38c591cba..f667b5787 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbolTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/ElfSymbolTable.java
@@ -22,6 +22,7 @@ import java.util.stream.Collectors;
 
 import ghidra.app.util.bin.BinaryReader;
 import ghidra.app.util.bin.ByteArrayConverter;
+import ghidra.app.util.bin.StructConverter;
 import ghidra.program.model.data.*;
 import ghidra.util.DataConverter;
 import ghidra.util.exception.DuplicateNameException;
@@ -29,15 +30,11 @@ import ghidra.util.exception.DuplicateNameException;
 /**
  * A container class to hold ELF symbols.
  */
-public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
+public class ElfSymbolTable implements ByteArrayConverter, StructConverter {
 
 	private ElfStringTable stringTable;
-	private ElfSectionHeader symbolTableSection; // may be null
+	private ElfFileSection fileSection;
 	private int[] symbolSectionIndexTable;
-	private long fileOffset;
-	private long addrOffset;
-	private long length;
-	private long entrySize;
 	private int symbolCount;
 
 	private boolean is32bit;
@@ -47,13 +44,8 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 
 	/**
 	 * Construct and parse an Elf symbol table
-	 * @param reader byte reader
 	 * @param header elf header
-	 * @param symbolTableSection string table section header or null if associated with a dynamic table entry
-	 * @param fileOffset symbol table file offset
-	 * @param addrOffset memory address of symbol table (should already be adjusted for prelink)
-	 * @param length length of symbol table in bytes of -1 if unknown
-	 * @param entrySize size of each symbol entry in bytes
+	 * @param fileSection symbol table file section
 	 * @param stringTable associated string table
 	 * @param symbolSectionIndexTable extended symbol section index table (may be null, used when 
 	 *           symbol <code>st_shndx == SHN_XINDEX</code>).  See 
@@ -61,26 +53,21 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 	 * @param isDynamic true if symbol table is the dynamic symbol table
 	 * @throws IOException if an IO or parse error occurs
 	 */
-	public ElfSymbolTable(BinaryReader reader, ElfHeader header,
-			ElfSectionHeader symbolTableSection, long fileOffset, long addrOffset, long length,
-			long entrySize, ElfStringTable stringTable, int[] symbolSectionIndexTable,
+	public ElfSymbolTable(ElfHeader header, ElfFileSection fileSection,
+			ElfStringTable stringTable, int[] symbolSectionIndexTable,
 			boolean isDynamic) throws IOException {
 
-		this.symbolTableSection = symbolTableSection;
-		this.fileOffset = fileOffset;
-		this.addrOffset = addrOffset;
-		this.length = length;
-		this.entrySize = entrySize;
+		this.fileSection = fileSection;
 		this.stringTable = stringTable;
 		this.is32bit = header.is32Bit();
 		this.symbolSectionIndexTable = symbolSectionIndexTable;
 		this.isDynamic = isDynamic;
 
-		long ptr = reader.getPointerIndex();
-		reader.setPointerIndex(fileOffset);
+		BinaryReader reader = fileSection.getReader();
+		long entrySize = fileSection.getEntrySize();
 
 		List<ElfSymbol> symbolList = new ArrayList<>();
-		symbolCount = (int) (length / entrySize);
+		symbolCount = (int) (fileSection.getMemorySize() / entrySize);
 
 		long entryPos = reader.getPointerIndex();
 
@@ -104,8 +91,6 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 			sym.initSymbolName(reader, stringTable);
 		}
 
-		reader.setPointerIndex(ptr);
-
 		symbols = new ElfSymbol[symbolList.size()];
 		symbolList.toArray(symbols);
 	}
@@ -293,33 +278,12 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 		return bytes;
 	}
 
-	@Override
-	public long getLength() {
-		return length;
-	}
-
-	@Override
-	public long getAddressOffset() {
-		return addrOffset;
-	}
-
 	/**
-	 * Get the section header which corresponds to this table, or null
-	 * if only associated with a dynamic table entry
-	 * @return symbol table section header or null
+	 * Get the file section which corresponds to this table
+	 * @return symbol table file section
 	 */
-	public ElfSectionHeader getTableSectionHeader() {
-		return symbolTableSection;
-	}
-
-	@Override
-	public long getFileOffset() {
-		return fileOffset;
-	}
-
-	@Override
-	public int getEntrySize() {
-		return (int) entrySize;
+	public ElfFileSection getFileSection() {
+		return fileSection;
 	}
 
 // Comments are repetitive - should refer to Elf documentation 
@@ -332,6 +296,8 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 
 	@Override
 	public DataType toDataType() throws DuplicateNameException {
+		long entrySize = fileSection.getEntrySize();
+
 		String dtName = is32bit ? "Elf32_Sym" : "Elf64_Sym";
 		Structure struct = new StructureDataType(new CategoryPath("/ELF"), dtName, 0);
 		struct.add(DWORD, "st_name", null);
@@ -349,11 +315,11 @@ public class ElfSymbolTable implements ElfFileSection, ByteArrayConverter {
 			struct.add(QWORD, "st_value", null);
 			struct.add(QWORD, "st_size", null);
 		}
-		int sizeRemaining = getEntrySize() - struct.getLength();
+		int sizeRemaining = (int) entrySize - struct.getLength();
 		if (sizeRemaining > 0) {
 			struct.add(new ArrayDataType(ByteDataType.dataType, sizeRemaining, 1), "st_unknown",
 				null);
 		}
-		return new ArrayDataType(struct, (int) (length / entrySize), (int) entrySize);
+		return new ArrayDataType(struct, (int) (fileSection.getMemorySize() / entrySize), (int) entrySize);
 	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/extend/ElfLoadAdapter.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/extend/ElfLoadAdapter.java
index 3cce2bcd0..8aa819aef 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/extend/ElfLoadAdapter.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/elf/extend/ElfLoadAdapter.java
@@ -216,7 +216,7 @@ public class ElfLoadAdapter {
 
 		AddressSpace space = getPreferredSectionAddressSpace(elfLoadHelper, elfSectionHeader);
 
-		long addrWordOffset = elfSectionHeader.getAddress();
+		long addrWordOffset = elfSectionHeader.getVirtualAddress();
 
 		if (space == program.getAddressFactory().getDefaultAddressSpace()) {
 			addrWordOffset += elfLoadHelper.getImageBaseWordAdjustmentOffset();
@@ -469,7 +469,7 @@ public class ElfLoadAdapter {
 	 * @return preferred memory block size in bytes which corresponds to the specified section header
 	 */
 	public long getAdjustedSize(ElfSectionHeader section) {
-		return section.getSize();
+		return section.getFileSize();
 	}
 
 	/**
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfDataType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfDataType.java
index 700444eff..5a8678161 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfDataType.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfDataType.java
@@ -56,7 +56,6 @@ public class ElfDataType extends FactoryStructureDataType {
 	        ByteArrayProvider bap = new ByteArrayProvider(bytes);
 
 			ElfHeader elf = new ElfHeader(bap, null);
-			elf.parse();
 
 	        struct.add(elf.toDataType());
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoader.java
index 8b042c5de..123f37f02 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoader.java
@@ -143,8 +143,7 @@ public class ElfLoader extends AbstractLibrarySupportLoader {
 			throws IOException, CancelledException {
 
 		try {
-			ElfHeader elf = new ElfHeader(provider, msg -> log.appendMsg(msg));
-			ElfProgramBuilder.loadElf(elf, program, options, log, monitor);
+			ElfProgramBuilder.loadElf(provider, program, options, log, monitor);
 		}
 		catch (ElfException e) {
 			throw new IOException(e.getMessage());
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java
index 7fee5a24c..01f75d405 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfLoaderOptionsFactory.java
@@ -15,6 +15,7 @@
  */
 package ghidra.app.util.opinion;
 
+import java.io.IOException;
 import java.util.List;
 
 import ghidra.app.util.Option;
@@ -51,7 +52,7 @@ public class ElfLoaderOptionsFactory {
 	}
 
 	static void addOptions(List<Option> options, ByteProvider provider, LoadSpec loadSpec)
-			throws ElfException, LanguageNotFoundException {
+			throws ElfException, IOException {
 
 		// NOTE: add-to-program is not supported
 
@@ -60,7 +61,7 @@ public class ElfLoaderOptionsFactory {
 
 		ElfHeader elf = new ElfHeader(provider, null);
 
-		long imageBase = elf.findImageBase();
+		long imageBase = elf.getImageBase();
 		if (imageBase == 0 && (elf.isRelocatable() || elf.isSharedObject())) {
 			imageBase = elf.is64Bit() ? IMAGE64_BASE_DEFAULT : IMAGE_BASE_DEFAULT;
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfProgramBuilder.java
index dc5dab03f..18afbc8f3 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfProgramBuilder.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/ElfProgramBuilder.java
@@ -79,6 +79,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 	private MessageLog log;
 
 	private ElfHeader elf;
+	private ByteProvider byteProvider;
 	private FileBytes fileBytes;
 
 	private Listing listing;
@@ -86,10 +87,11 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 	private HashMap<ElfSymbol, Address> symbolMap = new HashMap<>();
 
-	protected ElfProgramBuilder(ElfHeader elf, Program program, List<Option> options,
-			MessageLog log) {
+	protected ElfProgramBuilder(ByteProvider byteProvider, Program program,
+			List<Option> options, MessageLog log) {
 		super(program);
-		this.elf = elf;
+		this.elf = null;
+		this.byteProvider = byteProvider;
 		this.options = options;
 		this.log = log;
 		memory = program.getMemory();
@@ -106,17 +108,16 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 		return elf;
 	}
 
-	static void loadElf(ElfHeader elf, Program program, List<Option> options, MessageLog log,
-			TaskMonitor monitor) throws IOException, CancelledException {
-		ElfProgramBuilder elfProgramBuilder = new ElfProgramBuilder(elf, program, options, log);
+	static void loadElf(ByteProvider byteProvider, Program program, List<Option> options,
+			MessageLog log, TaskMonitor monitor) throws IOException, CancelledException, ElfException {
+		ElfProgramBuilder elfProgramBuilder = new ElfProgramBuilder(byteProvider, program, options, log);
 		elfProgramBuilder.load(monitor);
 	}
 
-	protected void load(TaskMonitor monitor) throws IOException, CancelledException {
-
-		monitor.setMessage("Completing ELF header parsing...");
+	protected void load(TaskMonitor monitor) throws IOException, CancelledException, ElfException {
+		monitor.setMessage("Parsing ELF file...");
 		monitor.setCancelEnabled(false);
-		elf.parse();
+		elf = new ElfHeader(byteProvider, msg -> log.appendMsg(msg));
 		monitor.setCancelEnabled(true);
 
 		int id = program.startTransaction("Load ELF program");
@@ -127,8 +128,6 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			setImageBase();
 			program.setExecutableFormat(ElfLoader.ELF_NAME);
 
-			ByteProvider byteProvider = elf.getByteProvider();
-
 			createFileBytes(byteProvider, monitor);
 
 			adjustSegmentAndSectionFileAllocations(byteProvider, monitor);
@@ -233,20 +232,20 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				segment.isInvalidOffset() || size <= 0) {
 				continue;
 			}
-			long offset = segment.getOffset();
+			long offset = segment.getFileOffset();
 			fileMap.paintRange(offset, offset + size - 1, -2); // -2: used by segment
 		}
 
 		for (ElfSectionHeader section : sections) {
 			monitor.checkCanceled();
 			monitor.incrementProgress(1);
-			long size = section.getSize();
+			long size = section.getFileSize();
 			if (section.getType() == ElfSectionHeaderConstants.SHT_NULL ||
 				section.getType() == ElfSectionHeaderConstants.SHT_NOBITS ||
 				section.isInvalidOffset() || size <= 0) {
 				continue;
 			}
-			long offset = section.getOffset();
+			long offset = section.getFileOffset();
 			fileMap.paintRange(offset, offset + size - 1, -3); // -3: used by section 
 		}
 
@@ -794,12 +793,12 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 		ElfProgramHeader[] interpProgramHeaders =
 			elf.getProgramHeaders(ElfProgramHeaderConstants.PT_INTERP);
 		if (interpProgramHeaders.length != 0) {
-			long offset = interpProgramHeaders[0].getOffset();
+			long offset = interpProgramHeaders[0].getFileOffset();
 			if (offset == 0) {
 				log("ELF PT_INTERP appears to have been stripped from binary");
 				return;
 			}
-			interpStrAddr = findLoadAddress(interpProgramHeaders[0].getOffset(), 1);
+			interpStrAddr = findLoadAddress(interpProgramHeaders[0].getFileOffset(), 1);
 		}
 
 		if (interpStrAddr == null) {
@@ -882,12 +881,12 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 		Address relocTableAddr = null;
 
-		ElfSectionHeader section = relocationTable.getTableSectionHeader();
-		if (section != null) {
+		ElfFileSection section = relocationTable.getFileSection();
+		if (section instanceof ElfSectionHeader) {
 			relocTableAddr = findLoadAddress(section, 0);
 		}
 		else {
-			relocTableAddr = findLoadAddress(relocationTable.getFileOffset(), 1);
+			relocTableAddr = findLoadAddress(section.getFileOffset(), 1);
 		}
 
 		/**
@@ -910,7 +909,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			Address sectionLoadAddr = findLoadAddress(sectionToBeRelocated, 0);
 			if (sectionLoadAddr == null) {
 				log("Failed to identify relocation base address for relocation table 0x" +
-					relocationTable.getAddressOffset() + " [section: " +
+					relocationTable.getFileSection().getVirtualAddress() + " [section: " +
 					sectionToBeRelocated.getNameAsString() + "]");
 				monitor.incrementProgress(relocationTable.getRelocationCount());
 				return;
@@ -945,9 +944,10 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 		boolean unableToApplyRelocs = relocationTable.isMissingRequiredSymbolTable();
 		if (unableToApplyRelocs) {
-			ElfSectionHeader tableSectionHeader = relocationTable.getTableSectionHeader();
-			String relocTableName =
-				tableSectionHeader != null ? tableSectionHeader.getNameAsString() : "dynamic";
+			ElfFileSection tableSectionHeader = relocationTable.getFileSection();
+			String relocTableName = tableSectionHeader instanceof ElfSectionHeader
+				? ((ElfSectionHeader) tableSectionHeader).getNameAsString()
+				: "dynamic";
 			ElfSectionHeader sectionToBeRelocated = relocationTable.getSectionToBeRelocated();
 			String relocaBaseName =
 				sectionToBeRelocated != null ? sectionToBeRelocated.getNameAsString() : "PT_LOAD";
@@ -1185,7 +1185,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				if (programHeaders[i].getType() == ElfProgramHeaderConstants.PT_NULL) {
 					continue;
 				}
-				if (programHeaders[i].getOffset() == 0) {
+				if (programHeaders[i].getFileOffset() == 0) {
 					continue; // has been stripped
 				}
 				Address segmentAddr = findLoadAddress(programHeaders[i], 0);
@@ -1278,7 +1278,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			return;
 		}
 		// determine number of 32-bit index elements for DWORD[]
-		int count = (int) (section.getSize() / 4);
+		int count = (int) (section.getFileSize() / 4);
 		DataType dt = new ArrayDataType(DWordDataType.dataType, count, -1);
 		createData(sectionAddr, dt);
 	}
@@ -1521,13 +1521,13 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 			Address symbolTableAddr = null;
 
-			ElfSectionHeader symbolTableSection = elfSymbolTable.getTableSectionHeader();
-			if (symbolTableSection != null) {
-				symbolTableAddr = findLoadAddress(symbolTableSection, 0);
+			ElfFileSection section = elfSymbolTable.getFileSection();
+			if (section instanceof ElfSectionHeader) {
+				symbolTableAddr = findLoadAddress(section, 0);
 			}
 			else {
 				symbolTableAddr =
-					findLoadAddress(elfSymbolTable.getFileOffset(), elfSymbolTable.getLength());
+					findLoadAddress(section.getFileOffset(), section.getFileSize());
 			}
 
 			ElfSymbol[] symbols = elfSymbolTable.getSymbols();
@@ -1562,7 +1562,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			try {
 				File tmpFile = File.createTempFile("ghidra_gnu_debugdata", null);
 				try (ByteProviderWrapper compressedDebugDataBP = new ByteProviderWrapper(
-					new MemoryByteProvider(memory, debugDataAddr), 0, debugDataSection.getSize());
+					new MemoryByteProvider(memory, debugDataAddr), 0, debugDataSection.getMemorySize());
 						XZCompressorInputStream xzIS =
 							new XZCompressorInputStream(compressedDebugDataBP.getInputStream(0));
 						ObfuscatedOutputStream oos =
@@ -1575,7 +1575,6 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 						new ObfuscatedFileByteProvider(tmpFile, null, AccessMode.READ)) {
 
 						ElfHeader minidebugElf = new ElfHeader(debugDataBP, null);
-						minidebugElf.parse();
 
 						ElfSymbolTable[] minidebugSymbolTables = minidebugElf.getSymbolTables();
 						int debugSymbolsCount = 0;
@@ -2588,10 +2587,10 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				return;
 			}
 
-			dynamicTableAddress = findLoadAddress(dynamicTable.getFileOffset(), 1);
+			dynamicTableAddress = findLoadAddress(dynamicTable.getFileSection().getFileOffset(), 1);
 			if (dynamicTableAddress == null) {
 				log("Failed to locate dynamic table at file offset 0x" +
-					Long.toHexString(dynamicTable.getFileOffset()));
+					Long.toHexString(dynamicTable.getFileSection().getFileOffset()));
 				return;
 			}
 
@@ -2632,7 +2631,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 					else if (dynamicType.valueType == ElfDynamicValueType.STRING) {
 						ElfStringTable dynamicStringTable = elf.getDynamicStringTable();
 						if (dynamicStringTable != null) {
-							String str = dynamicStringTable.readString(elf.getReader(), value);
+							String str = dynamicStringTable.readString(value);
 							if (str != null && str.length() != 0) {
 								valueData.setComment(CodeUnit.EOL_COMMENT, str);
 							}
@@ -2687,7 +2686,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 		long totalLength = 0;
 		for (ElfStringTable stringTable : stringTables) {
-			totalLength += stringTable.getLength();
+			totalLength += stringTable.getFileSection().getMemorySize();
 		}
 		monitor.initialize(totalLength);
 
@@ -2696,27 +2695,27 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 			Address stringTableAddr = null;
 
-			ElfSectionHeader section = stringTable.getTableSectionHeader();
-			if (section != null) {
+			ElfFileSection section = stringTable.getFileSection();
+			if (section instanceof ElfSectionHeader) {
 				stringTableAddr = findLoadAddress(section, 0);
 			}
 			else {
-				stringTableAddr = findLoadAddress(stringTable.getFileOffset(), 1);
+				stringTableAddr = findLoadAddress(section.getFileOffset(), 1);
 			}
 			if (stringTableAddr == null) {
 //				log("Failed to locate string table at file offset 0x" +
 //					Long.toHexString(stringTable.getFileOffset()));
-				monitor.incrementProgress(stringTable.getLength()); // skipping table
+				monitor.incrementProgress(section.getMemorySize()); // skipping table
 				continue;
 			}
 
 			AddressRange rangeConstraint = getMarkupMemoryRangeConstraint(stringTableAddr);
 			if (rangeConstraint == null) {
-				monitor.incrementProgress(stringTable.getLength()); // skipping table
+				monitor.incrementProgress(section.getMemorySize()); // skipping table
 				continue;
 			}
 
-			long tblLength = stringTable.getLength();
+			long tblLength = section.getMemorySize();
 			long limit = Math.min(tblLength, rangeConstraint.getLength());
 			if (limit < tblLength) {
 				monitor.incrementProgress(tblLength - limit);
@@ -2839,7 +2838,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 		AddressSpace space = getSectionAddressSpace(elfSectionHeader);
 		if (!space.isLoadedMemorySpace()) {
 			// handle non-loaded sections into the OTHER space
-			long addrWordOffset = elfSectionHeader.getAddress();
+			long addrWordOffset = elfSectionHeader.getVirtualAddress();
 			return space.getTruncatedAddress(addrWordOffset, true);
 		}
 
@@ -2877,7 +2876,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				// PT_LOAD segment must have been superseded by section load
 				ElfSectionHeader sectionHeader = elf.getSectionLoadHeaderContaining(offsetAddr);
 				if (sectionHeader != null) {
-					return findLoadAddress(sectionHeader, offsetAddr - sectionHeader.getAddress());
+					return findLoadAddress(sectionHeader, offsetAddr - sectionHeader.getVirtualAddress());
 				}
 			}
 			else if (section instanceof ElfSectionHeader) {
@@ -2935,10 +2934,10 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				section.isInvalidOffset()) {
 				continue;
 			}
-			long startOffset = section.getOffset();
-			long endOffset = startOffset + section.getSize() - 1;
+			long startOffset = section.getFileOffset();
+			long endOffset = startOffset + section.getFileSize() - 1;
 			if (fileOffset >= startOffset && headerEndOffset <= endOffset) {
-				headerAddr = findLoadAddress(section, fileOffset - section.getOffset());
+				headerAddr = findLoadAddress(section, fileOffset - section.getFileOffset());
 				if (headerAddr != null) {
 					return headerAddr;
 				}
@@ -2951,10 +2950,10 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 				segment.isInvalidOffset()) {
 				continue;
 			}
-			long startOffset = segment.getOffset();
+			long startOffset = segment.getFileOffset();
 			long endOffset = startOffset + segment.getFileSize() - 1;
 			if (fileOffset >= startOffset && headerEndOffset <= endOffset) {
-				headerAddr = findLoadAddress(segment, fileOffset - segment.getOffset());
+				headerAddr = findLoadAddress(segment, fileOffset - segment.getFileOffset());
 				if (headerAddr != null && segment.getType() == ElfProgramHeaderConstants.PT_LOAD) {
 					return headerAddr;
 				}
@@ -3104,7 +3103,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			if (elfProgramHeader.getType() == ElfProgramHeaderConstants.PT_NULL) {
 				continue;
 			}
-			long fileOffset = elfProgramHeader.getOffset();
+			long fileOffset = elfProgramHeader.getFileOffset();
 			if (elfProgramHeader.getType() != ElfProgramHeaderConstants.PT_LOAD) {
 				if (!includeOtherBlocks) {
 					continue;
@@ -3189,7 +3188,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 
 			String blockName = getSegmentName(elfProgramHeader, segmentNumber);
 			if (loadSizeBytes != 0) {
-				addInitializedMemorySection(elfProgramHeader, elfProgramHeader.getOffset(),
+				addInitializedMemorySection(elfProgramHeader, elfProgramHeader.getFileOffset(),
 					loadSizeBytes, address, blockName, elfProgramHeader.isRead(),
 					elfProgramHeader.isWrite(),
 					maintainExecuteBit ? elfProgramHeader.isExecute() : false, comment,
@@ -3284,7 +3283,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 		ElfSectionHeader[] sections = elf.getSections();
 		for (ElfSectionHeader elfSectionToLoad : sections) {
 			monitor.checkCanceled();
-			long addr = elfSectionToLoad.getAddress();
+			long addr = elfSectionToLoad.getVirtualAddress();
 			if (addr < 0) {
 				relocStartAddr = 0;
 				break;
@@ -3328,14 +3327,14 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			int type = elfSectionToLoad.getType();
 			if (type != ElfSectionHeaderConstants.SHT_NULL &&
 				(includeOtherBlocks || elfSectionToLoad.isAlloc())) {
-				long fileOffset = elfSectionToLoad.getOffset();
+				long fileOffset = elfSectionToLoad.getFileOffset();
 				if (type != ElfSectionHeaderConstants.SHT_NOBITS &&
 					(elfSectionToLoad.isInvalidOffset() || fileOffset >= fileBytes.getSize())) {
 					log("Skipping section [" + elfSectionToLoad.getNameAsString() +
 						"] with invalid file offset 0x" + Long.toHexString(fileOffset));
 					continue;
 				}
-				long size = elfSectionToLoad.getSize();
+				long size = elfSectionToLoad.getFileSize();
 				if (size <= 0 ||
 					(type != ElfSectionHeaderConstants.SHT_NOBITS && size >= fileBytes.getSize())) {
 					log("Skipping section [" + elfSectionToLoad.getNameAsString() +
@@ -3358,9 +3357,9 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 			RelocatableImageBaseProvider relocatableImageBaseProvider)
 			throws AddressOutOfBoundsException {
 
-		long addr = elfSectionToLoad.getAddress();
+		long addr = elfSectionToLoad.getVirtualAddress();
 		long sectionByteLength = elfSectionToLoad.getAdjustedSize(); // size in bytes
-		long loadOffset = elfSectionToLoad.getOffset(); // file offset in bytes
+		long loadOffset = elfSectionToLoad.getFileOffset(); // file offset in bytes
 		Long nextRelocOffset = null;
 
 		// In a relocatable ELF (object module), the address of all sections is zero.
@@ -3540,7 +3539,7 @@ class ElfProgramBuilder extends MemorySectionResolver implements ElfLoadHelper {
 	 */
 	private InputStream getInitializedBlockInputStream(MemoryLoadable loadable, Address start,
 			long fileOffset, long dataLength) throws IOException {
-		InputStream dataInput = elf.getByteProvider().getInputStream(fileOffset);
+		InputStream dataInput = byteProvider.getInputStream(fileOffset);
 		return elf.getLoadAdapter()
 				.getFilteredLoadInputStream(this, loadable, start, dataLength, dataInput);
 	}
diff --git a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/android/oat/OatFileSystem.java b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/android/oat/OatFileSystem.java
index c9251e7c0..442c240a1 100644
--- a/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/android/oat/OatFileSystem.java
+++ b/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/android/oat/OatFileSystem.java
@@ -55,7 +55,6 @@ public class OatFileSystem extends GFileSystemBase {
 
 			if (magicMatch) {
 				ElfHeader elf = new ElfHeader(provider, null);
-				elf.parse();
 
 				ElfSymbolTable dynamicSymbolTable = elf.getDynamicSymbolTable();
 				if (dynamicSymbolTable != null) {
@@ -97,18 +96,17 @@ public class OatFileSystem extends GFileSystemBase {
 			monitor.setMessage("Parsing ELF header...");
 			monitor.incrementProgress(1);
 			ElfHeader elf = new ElfHeader(provider, null);
-			elf.parse();
 			monitor.incrementProgress(1);
 
 			ElfSectionHeader roDataSection = elf.getSection(ElfSectionHeaderConstants.dot_rodata);
 			if (roDataSection == null) {
 				throw new IOException("rodata section does not exist.");
 			}
-			baseOffset = roDataSection.getOffset();
+			baseOffset = roDataSection.getFileOffset();
 
 			monitor.setMessage("Parsing OAT header...");
 			ByteProviderWrapper wrapper =
-				new ByteProviderWrapper(provider, baseOffset, roDataSection.getSize());
+				new ByteProviderWrapper(provider, baseOffset, roDataSection.getFileSize());
 			BinaryReader reader = new BinaryReader(wrapper, elf.isLittleEndian());
 			OatHeader oatHeader = OatHeaderFactory.newOatHeader(reader);
 			OatHeaderFactory.parseOatHeader(oatHeader, null, reader, monitor, new MessageLog());
diff --git a/Ghidra/Processors/ARM/src/main/java/ghidra/app/util/bin/format/elf/extend/ARM_ElfExtension.java b/Ghidra/Processors/ARM/src/main/java/ghidra/app/util/bin/format/elf/extend/ARM_ElfExtension.java
index 40c77e68e..b7136b12d 100644
--- a/Ghidra/Processors/ARM/src/main/java/ghidra/app/util/bin/format/elf/extend/ARM_ElfExtension.java
+++ b/Ghidra/Processors/ARM/src/main/java/ghidra/app/util/bin/format/elf/extend/ARM_ElfExtension.java
@@ -85,17 +85,10 @@ public class ARM_ElfExtension extends ElfExtension {
 		// if enabled PC Bias must be factored in explicitly during relocation processing
 		boolean enablePcBiasOption = false;
 
-		try {
-			elf.parse(); // ensure ELF is fully parsed to query section data
-
-			// Enable PC Bias use if Green Hills (GHS) detected
-			ElfSectionHeader section = elf.getSection(".ghsinfo");
-			if (section != null) {
-				enablePcBiasOption = true;
-			}
-		}
-		catch (IOException e) {
-			Msg.warn(this, "Failed to fully parse ELF headers to formulate ARM import options");
+		// Enable PC Bias use if Green Hills (GHS) detected
+		ElfSectionHeader section = elf.getSection(".ghsinfo");
+		if (section != null) {
+			enablePcBiasOption = true;
 		}
 
 		options.add(new Option(APPLY_PC_BIAS_TO_RELATIVE_RELOCATIONS_OPTION_NAME,
diff --git a/Ghidra/Processors/HCS12/src/main/java/ghidra/app/util/bin/format/elf/extend/HCS12X_ElfExtension.java b/Ghidra/Processors/HCS12/src/main/java/ghidra/app/util/bin/format/elf/extend/HCS12X_ElfExtension.java
index 9d417b927..652d6fd22 100644
--- a/Ghidra/Processors/HCS12/src/main/java/ghidra/app/util/bin/format/elf/extend/HCS12X_ElfExtension.java
+++ b/Ghidra/Processors/HCS12/src/main/java/ghidra/app/util/bin/format/elf/extend/HCS12X_ElfExtension.java
@@ -83,7 +83,7 @@ public class HCS12X_ElfExtension extends ElfExtension {
 
 		AddressSpace space = getPreferredSectionAddressSpace(elfLoadHelper, elfSectionHeader);
 
-		long addrWordOffset = elfSectionHeader.getAddress();
+		long addrWordOffset = elfSectionHeader.getVirtualAddress();
 
 		if (space == program.getAddressFactory().getDefaultAddressSpace()) {
 			addrWordOffset += elfLoadHelper.getImageBaseWordAdjustmentOffset();
diff --git a/Ghidra/Processors/PIC/src/main/java/ghidra/app/util/bin/format/elf/extend/PIC30_ElfExtension.java b/Ghidra/Processors/PIC/src/main/java/ghidra/app/util/bin/format/elf/extend/PIC30_ElfExtension.java
index fa7cf1990..af6b1a7c0 100644
--- a/Ghidra/Processors/PIC/src/main/java/ghidra/app/util/bin/format/elf/extend/PIC30_ElfExtension.java
+++ b/Ghidra/Processors/PIC/src/main/java/ghidra/app/util/bin/format/elf/extend/PIC30_ElfExtension.java
@@ -176,7 +176,7 @@ public class PIC30_ElfExtension extends ElfExtension {
 
 	@Override
 	public long getAdjustedSize(ElfSectionHeader section) {
-		long rawSize = section.getSize();
+		long rawSize = section.getFileSize();
 		return isDataLoad(section) ? getAdjustedDataLoadSize(rawSize) : rawSize;
 	}
 
diff --git a/Ghidra/Processors/eBPF/src/main/java/ghidra/app/util/bin/format/elf/relocation/eBPF_ElfRelocationHandler.java b/Ghidra/Processors/eBPF/src/main/java/ghidra/app/util/bin/format/elf/relocation/eBPF_ElfRelocationHandler.java
index 51c952607..cd2dbb1fd 100644
--- a/Ghidra/Processors/eBPF/src/main/java/ghidra/app/util/bin/format/elf/relocation/eBPF_ElfRelocationHandler.java
+++ b/Ghidra/Processors/eBPF/src/main/java/ghidra/app/util/bin/format/elf/relocation/eBPF_ElfRelocationHandler.java
@@ -88,7 +88,7 @@ public class eBPF_ElfRelocationHandler extends ElfRelocationHandler {
                     if (memory.getInt(relocationAddress) == 0x1085) {
 
                         ElfSectionHeader sec = elfRelocationContext.getElfHeader().getSection(func_or_sec);
-                        long sec_start = program.getImageBase().getOffset() + sec.getAddress();
+                        long sec_start = program.getImageBase().getOffset() + sec.getVirtualAddress();
 
                         // getting call instruction offset (current imm)
                         int current_imm = memory.getInt(relocationAddress.add(0x4));
-- 
2.39.1

